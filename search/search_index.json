{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00a1Bienvenido al curso de Desarrollo de Software! Este curso est\u00e1 dise\u00f1ado para proporcionarte informaci\u00f3n y recursos valiosos relacionados con el desarrollo de software en Python. A lo largo de esta gu\u00eda, explorar\u00e1s una variedad de temas importantes que te ayudar\u00e1n a convertirte en un desarrollador de Python m\u00e1s competente y eficiente. Cap\u00edtulos 1. Configuraci\u00f3n (Setup) En esta secci\u00f3n, te ayudaremos a configurar tu entorno de desarrollo de Python. Cubriremos temas como la instalaci\u00f3n de Pyenv, la creaci\u00f3n de entornos virtuales con Virtualenv, la gesti\u00f3n de paquetes y proyectos con Poetry, y c\u00f3mo utilizar Git y GitHub para el control de versiones y la colaboraci\u00f3n. 2. Programaci\u00f3n En este cap\u00edtulo, profundizaremos en conceptos de programaci\u00f3n s\u00f3lidos, como los principios SOLID, y exploraremos los patrones de dise\u00f1o comunes. Adem\u00e1s, aprender\u00e1s sobre t\u00e9cnicas de refactorizaci\u00f3n para mejorar la calidad de tu c\u00f3digo. 3. Ecosistema Esta secci\u00f3n se centra en el ecosistema de Python. Cubriremos los PEP (Python Enhancement Proposals) m\u00e1s relevantes, exploraremos diferentes paradigmas de programaci\u00f3n en Python y discutiremos temas relacionados con la tipificaci\u00f3n y Pydantic. 4. Utilidades (Utilities) Aprender\u00e1s sobre utilidades esenciales para el desarrollo en Python, como el registro de eventos (logging), la estilizaci\u00f3n de c\u00f3digo y c\u00f3mo utilizar pre-commit para automatizar tareas de preconfirmaci\u00f3n. 5. Pruebas (Testing) Exploraremos t\u00e9cnicas de prueba en Python, incluyendo una introducci\u00f3n a Pytest, c\u00f3mo medir la cobertura de c\u00f3digo, t\u00e9cnicas de simulaci\u00f3n (mocking) y c\u00f3mo utilizar la biblioteca Hypothesis para pruebas generativas. 6. Documentaci\u00f3n Aprender\u00e1s a documentar adecuadamente tus proyectos en Python. Cubriremos la creaci\u00f3n de documentaci\u00f3n con Mkdocs y Mkdocs-Material, as\u00ed como la personalizaci\u00f3n y extensi\u00f3n de tu documentaci\u00f3n con Mkdocs-Plugging. 7. Extras Aqu\u00ed encontrar\u00e1s recursos adicionales, como tutoriales y ejemplos relacionados con Diagrams y PlantUML.","title":"Home"},{"location":"#home","text":"\u00a1Bienvenido al curso de Desarrollo de Software! Este curso est\u00e1 dise\u00f1ado para proporcionarte informaci\u00f3n y recursos valiosos relacionados con el desarrollo de software en Python. A lo largo de esta gu\u00eda, explorar\u00e1s una variedad de temas importantes que te ayudar\u00e1n a convertirte en un desarrollador de Python m\u00e1s competente y eficiente.","title":"Home"},{"location":"#capitulos","text":"","title":"Cap\u00edtulos"},{"location":"#1-configuracion-setup","text":"En esta secci\u00f3n, te ayudaremos a configurar tu entorno de desarrollo de Python. Cubriremos temas como la instalaci\u00f3n de Pyenv, la creaci\u00f3n de entornos virtuales con Virtualenv, la gesti\u00f3n de paquetes y proyectos con Poetry, y c\u00f3mo utilizar Git y GitHub para el control de versiones y la colaboraci\u00f3n.","title":"1. Configuraci\u00f3n (Setup)"},{"location":"#2-programacion","text":"En este cap\u00edtulo, profundizaremos en conceptos de programaci\u00f3n s\u00f3lidos, como los principios SOLID, y exploraremos los patrones de dise\u00f1o comunes. Adem\u00e1s, aprender\u00e1s sobre t\u00e9cnicas de refactorizaci\u00f3n para mejorar la calidad de tu c\u00f3digo.","title":"2. Programaci\u00f3n"},{"location":"#3-ecosistema","text":"Esta secci\u00f3n se centra en el ecosistema de Python. Cubriremos los PEP (Python Enhancement Proposals) m\u00e1s relevantes, exploraremos diferentes paradigmas de programaci\u00f3n en Python y discutiremos temas relacionados con la tipificaci\u00f3n y Pydantic.","title":"3. Ecosistema"},{"location":"#4-utilidades-utilities","text":"Aprender\u00e1s sobre utilidades esenciales para el desarrollo en Python, como el registro de eventos (logging), la estilizaci\u00f3n de c\u00f3digo y c\u00f3mo utilizar pre-commit para automatizar tareas de preconfirmaci\u00f3n.","title":"4. Utilidades (Utilities)"},{"location":"#5-pruebas-testing","text":"Exploraremos t\u00e9cnicas de prueba en Python, incluyendo una introducci\u00f3n a Pytest, c\u00f3mo medir la cobertura de c\u00f3digo, t\u00e9cnicas de simulaci\u00f3n (mocking) y c\u00f3mo utilizar la biblioteca Hypothesis para pruebas generativas.","title":"5. Pruebas (Testing)"},{"location":"#6-documentacion","text":"Aprender\u00e1s a documentar adecuadamente tus proyectos en Python. Cubriremos la creaci\u00f3n de documentaci\u00f3n con Mkdocs y Mkdocs-Material, as\u00ed como la personalizaci\u00f3n y extensi\u00f3n de tu documentaci\u00f3n con Mkdocs-Plugging.","title":"6. Documentaci\u00f3n"},{"location":"#7-extras","text":"Aqu\u00ed encontrar\u00e1s recursos adicionales, como tutoriales y ejemplos relacionados con Diagrams y PlantUML.","title":"7. Extras"},{"location":"diagrams/diagrams/","text":"Diagrams Introducci\u00f3n El modelado visual es una parte fundamental en el desarrollo de software y en la administraci\u00f3n de infraestructura. Los diagramas ayudan a los equipos a comprender y comunicar la arquitectura, los flujos de datos y las relaciones de manera efectiva. Sin embargo, crear y mantener diagramas puede ser un proceso laborioso y propenso a errores. Diagrams es una biblioteca de Python que aborda este problema permiti\u00e9ndote crear diagramas como c\u00f3digo. Con Diagrams, puedes definir tu infraestructura o arquitectura en Python, lo que facilita la automatizaci\u00f3n, la documentaci\u00f3n y la colaboraci\u00f3n. En este art\u00edculo, exploraremos c\u00f3mo utilizar Diagrams para crear diagramas eficientes y c\u00f3mo puedes integrarlo en tus proyectos. Instalaci\u00f3n de Diagrams Antes de comenzar, necesitamos instalar Diagrams. Puedes instalar Diagrams utilizando pip , el administrador de paquetes de Python. pip install diagrams Adem\u00e1s, necesitaremos Graphviz, una herramienta para generar los diagramas. Puedes descargar Graphviz desde su sitio web oficial e instalarlo en tu sistema. Creando Diagramas con Diagrams Diagrams ofrece una forma intuitiva de crear diagramas como c\u00f3digo en Python. Comencemos con un ejemplo b\u00e1sico: from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram Importa las bibliotecas necesarias: from diagrams import Diagram : Importa la clase Diagram que se utiliza para crear el diagrama. from diagrams.aws.compute import EC2 : Importa el componente EC2 de la biblioteca \"diagrams\" que representa una instancia de Amazon EC2. Crea un nuevo diagrama con el nombre \"Diagrama Simple\" utilizando la clase Diagram . El par\u00e1metro show=False se utiliza para indicar que el diagrama no se debe mostrar autom\u00e1ticamente cuando se crea. Dentro del bloque with , se define un componente EC2 llamado \"web\" utilizando la clase EC2 . Este componente representa una instancia de servidor virtual en la nube de Amazon Web Services (AWS) y se etiqueta como \"web\". El diagrama se cierra autom\u00e1ticamente al finalizar el bloque with . Finalmente, el diagrama se muestra utilizando la variable diagram , que contiene la representaci\u00f3n visual del diagrama. Tipos de componentes La biblioteca \"diagrams\" proporciona componentes para una variedad de proveedores y tipos de recursos, lo que la hace vers\u00e1til y adecuada para diferentes casos de uso. Aqu\u00ed hay una descripci\u00f3n de los tipos de componentes m\u00e1s comunes disponibles en \"diagrams\": AWS/GCP/Azure Estos proveedores ofrecen componentes que representan los activos oficiales de los servicios en la nube de Amazon Web Services (AWS), Google Cloud Platform (GCP) y Microsoft Azure. Puede utilizar estos componentes para crear diagramas que representen la infraestructura en la nube de estos proveedores, como instancias EC2, bases de datos RDS, servicios de Azure, etc. Ejemplo: from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS with Diagram ( \"Arquitectura AWS\" , show = False ) as diagram : web_server = EC2 ( \"Servidor Web\" ) database = RDS ( \"Base de Datos\" ) web_server >> database diagram Generic and On-Premise Estos componentes son \u00fatiles cuando desea representar tecnolog\u00edas subyacentes que no est\u00e1n vinculadas a un proveedor de la nube espec\u00edfico o que se ejecutan en entornos locales (on-premise). Puede utilizar estos componentes para crear diagramas independientes de la nube. Ejemplo: from diagrams import Diagram from diagrams.generic.network import Switch , Router from diagrams.onprem.client import User from diagrams.onprem.compute import Server from diagrams.generic.os import LinuxGeneral with Diagram ( \"Arquitectura On-Premise\" , show = False ) as diagram : user = User ( \"Usuario\" ) switch = Switch ( \"Switch\" ) router = Router ( \"Router\" ) server = Server ( \"Servidor\" ) linux = LinuxGeneral ( \"Linux\" ) user >> switch >> router >> server >> linux diagram Frameworks Estos componentes son \u00fatiles cuando desea representar componentes de sistemas relacionados con un lenguaje de programaci\u00f3n o un marco de trabajo espec\u00edfico. Esto es \u00fatil para mostrar c\u00f3mo se integran diferentes tecnolog\u00edas en su sistema. Ejemplo: from diagrams.programming.framework import React from diagrams.programming.framework import Fastapi with Diagram ( \"Arquitectura de Aplicaci\u00f3n Web\" , show = False ) as diagram : frontend = React ( \"Frontend\" ) backend = Fastapi ( \"Backend\" ) frontend >> backend diagram SaaS La biblioteca \"diagrams\" tambi\u00e9n proporciona componentes para representar Software como Servicio (SaaS) que se pueden utilizar en su arquitectura. Esto es \u00fatil cuando desea mostrar integraciones con servicios externos como Slack, Gmail, etc. Ejemplo: from diagrams.gcp.ml import AIPlatform from diagrams.saas.chat import Slack with Diagram ( \"Integraci\u00f3n con SaaS\" , show = False ) as diagram : app = AIPlatform ( \"Tu Aplicaci\u00f3n\" ) slack = Slack ( \"Slack\" ) app >> slack diagram M\u00e1s conceptos Nodes Node es un segundo objeto que representa un nodo o componente del sistema. Node es un concepto abstracto que representa un \u00fanico objeto componente del sistema. Un objeto Node consta de tres partes: proveedor, tipo de recurso y nombre. Es posible que ya haya visto cada parte en el ejemplo anterior. from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram En el ejemplo anterior, EC2 es un nodo de tipo de recurso inform\u00e1tico proporcionado por el proveedor de AWS . Data Flow Puede representar el flujo de datos conectando los nodos con estos operadores: >> : Conecta los nodos de izquierda a derecha. << : Conecta los nodos de derecha a izquierda. - : Conecta nodos en ninguna direcci\u00f3n. No dirigido. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB from diagrams.aws.storage import S3 with Diagram ( \"Web Services\" , show = False ) as node : ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) >> S3 ( \"store\" ) ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) << EC2 ( \"stat\" ) ( ELB ( \"lb\" ) >> EC2 ( \"web\" )) - EC2 ( \"web\" ) >> RDS ( \"userdb\" ) node Tenga cuidado al usar `-` y cualquier operador de turno juntos, lo que podr\u00eda causar resultados inesperados debido a la precedencia del operador. El orden de los diagramas renderizados es el inverso del orden de declaraci\u00f3n. Puede cambiar la direcci\u00f3n del flujo de datos con el par\u00e1metro direction . El valor predeterminado es LR . (TB, BT, LR y RL) est\u00e1n permitidos. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Workers\" , show = False , direction = \"TB\" ) as node : lb = ELB ( \"lb\" ) db = RDS ( \"events\" ) lb >> EC2 ( \"worker1\" ) >> db lb >> EC2 ( \"worker2\" ) >> db lb >> EC2 ( \"worker3\" ) >> db lb >> EC2 ( \"worker4\" ) >> db lb >> EC2 ( \"worker5\" ) >> db node Group Data Flow El ejemplo del worker anterior tiene demasiados flujos redundantes. En este caso, puede agrupar nodos en una lista para que todos los nodos est\u00e9n conectados a otros nodos a la vez. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Grouped Workers\" , show = False , direction = \"TB\" ) as node : ELB ( \"lb\" ) >> [ EC2 ( \"worker1\" ), EC2 ( \"worker2\" ), EC2 ( \"worker3\" ), EC2 ( \"worker4\" ), EC2 ( \"worker5\" )] >> RDS ( \"events\" ) node No puede conectar dos listas directamente porque las operaciones `shift/arithmetic` entre listas no est\u00e1n permitidas en Python. Clusters Cluster le permite agrupar (o agrupar) los nodos en un grupo aislado. Cluster representa un contexto de cl\u00faster local. Puede crear un contexto de cl\u00faster con la clase Cluster . Y tambi\u00e9n puede conectar los nodos de un cl\u00faster a otros nodos fuera de un cl\u00faster. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS from diagrams.aws.database import RDS from diagrams.aws.network import Route53 with Diagram ( \"Simple Web Service with DB Cluster\" , show = False ) as cluster : dns = Route53 ( \"dns\" ) web = ECS ( \"service\" ) with Cluster ( \"DB Cluster\" ): db_master = RDS ( \"master\" ) db_master - [ RDS ( \"slave1\" ), RDS ( \"slave2\" )] dns >> web >> db_master cluster Nested Clusters Tambi\u00e9n es posible la agrupaci\u00f3n en cl\u00fasteres anidados. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS , EKS , Lambda from diagrams.aws.database import Redshift from diagrams.aws.integration import SQS from diagrams.aws.storage import S3 with Diagram ( \"Event Processing\" , show = False ) as cluster : source = EKS ( \"k8s source\" ) with Cluster ( \"Event Flows\" ): with Cluster ( \"Event Workers\" ): workers = [ ECS ( \"worker1\" ), ECS ( \"worker2\" ), ECS ( \"worker3\" )] queue = SQS ( \"event queue\" ) with Cluster ( \"Processing\" ): handlers = [ Lambda ( \"proc1\" ), Lambda ( \"proc2\" ), Lambda ( \"proc3\" )] store = S3 ( \"events store\" ) dw = Redshift ( \"analytics\" ) source >> workers >> queue >> handlers handlers >> store handlers >> dw cluster No hay l\u00edmite de profundidad de anidaci\u00f3n. Si\u00e9ntase libre de crear cl\u00fasteres anidados con la profundidad que desee. Edges Edge representa un borde entre nodos. Edge es un objeto que representa una conexi\u00f3n entre nodos con algunas propiedades adicionales. Un objeto Edge contiene tres atributos: etiqueta, color y estilo que reflejan los atributos de borde de graphviz correspondientes. from diagrams import Cluster , Diagram , Edge from diagrams.onprem.analytics import Spark from diagrams.onprem.compute import Server from diagrams.onprem.database import PostgreSQL from diagrams.onprem.inmemory import Redis from diagrams.onprem.aggregator import Fluentd from diagrams.onprem.monitoring import Grafana , Prometheus from diagrams.onprem.network import Nginx from diagrams.onprem.queue import Kafka with Diagram ( name = \"Advanced Web Service with On-Premise (colored)\" , show = False ) as edges : ingress = Nginx ( \"ingress\" ) metrics = Prometheus ( \"metric\" ) metrics << Edge ( color = \"firebrick\" , style = \"dashed\" ) << Grafana ( \"monitoring\" ) with Cluster ( \"Service Cluster\" ): grpcsvc = [ Server ( \"grpc1\" ), Server ( \"grpc2\" ), Server ( \"grpc3\" )] with Cluster ( \"Sessions HA\" ): master = Redis ( \"session\" ) master - Edge ( color = \"brown\" , style = \"dashed\" ) - Redis ( \"replica\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"brown\" ) >> master with Cluster ( \"Database HA\" ): master = PostgreSQL ( \"users\" ) master - Edge ( color = \"brown\" , style = \"dotted\" ) - PostgreSQL ( \"slave\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"black\" ) >> master aggregator = Fluentd ( \"logging\" ) aggregator >> Edge ( label = \"parse\" ) >> Kafka ( \"stream\" ) >> Edge ( color = \"black\" , style = \"bold\" ) >> Spark ( \"analytics\" ) ingress >> Edge ( color = \"darkgreen\" ) << grpcsvc >> Edge ( color = \"darkorange\" ) >> aggregator edges Warning: Orthogonal edges do not currently handle edge labels. Try using xlabels. Conclusi\u00f3n Diagrams es una herramienta poderosa que facilita la creaci\u00f3n de diagramas como c\u00f3digo en Python. Te permite representar infraestructuras y arquitecturas de manera eficiente, lo que es \u00fatil para la documentaci\u00f3n, la colaboraci\u00f3n y la automatizaci\u00f3n. Al utilizar Diagrams, puedes mejorar la comprensi\u00f3n y la comunicaci\u00f3n de tus dise\u00f1os y proyectos. Referencias Repositorio oficial de Diagrams en GitHub Documentaci\u00f3n oficial de Diagrams Ejemplos adicionales de Diagrams","title":"Diagrams"},{"location":"diagrams/diagrams/#diagrams","text":"","title":"Diagrams"},{"location":"diagrams/diagrams/#introduccion","text":"El modelado visual es una parte fundamental en el desarrollo de software y en la administraci\u00f3n de infraestructura. Los diagramas ayudan a los equipos a comprender y comunicar la arquitectura, los flujos de datos y las relaciones de manera efectiva. Sin embargo, crear y mantener diagramas puede ser un proceso laborioso y propenso a errores. Diagrams es una biblioteca de Python que aborda este problema permiti\u00e9ndote crear diagramas como c\u00f3digo. Con Diagrams, puedes definir tu infraestructura o arquitectura en Python, lo que facilita la automatizaci\u00f3n, la documentaci\u00f3n y la colaboraci\u00f3n. En este art\u00edculo, exploraremos c\u00f3mo utilizar Diagrams para crear diagramas eficientes y c\u00f3mo puedes integrarlo en tus proyectos.","title":"Introducci\u00f3n"},{"location":"diagrams/diagrams/#instalacion-de-diagrams","text":"Antes de comenzar, necesitamos instalar Diagrams. Puedes instalar Diagrams utilizando pip , el administrador de paquetes de Python. pip install diagrams Adem\u00e1s, necesitaremos Graphviz, una herramienta para generar los diagramas. Puedes descargar Graphviz desde su sitio web oficial e instalarlo en tu sistema.","title":"Instalaci\u00f3n de Diagrams"},{"location":"diagrams/diagrams/#creando-diagramas-con-diagrams","text":"Diagrams ofrece una forma intuitiva de crear diagramas como c\u00f3digo en Python. Comencemos con un ejemplo b\u00e1sico: from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram Importa las bibliotecas necesarias: from diagrams import Diagram : Importa la clase Diagram que se utiliza para crear el diagrama. from diagrams.aws.compute import EC2 : Importa el componente EC2 de la biblioteca \"diagrams\" que representa una instancia de Amazon EC2. Crea un nuevo diagrama con el nombre \"Diagrama Simple\" utilizando la clase Diagram . El par\u00e1metro show=False se utiliza para indicar que el diagrama no se debe mostrar autom\u00e1ticamente cuando se crea. Dentro del bloque with , se define un componente EC2 llamado \"web\" utilizando la clase EC2 . Este componente representa una instancia de servidor virtual en la nube de Amazon Web Services (AWS) y se etiqueta como \"web\". El diagrama se cierra autom\u00e1ticamente al finalizar el bloque with . Finalmente, el diagrama se muestra utilizando la variable diagram , que contiene la representaci\u00f3n visual del diagrama.","title":"Creando Diagramas con Diagrams"},{"location":"diagrams/diagrams/#tipos-de-componentes","text":"La biblioteca \"diagrams\" proporciona componentes para una variedad de proveedores y tipos de recursos, lo que la hace vers\u00e1til y adecuada para diferentes casos de uso. Aqu\u00ed hay una descripci\u00f3n de los tipos de componentes m\u00e1s comunes disponibles en \"diagrams\":","title":"Tipos de componentes"},{"location":"diagrams/diagrams/#awsgcpazure","text":"Estos proveedores ofrecen componentes que representan los activos oficiales de los servicios en la nube de Amazon Web Services (AWS), Google Cloud Platform (GCP) y Microsoft Azure. Puede utilizar estos componentes para crear diagramas que representen la infraestructura en la nube de estos proveedores, como instancias EC2, bases de datos RDS, servicios de Azure, etc. Ejemplo: from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS with Diagram ( \"Arquitectura AWS\" , show = False ) as diagram : web_server = EC2 ( \"Servidor Web\" ) database = RDS ( \"Base de Datos\" ) web_server >> database diagram","title":"AWS/GCP/Azure"},{"location":"diagrams/diagrams/#generic-and-on-premise","text":"Estos componentes son \u00fatiles cuando desea representar tecnolog\u00edas subyacentes que no est\u00e1n vinculadas a un proveedor de la nube espec\u00edfico o que se ejecutan en entornos locales (on-premise). Puede utilizar estos componentes para crear diagramas independientes de la nube. Ejemplo: from diagrams import Diagram from diagrams.generic.network import Switch , Router from diagrams.onprem.client import User from diagrams.onprem.compute import Server from diagrams.generic.os import LinuxGeneral with Diagram ( \"Arquitectura On-Premise\" , show = False ) as diagram : user = User ( \"Usuario\" ) switch = Switch ( \"Switch\" ) router = Router ( \"Router\" ) server = Server ( \"Servidor\" ) linux = LinuxGeneral ( \"Linux\" ) user >> switch >> router >> server >> linux diagram","title":"Generic and On-Premise"},{"location":"diagrams/diagrams/#frameworks","text":"Estos componentes son \u00fatiles cuando desea representar componentes de sistemas relacionados con un lenguaje de programaci\u00f3n o un marco de trabajo espec\u00edfico. Esto es \u00fatil para mostrar c\u00f3mo se integran diferentes tecnolog\u00edas en su sistema. Ejemplo: from diagrams.programming.framework import React from diagrams.programming.framework import Fastapi with Diagram ( \"Arquitectura de Aplicaci\u00f3n Web\" , show = False ) as diagram : frontend = React ( \"Frontend\" ) backend = Fastapi ( \"Backend\" ) frontend >> backend diagram","title":"Frameworks"},{"location":"diagrams/diagrams/#saas","text":"La biblioteca \"diagrams\" tambi\u00e9n proporciona componentes para representar Software como Servicio (SaaS) que se pueden utilizar en su arquitectura. Esto es \u00fatil cuando desea mostrar integraciones con servicios externos como Slack, Gmail, etc. Ejemplo: from diagrams.gcp.ml import AIPlatform from diagrams.saas.chat import Slack with Diagram ( \"Integraci\u00f3n con SaaS\" , show = False ) as diagram : app = AIPlatform ( \"Tu Aplicaci\u00f3n\" ) slack = Slack ( \"Slack\" ) app >> slack diagram","title":"SaaS"},{"location":"diagrams/diagrams/#mas-conceptos","text":"","title":"M\u00e1s conceptos"},{"location":"diagrams/diagrams/#nodes","text":"Node es un segundo objeto que representa un nodo o componente del sistema. Node es un concepto abstracto que representa un \u00fanico objeto componente del sistema. Un objeto Node consta de tres partes: proveedor, tipo de recurso y nombre. Es posible que ya haya visto cada parte en el ejemplo anterior. from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram En el ejemplo anterior, EC2 es un nodo de tipo de recurso inform\u00e1tico proporcionado por el proveedor de AWS .","title":"Nodes"},{"location":"diagrams/diagrams/#data-flow","text":"Puede representar el flujo de datos conectando los nodos con estos operadores: >> : Conecta los nodos de izquierda a derecha. << : Conecta los nodos de derecha a izquierda. - : Conecta nodos en ninguna direcci\u00f3n. No dirigido. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB from diagrams.aws.storage import S3 with Diagram ( \"Web Services\" , show = False ) as node : ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) >> S3 ( \"store\" ) ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) << EC2 ( \"stat\" ) ( ELB ( \"lb\" ) >> EC2 ( \"web\" )) - EC2 ( \"web\" ) >> RDS ( \"userdb\" ) node Tenga cuidado al usar `-` y cualquier operador de turno juntos, lo que podr\u00eda causar resultados inesperados debido a la precedencia del operador. El orden de los diagramas renderizados es el inverso del orden de declaraci\u00f3n. Puede cambiar la direcci\u00f3n del flujo de datos con el par\u00e1metro direction . El valor predeterminado es LR . (TB, BT, LR y RL) est\u00e1n permitidos. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Workers\" , show = False , direction = \"TB\" ) as node : lb = ELB ( \"lb\" ) db = RDS ( \"events\" ) lb >> EC2 ( \"worker1\" ) >> db lb >> EC2 ( \"worker2\" ) >> db lb >> EC2 ( \"worker3\" ) >> db lb >> EC2 ( \"worker4\" ) >> db lb >> EC2 ( \"worker5\" ) >> db node","title":"Data Flow"},{"location":"diagrams/diagrams/#group-data-flow","text":"El ejemplo del worker anterior tiene demasiados flujos redundantes. En este caso, puede agrupar nodos en una lista para que todos los nodos est\u00e9n conectados a otros nodos a la vez. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Grouped Workers\" , show = False , direction = \"TB\" ) as node : ELB ( \"lb\" ) >> [ EC2 ( \"worker1\" ), EC2 ( \"worker2\" ), EC2 ( \"worker3\" ), EC2 ( \"worker4\" ), EC2 ( \"worker5\" )] >> RDS ( \"events\" ) node No puede conectar dos listas directamente porque las operaciones `shift/arithmetic` entre listas no est\u00e1n permitidas en Python.","title":"Group Data Flow"},{"location":"diagrams/diagrams/#clusters","text":"Cluster le permite agrupar (o agrupar) los nodos en un grupo aislado. Cluster representa un contexto de cl\u00faster local. Puede crear un contexto de cl\u00faster con la clase Cluster . Y tambi\u00e9n puede conectar los nodos de un cl\u00faster a otros nodos fuera de un cl\u00faster. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS from diagrams.aws.database import RDS from diagrams.aws.network import Route53 with Diagram ( \"Simple Web Service with DB Cluster\" , show = False ) as cluster : dns = Route53 ( \"dns\" ) web = ECS ( \"service\" ) with Cluster ( \"DB Cluster\" ): db_master = RDS ( \"master\" ) db_master - [ RDS ( \"slave1\" ), RDS ( \"slave2\" )] dns >> web >> db_master cluster","title":"Clusters"},{"location":"diagrams/diagrams/#nested-clusters","text":"Tambi\u00e9n es posible la agrupaci\u00f3n en cl\u00fasteres anidados. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS , EKS , Lambda from diagrams.aws.database import Redshift from diagrams.aws.integration import SQS from diagrams.aws.storage import S3 with Diagram ( \"Event Processing\" , show = False ) as cluster : source = EKS ( \"k8s source\" ) with Cluster ( \"Event Flows\" ): with Cluster ( \"Event Workers\" ): workers = [ ECS ( \"worker1\" ), ECS ( \"worker2\" ), ECS ( \"worker3\" )] queue = SQS ( \"event queue\" ) with Cluster ( \"Processing\" ): handlers = [ Lambda ( \"proc1\" ), Lambda ( \"proc2\" ), Lambda ( \"proc3\" )] store = S3 ( \"events store\" ) dw = Redshift ( \"analytics\" ) source >> workers >> queue >> handlers handlers >> store handlers >> dw cluster No hay l\u00edmite de profundidad de anidaci\u00f3n. Si\u00e9ntase libre de crear cl\u00fasteres anidados con la profundidad que desee.","title":"Nested Clusters"},{"location":"diagrams/diagrams/#edges","text":"Edge representa un borde entre nodos. Edge es un objeto que representa una conexi\u00f3n entre nodos con algunas propiedades adicionales. Un objeto Edge contiene tres atributos: etiqueta, color y estilo que reflejan los atributos de borde de graphviz correspondientes. from diagrams import Cluster , Diagram , Edge from diagrams.onprem.analytics import Spark from diagrams.onprem.compute import Server from diagrams.onprem.database import PostgreSQL from diagrams.onprem.inmemory import Redis from diagrams.onprem.aggregator import Fluentd from diagrams.onprem.monitoring import Grafana , Prometheus from diagrams.onprem.network import Nginx from diagrams.onprem.queue import Kafka with Diagram ( name = \"Advanced Web Service with On-Premise (colored)\" , show = False ) as edges : ingress = Nginx ( \"ingress\" ) metrics = Prometheus ( \"metric\" ) metrics << Edge ( color = \"firebrick\" , style = \"dashed\" ) << Grafana ( \"monitoring\" ) with Cluster ( \"Service Cluster\" ): grpcsvc = [ Server ( \"grpc1\" ), Server ( \"grpc2\" ), Server ( \"grpc3\" )] with Cluster ( \"Sessions HA\" ): master = Redis ( \"session\" ) master - Edge ( color = \"brown\" , style = \"dashed\" ) - Redis ( \"replica\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"brown\" ) >> master with Cluster ( \"Database HA\" ): master = PostgreSQL ( \"users\" ) master - Edge ( color = \"brown\" , style = \"dotted\" ) - PostgreSQL ( \"slave\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"black\" ) >> master aggregator = Fluentd ( \"logging\" ) aggregator >> Edge ( label = \"parse\" ) >> Kafka ( \"stream\" ) >> Edge ( color = \"black\" , style = \"bold\" ) >> Spark ( \"analytics\" ) ingress >> Edge ( color = \"darkgreen\" ) << grpcsvc >> Edge ( color = \"darkorange\" ) >> aggregator edges Warning: Orthogonal edges do not currently handle edge labels. Try using xlabels.","title":"Edges"},{"location":"diagrams/diagrams/#conclusion","text":"Diagrams es una herramienta poderosa que facilita la creaci\u00f3n de diagramas como c\u00f3digo en Python. Te permite representar infraestructuras y arquitecturas de manera eficiente, lo que es \u00fatil para la documentaci\u00f3n, la colaboraci\u00f3n y la automatizaci\u00f3n. Al utilizar Diagrams, puedes mejorar la comprensi\u00f3n y la comunicaci\u00f3n de tus dise\u00f1os y proyectos.","title":"Conclusi\u00f3n"},{"location":"diagrams/diagrams/#referencias","text":"Repositorio oficial de Diagrams en GitHub Documentaci\u00f3n oficial de Diagrams Ejemplos adicionales de Diagrams","title":"Referencias"},{"location":"diagrams/plantuml/","text":"PlantUML Introducci\u00f3n El modelado visual es una parte esencial del desarrollo de software. Ayuda a los equipos de desarrollo a comprender, comunicar y documentar sus dise\u00f1os y arquitecturas de manera efectiva. Uno de los est\u00e1ndares m\u00e1s ampliamente utilizados para el modelado visual en el desarrollo de software es UML (Unified Modeling Language). PlantUML es una herramienta que simplifica la creaci\u00f3n de diagramas UML y otros tipos de diagramas de modelado visual. Utiliza una sintaxis de marcado de texto simple y genera autom\u00e1ticamente diagramas visuales de alta calidad. En este art\u00edculo, exploraremos c\u00f3mo utilizar PlantUML para crear diagramas efectivos y c\u00f3mo puedes integrarlo en tus proyectos de Python y Jupyter Notebook. Instalaci\u00f3n de PlantUML Antes de comenzar, necesitamos instalar PlantUML. PlantUML se ejecuta en la m\u00e1quina virtual de Java, por lo que debes asegurarte de tener Java instalado en tu sistema. Luego, puedes descargar la \u00faltima versi\u00f3n desde el siguiente enlace . Adem\u00e1s, necesitaremos Graphviz, una herramienta para la visualizaci\u00f3n de grafos que PlantUML utiliza para generar diagramas. Puedes descargar Graphviz desde su sitio web oficial e instalarlo en tu sistema. Creando Diagramas con PlantUML Nota : Para estos ejemplos, utilizaremos iPlantUML para generar los diagramas de PlantUML en Jupyter Notebook. PlantUML utiliza una sintaxis basada en texto para definir diagramas. Puedes crear diagramas UML, diagramas de flujo, diagramas de secuencia y m\u00e1s utilizando esta sintaxis simple. Aqu\u00ed hay un ejemplo de un diagrama de clases UML b\u00e1sico: import iplantuml %% plantuml @startuml class Car { + startEngine () + stopEngine () + accelerate () + brake () } Car --> Engine @enduml Este c\u00f3digo define una clase Car con cuatro m\u00e9todos y establece una relaci\u00f3n con la clase Engine . Para generar un diagrama a partir de este c\u00f3digo, puedes usar el comando plantuml desde la l\u00ednea de comandos: plantuml diagrama.clase.uml Esto generar\u00e1 una imagen del diagrama UML en el archivo diagrama.clase.png . Sintaxis B\u00e1sica de PlantUML PlantUML ofrece una variedad de elementos de diagrama y relaciones que puedes utilizar en tus diagramas. Aqu\u00ed hay algunos ejemplos de la sintaxis b\u00e1sica de PlantUML: Clases y Objetos %% plantuml @startuml class Car object myCar @enduml M\u00e9todos y Atributos %% plantuml @startuml class Car { + startEngine () - stopEngine () #accelerate() ~ brake () gear : int } @enduml Relaciones %% plantuml @startuml class Car class Engine Car --> Engine @enduml Diagramas de Flujo %% plantuml @startuml start : Start Process ; if ( Condition ) then ( Yes ) : Action If True ; else ( No ) : Action If False ; endif stop @enduml Ejemplos Pr\u00e1cticos con PlantUML Diagrama de Clases UML Veamos un ejemplo m\u00e1s detallado de un diagrama de clases UML. Supongamos que estamos modelando una aplicaci\u00f3n de biblioteca. Aqu\u00ed est\u00e1 el c\u00f3digo PlantUML para un diagrama de clases que representa esta aplicaci\u00f3n: %% plantuml @startuml class Library { - name : String - location : String - books : List < Book > + addBook ( book : Book ): void + removeBook ( book : Book ): void + getAvailableBooks (): List < Book > } class Book { - title : String - author : String - ISBN : String - available : boolean } Library \"1\" -- \"0..*\" Book @enduml Este c\u00f3digo define dos clases, Library y Book , con atributos y m\u00e9todos relevantes. Tambi\u00e9n establece una relaci\u00f3n entre las clases Library y Book para representar que una biblioteca puede contener m\u00faltiples libros. Diagrama de Secuencia Un diagrama de secuencia es \u00fatil para visualizar la interacci\u00f3n entre objetos a lo largo del tiempo. Supongamos que estamos modelando un sistema de reserva de vuelos. Aqu\u00ed est\u00e1 el c\u00f3digo PlantUML para un diagrama de secuencia que representa la reserva de un vuelo: %% plantuml @startuml actor User participant FlightReservationSystem participant Flight User -> FlightReservationSystem : Initiate Reservation activate FlightReservationSystem User -> FlightReservationSystem : Select Flight User -> FlightReservationSystem : Enter Passenger Details User <- FlightReservationSystem : Confirm Reservation deactivate FlightReservationSystem User -> Flight : Make Payment User <- Flight : Reservation Confirmation @enduml Este diagrama muestra c\u00f3mo el usuario interact\u00faa con el sistema de reserva de vuelos y c\u00f3mo se comunica con el objeto Flight para confirmar la reserva. Conclusi\u00f3n PlantUML es una herramienta poderosa para el modelado visual que facilita la creaci\u00f3n de diagramas UML y otros tipos de diagramas. Su sintaxis basada en texto es f\u00e1cil de aprender y su integraci\u00f3n con Python y Jupyter Notebook lo hace a\u00fan m\u00e1s vers\u00e1til. Al agregar diagramas visuales a tu documentaci\u00f3n y presentaciones, puedes mejorar la comunicaci\u00f3n y comprensi\u00f3n de tus dise\u00f1os y arquitecturas de software. Referencias Sitio web oficial de PlantUML Repositorio de Graphviz UML Distilled: A Brief Guide to the Standard Object Modeling Language","title":"PlantUML"},{"location":"diagrams/plantuml/#plantuml","text":"","title":"PlantUML"},{"location":"diagrams/plantuml/#introduccion","text":"El modelado visual es una parte esencial del desarrollo de software. Ayuda a los equipos de desarrollo a comprender, comunicar y documentar sus dise\u00f1os y arquitecturas de manera efectiva. Uno de los est\u00e1ndares m\u00e1s ampliamente utilizados para el modelado visual en el desarrollo de software es UML (Unified Modeling Language). PlantUML es una herramienta que simplifica la creaci\u00f3n de diagramas UML y otros tipos de diagramas de modelado visual. Utiliza una sintaxis de marcado de texto simple y genera autom\u00e1ticamente diagramas visuales de alta calidad. En este art\u00edculo, exploraremos c\u00f3mo utilizar PlantUML para crear diagramas efectivos y c\u00f3mo puedes integrarlo en tus proyectos de Python y Jupyter Notebook.","title":"Introducci\u00f3n"},{"location":"diagrams/plantuml/#instalacion-de-plantuml","text":"Antes de comenzar, necesitamos instalar PlantUML. PlantUML se ejecuta en la m\u00e1quina virtual de Java, por lo que debes asegurarte de tener Java instalado en tu sistema. Luego, puedes descargar la \u00faltima versi\u00f3n desde el siguiente enlace . Adem\u00e1s, necesitaremos Graphviz, una herramienta para la visualizaci\u00f3n de grafos que PlantUML utiliza para generar diagramas. Puedes descargar Graphviz desde su sitio web oficial e instalarlo en tu sistema.","title":"Instalaci\u00f3n de PlantUML"},{"location":"diagrams/plantuml/#creando-diagramas-con-plantuml","text":"Nota : Para estos ejemplos, utilizaremos iPlantUML para generar los diagramas de PlantUML en Jupyter Notebook. PlantUML utiliza una sintaxis basada en texto para definir diagramas. Puedes crear diagramas UML, diagramas de flujo, diagramas de secuencia y m\u00e1s utilizando esta sintaxis simple. Aqu\u00ed hay un ejemplo de un diagrama de clases UML b\u00e1sico: import iplantuml %% plantuml @startuml class Car { + startEngine () + stopEngine () + accelerate () + brake () } Car --> Engine @enduml Este c\u00f3digo define una clase Car con cuatro m\u00e9todos y establece una relaci\u00f3n con la clase Engine . Para generar un diagrama a partir de este c\u00f3digo, puedes usar el comando plantuml desde la l\u00ednea de comandos: plantuml diagrama.clase.uml Esto generar\u00e1 una imagen del diagrama UML en el archivo diagrama.clase.png .","title":"Creando Diagramas con PlantUML"},{"location":"diagrams/plantuml/#sintaxis-basica-de-plantuml","text":"PlantUML ofrece una variedad de elementos de diagrama y relaciones que puedes utilizar en tus diagramas. Aqu\u00ed hay algunos ejemplos de la sintaxis b\u00e1sica de PlantUML:","title":"Sintaxis B\u00e1sica de PlantUML"},{"location":"diagrams/plantuml/#clases-y-objetos","text":"%% plantuml @startuml class Car object myCar @enduml","title":"Clases y Objetos"},{"location":"diagrams/plantuml/#metodos-y-atributos","text":"%% plantuml @startuml class Car { + startEngine () - stopEngine () #accelerate() ~ brake () gear : int } @enduml","title":"M\u00e9todos y Atributos"},{"location":"diagrams/plantuml/#relaciones","text":"%% plantuml @startuml class Car class Engine Car --> Engine @enduml","title":"Relaciones"},{"location":"diagrams/plantuml/#diagramas-de-flujo","text":"%% plantuml @startuml start : Start Process ; if ( Condition ) then ( Yes ) : Action If True ; else ( No ) : Action If False ; endif stop @enduml","title":"Diagramas de Flujo"},{"location":"diagrams/plantuml/#ejemplos-practicos-con-plantuml","text":"","title":"Ejemplos Pr\u00e1cticos con PlantUML"},{"location":"diagrams/plantuml/#diagrama-de-clases-uml","text":"Veamos un ejemplo m\u00e1s detallado de un diagrama de clases UML. Supongamos que estamos modelando una aplicaci\u00f3n de biblioteca. Aqu\u00ed est\u00e1 el c\u00f3digo PlantUML para un diagrama de clases que representa esta aplicaci\u00f3n: %% plantuml @startuml class Library { - name : String - location : String - books : List < Book > + addBook ( book : Book ): void + removeBook ( book : Book ): void + getAvailableBooks (): List < Book > } class Book { - title : String - author : String - ISBN : String - available : boolean } Library \"1\" -- \"0..*\" Book @enduml Este c\u00f3digo define dos clases, Library y Book , con atributos y m\u00e9todos relevantes. Tambi\u00e9n establece una relaci\u00f3n entre las clases Library y Book para representar que una biblioteca puede contener m\u00faltiples libros.","title":"Diagrama de Clases UML"},{"location":"diagrams/plantuml/#diagrama-de-secuencia","text":"Un diagrama de secuencia es \u00fatil para visualizar la interacci\u00f3n entre objetos a lo largo del tiempo. Supongamos que estamos modelando un sistema de reserva de vuelos. Aqu\u00ed est\u00e1 el c\u00f3digo PlantUML para un diagrama de secuencia que representa la reserva de un vuelo: %% plantuml @startuml actor User participant FlightReservationSystem participant Flight User -> FlightReservationSystem : Initiate Reservation activate FlightReservationSystem User -> FlightReservationSystem : Select Flight User -> FlightReservationSystem : Enter Passenger Details User <- FlightReservationSystem : Confirm Reservation deactivate FlightReservationSystem User -> Flight : Make Payment User <- Flight : Reservation Confirmation @enduml Este diagrama muestra c\u00f3mo el usuario interact\u00faa con el sistema de reserva de vuelos y c\u00f3mo se comunica con el objeto Flight para confirmar la reserva.","title":"Diagrama de Secuencia"},{"location":"diagrams/plantuml/#conclusion","text":"PlantUML es una herramienta poderosa para el modelado visual que facilita la creaci\u00f3n de diagramas UML y otros tipos de diagramas. Su sintaxis basada en texto es f\u00e1cil de aprender y su integraci\u00f3n con Python y Jupyter Notebook lo hace a\u00fan m\u00e1s vers\u00e1til. Al agregar diagramas visuales a tu documentaci\u00f3n y presentaciones, puedes mejorar la comunicaci\u00f3n y comprensi\u00f3n de tus dise\u00f1os y arquitecturas de software.","title":"Conclusi\u00f3n"},{"location":"diagrams/plantuml/#referencias","text":"Sitio web oficial de PlantUML Repositorio de Graphviz UML Distilled: A Brief Guide to the Standard Object Modeling Language","title":"Referencias"},{"location":"documentation/intro/","text":"Documentaci\u00f3n en Python: Mejores Pr\u00e1cticas y Herramientas La documentaci\u00f3n es una parte fundamental del desarrollo de software. Proporciona informaci\u00f3n esencial para los desarrolladores, usuarios y colaboradores sobre c\u00f3mo utilizar y contribuir a un proyecto. En Python, existen buenas pr\u00e1cticas y herramientas que hacen que la creaci\u00f3n y mantenimiento de la documentaci\u00f3n sea m\u00e1s f\u00e1cil y efectiva. En este art\u00edculo, exploraremos la importancia de la documentaci\u00f3n, los diferentes estilos de docstrings y dos de las principales herramientas de documentaci\u00f3n en Python: Sphinx y Markdown. Importancia de la Documentaci\u00f3n La documentaci\u00f3n es una forma de comunicaci\u00f3n clave en el desarrollo de software. Proporciona claridad y contexto sobre el prop\u00f3sito, el funcionamiento y el uso de un proyecto. Algunas de las razones por las que la documentaci\u00f3n es importante incluyen: Facilita el Uso : Permite a los usuarios comprender c\u00f3mo usar una biblioteca o aplicaci\u00f3n sin necesidad de leer el c\u00f3digo fuente. Colaboraci\u00f3n Eficiente : Ayuda a los colaboradores a comprender c\u00f3mo contribuir al proyecto y a mantener un est\u00e1ndar com\u00fan. Resoluci\u00f3n de Problemas : Facilita la soluci\u00f3n de problemas al proporcionar informaci\u00f3n sobre errores comunes y ejemplos de uso. Mantenimiento Sostenible : Permite que un proyecto sea mantenible a lo largo del tiempo, incluso si los desarrolladores originales ya no est\u00e1n disponibles. Docstrings Los docstrings en Python son cadenas de documentaci\u00f3n que se utilizan para describir el prop\u00f3sito y el funcionamiento de m\u00f3dulos, clases, funciones y m\u00e9todos en el c\u00f3digo. Estas cadenas de documentaci\u00f3n proporcionan una forma de comunicar de manera efectiva c\u00f3mo se debe utilizar y entender una pieza de software. En este art\u00edculo, exploraremos en detalle los docstrings en Python, incluyendo los diferentes estilos de docstrings y su importancia. \u00bfQu\u00e9 Son los Docstrings? Los docstrings son simplemente cadenas de texto que se colocan en la parte superior de un m\u00f3dulo, clase, funci\u00f3n o m\u00e9todo en Python. Estas cadenas de texto se utilizan para documentar el c\u00f3digo y proporcionar informaci\u00f3n sobre lo que hace ese c\u00f3digo, c\u00f3mo debe usarse y qu\u00e9 argumentos se esperan. En Python, los docstrings son tratados como literales de cadena y se asignan autom\u00e1ticamente al atributo __doc__ de un objeto. Esto significa que puedes acceder a la cadena de documentaci\u00f3n de cualquier objeto en Python utilizando la notaci\u00f3n de punto, por ejemplo, objeto.__doc__ . Estilos de Docstrings Existen varios estilos y convenciones para escribir docstrings en Python. Los dos estilos de docstrings m\u00e1s comunes son: 1. Estilo de una L\u00ednea Este estilo es adecuado para documentar m\u00f3dulos, clases, funciones o m\u00e9todos muy simples en una sola l\u00ednea. Generalmente, se coloca entre comillas triples (simples o dobles) y se coloca inmediatamente debajo de la definici\u00f3n del objeto. def suma ( a , b ): \"\"\"Devuelve la suma de dos n\u00fameros.\"\"\" return a + b 2. Estilo de M\u00faltiples L\u00edneas Este estilo se utiliza para proporcionar una documentaci\u00f3n m\u00e1s detallada y estructurada. Sigue las convenciones de las PEP 257. Aqu\u00ed hay un ejemplo: def divide ( dividendo , divisor ): \"\"\" Divide el dividendo entre el divisor y devuelve el resultado. Args: dividendo (int): El n\u00famero que se divide. divisor (int): El n\u00famero por el cual se divide. Returns: float: El resultado de la divisi\u00f3n. Raises: ValueError: Si el divisor es igual a cero. \"\"\" if divisor == 0 : raise ValueError ( \"No se puede dividir por cero.\" ) return dividendo / divisor En el ejemplo anterior: La secci\u00f3n Args describe los argumentos que la funci\u00f3n espera y sus tipos. La secci\u00f3n Returns describe el valor de retorno de la funci\u00f3n y su tipo. La secci\u00f3n Raises enumera las excepciones que puede generar la funci\u00f3n. Formatos principales de docstrings NumPy/SciPy Docstrings Los docstrings de estilo NumPy/SciPy siguen las convenciones utilizadas en las bibliotecas NumPy y SciPy, que son ampliamente utilizadas en la comunidad cient\u00edfica de Python. Estos docstrings est\u00e1n dise\u00f1ados para proporcionar una documentaci\u00f3n clara y concisa para funciones y clases que trabajan con matrices multidimensionales y operaciones matem\u00e1ticas. Ejemplo: def matrix_multiply ( matrix1 , matrix2 ): \"\"\" Multiply two matrices element-wise. Parameters: matrix1 (numpy.ndarray): The first input matrix. matrix2 (numpy.ndarray): The second input matrix. Returns: numpy.ndarray: The result of element-wise multiplication. \"\"\" Google Docstrings Los docstrings de estilo Google siguen las convenciones de documentaci\u00f3n utilizadas por Google para documentar su c\u00f3digo en Python. Este formato se centra en proporcionar una documentaci\u00f3n clara y legible utilizando un estilo de lenguaje natural. Incluye secciones espec\u00edficas para describir par\u00e1metros, valores de retorno y ejemplos. Ejemplo: def calculate_area ( length , width ): \"\"\" Calculate the area of a rectangle. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. \"\"\" reStructuredText reStructuredText (reST) es un formato de marcado utilizado para escribir documentaci\u00f3n estructurada en Python. Se utiliza en combinaci\u00f3n con herramientas como Sphinx para generar documentaci\u00f3n de alta calidad a partir de docstrings y archivos de texto en formato reST. Este formato es particularmente popular en proyectos de c\u00f3digo abierto y bibliotecas bien documentadas. Ejemplo: def calculate_volume ( length , width , height ): \"\"\" Calculate the volume of a rectangular prism. :param float length: The length of the prism. :param float width: The width of the prism. :param float height: The height of the prism. :return: The volume of the prism. :rtype: float \"\"\" Epytext Epytext es un formato de marcado dise\u00f1ado espec\u00edficamente para documentar c\u00f3digo Python. Aunque no es tan ampliamente utilizado como los otros formatos, es una opci\u00f3n v\u00e1lida para documentar funciones y clases en Python. Epytext utiliza etiquetas especiales para describir par\u00e1metros, valores de retorno y otros elementos de la documentaci\u00f3n. Ejemplo: def calculate_perimeter ( side1 , side2 ): \"\"\" Calculate the perimeter of a rectangle. @param side1: The length of one side of the rectangle. @type side1: float @param side2: The length of the adjacent side of the rectangle. @type side2: float @return: The perimeter of the rectangle. @rtype: float \"\"\"","title":"Introducci\u00f3n"},{"location":"documentation/intro/#documentacion-en-python-mejores-practicas-y-herramientas","text":"La documentaci\u00f3n es una parte fundamental del desarrollo de software. Proporciona informaci\u00f3n esencial para los desarrolladores, usuarios y colaboradores sobre c\u00f3mo utilizar y contribuir a un proyecto. En Python, existen buenas pr\u00e1cticas y herramientas que hacen que la creaci\u00f3n y mantenimiento de la documentaci\u00f3n sea m\u00e1s f\u00e1cil y efectiva. En este art\u00edculo, exploraremos la importancia de la documentaci\u00f3n, los diferentes estilos de docstrings y dos de las principales herramientas de documentaci\u00f3n en Python: Sphinx y Markdown.","title":"Documentaci\u00f3n en Python: Mejores Pr\u00e1cticas y Herramientas"},{"location":"documentation/intro/#importancia-de-la-documentacion","text":"La documentaci\u00f3n es una forma de comunicaci\u00f3n clave en el desarrollo de software. Proporciona claridad y contexto sobre el prop\u00f3sito, el funcionamiento y el uso de un proyecto. Algunas de las razones por las que la documentaci\u00f3n es importante incluyen: Facilita el Uso : Permite a los usuarios comprender c\u00f3mo usar una biblioteca o aplicaci\u00f3n sin necesidad de leer el c\u00f3digo fuente. Colaboraci\u00f3n Eficiente : Ayuda a los colaboradores a comprender c\u00f3mo contribuir al proyecto y a mantener un est\u00e1ndar com\u00fan. Resoluci\u00f3n de Problemas : Facilita la soluci\u00f3n de problemas al proporcionar informaci\u00f3n sobre errores comunes y ejemplos de uso. Mantenimiento Sostenible : Permite que un proyecto sea mantenible a lo largo del tiempo, incluso si los desarrolladores originales ya no est\u00e1n disponibles.","title":"Importancia de la Documentaci\u00f3n"},{"location":"documentation/intro/#docstrings","text":"Los docstrings en Python son cadenas de documentaci\u00f3n que se utilizan para describir el prop\u00f3sito y el funcionamiento de m\u00f3dulos, clases, funciones y m\u00e9todos en el c\u00f3digo. Estas cadenas de documentaci\u00f3n proporcionan una forma de comunicar de manera efectiva c\u00f3mo se debe utilizar y entender una pieza de software. En este art\u00edculo, exploraremos en detalle los docstrings en Python, incluyendo los diferentes estilos de docstrings y su importancia.","title":"Docstrings"},{"location":"documentation/intro/#que-son-los-docstrings","text":"Los docstrings son simplemente cadenas de texto que se colocan en la parte superior de un m\u00f3dulo, clase, funci\u00f3n o m\u00e9todo en Python. Estas cadenas de texto se utilizan para documentar el c\u00f3digo y proporcionar informaci\u00f3n sobre lo que hace ese c\u00f3digo, c\u00f3mo debe usarse y qu\u00e9 argumentos se esperan. En Python, los docstrings son tratados como literales de cadena y se asignan autom\u00e1ticamente al atributo __doc__ de un objeto. Esto significa que puedes acceder a la cadena de documentaci\u00f3n de cualquier objeto en Python utilizando la notaci\u00f3n de punto, por ejemplo, objeto.__doc__ .","title":"\u00bfQu\u00e9 Son los Docstrings?"},{"location":"documentation/intro/#estilos-de-docstrings","text":"Existen varios estilos y convenciones para escribir docstrings en Python. Los dos estilos de docstrings m\u00e1s comunes son:","title":"Estilos de Docstrings"},{"location":"documentation/intro/#1-estilo-de-una-linea","text":"Este estilo es adecuado para documentar m\u00f3dulos, clases, funciones o m\u00e9todos muy simples en una sola l\u00ednea. Generalmente, se coloca entre comillas triples (simples o dobles) y se coloca inmediatamente debajo de la definici\u00f3n del objeto. def suma ( a , b ): \"\"\"Devuelve la suma de dos n\u00fameros.\"\"\" return a + b","title":"1. Estilo de una L\u00ednea"},{"location":"documentation/intro/#2-estilo-de-multiples-lineas","text":"Este estilo se utiliza para proporcionar una documentaci\u00f3n m\u00e1s detallada y estructurada. Sigue las convenciones de las PEP 257. Aqu\u00ed hay un ejemplo: def divide ( dividendo , divisor ): \"\"\" Divide el dividendo entre el divisor y devuelve el resultado. Args: dividendo (int): El n\u00famero que se divide. divisor (int): El n\u00famero por el cual se divide. Returns: float: El resultado de la divisi\u00f3n. Raises: ValueError: Si el divisor es igual a cero. \"\"\" if divisor == 0 : raise ValueError ( \"No se puede dividir por cero.\" ) return dividendo / divisor En el ejemplo anterior: La secci\u00f3n Args describe los argumentos que la funci\u00f3n espera y sus tipos. La secci\u00f3n Returns describe el valor de retorno de la funci\u00f3n y su tipo. La secci\u00f3n Raises enumera las excepciones que puede generar la funci\u00f3n.","title":"2. Estilo de M\u00faltiples L\u00edneas"},{"location":"documentation/intro/#formatos-principales-de-docstrings","text":"","title":"Formatos principales de docstrings"},{"location":"documentation/intro/#numpyscipy-docstrings","text":"Los docstrings de estilo NumPy/SciPy siguen las convenciones utilizadas en las bibliotecas NumPy y SciPy, que son ampliamente utilizadas en la comunidad cient\u00edfica de Python. Estos docstrings est\u00e1n dise\u00f1ados para proporcionar una documentaci\u00f3n clara y concisa para funciones y clases que trabajan con matrices multidimensionales y operaciones matem\u00e1ticas. Ejemplo: def matrix_multiply ( matrix1 , matrix2 ): \"\"\" Multiply two matrices element-wise. Parameters: matrix1 (numpy.ndarray): The first input matrix. matrix2 (numpy.ndarray): The second input matrix. Returns: numpy.ndarray: The result of element-wise multiplication. \"\"\"","title":"NumPy/SciPy Docstrings"},{"location":"documentation/intro/#google-docstrings","text":"Los docstrings de estilo Google siguen las convenciones de documentaci\u00f3n utilizadas por Google para documentar su c\u00f3digo en Python. Este formato se centra en proporcionar una documentaci\u00f3n clara y legible utilizando un estilo de lenguaje natural. Incluye secciones espec\u00edficas para describir par\u00e1metros, valores de retorno y ejemplos. Ejemplo: def calculate_area ( length , width ): \"\"\" Calculate the area of a rectangle. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. \"\"\"","title":"Google Docstrings"},{"location":"documentation/intro/#restructuredtext","text":"reStructuredText (reST) es un formato de marcado utilizado para escribir documentaci\u00f3n estructurada en Python. Se utiliza en combinaci\u00f3n con herramientas como Sphinx para generar documentaci\u00f3n de alta calidad a partir de docstrings y archivos de texto en formato reST. Este formato es particularmente popular en proyectos de c\u00f3digo abierto y bibliotecas bien documentadas. Ejemplo: def calculate_volume ( length , width , height ): \"\"\" Calculate the volume of a rectangular prism. :param float length: The length of the prism. :param float width: The width of the prism. :param float height: The height of the prism. :return: The volume of the prism. :rtype: float \"\"\"","title":"reStructuredText"},{"location":"documentation/intro/#epytext","text":"Epytext es un formato de marcado dise\u00f1ado espec\u00edficamente para documentar c\u00f3digo Python. Aunque no es tan ampliamente utilizado como los otros formatos, es una opci\u00f3n v\u00e1lida para documentar funciones y clases en Python. Epytext utiliza etiquetas especiales para describir par\u00e1metros, valores de retorno y otros elementos de la documentaci\u00f3n. Ejemplo: def calculate_perimeter ( side1 , side2 ): \"\"\" Calculate the perimeter of a rectangle. @param side1: The length of one side of the rectangle. @type side1: float @param side2: The length of the adjacent side of the rectangle. @type side2: float @return: The perimeter of the rectangle. @rtype: float \"\"\"","title":"Epytext"},{"location":"documentation/mkdocs-material/","text":"MkDocs-Material La documentaci\u00f3n es una parte esencial de cualquier proyecto de software. Para que sea efectiva, debe ser clara, accesible y visualmente atractiva. MkDocs-Material es una extensi\u00f3n del popular generador de sitios de documentaci\u00f3n MkDocs que permite crear documentaci\u00f3n atractiva con facilidad. En este art\u00edculo, exploraremos MkDocs-Material en detalle, aprenderemos c\u00f3mo instalarlo, configurarlo y crear documentaci\u00f3n visualmente impresionante para tu proyecto. \u00bfQu\u00e9 es MkDocs-Material? MkDocs-Material es una extensi\u00f3n para MkDocs que proporciona un tema de documentaci\u00f3n moderno y atractivo, junto con una serie de caracter\u00edsticas adicionales para mejorar la experiencia de documentaci\u00f3n. Este tema se basa en el dise\u00f1o de Material Design de Google, lo que significa que tu documentaci\u00f3n tendr\u00e1 un aspecto profesional y actualizado. Instalaci\u00f3n de MkDocs-Material Antes de comenzar, aseg\u00farate de que MkDocs est\u00e9 instalado en tu sistema. Si a\u00fan no lo has instalado, puedes hacerlo ejecutando el siguiente comando: pip install mkdocs Luego, para instalar MkDocs-Material, ejecuta el siguiente comando: pip install mkdocs-material Una vez que MkDocs-Material est\u00e9 instalado, puedes verificar su versi\u00f3n con: mkdocs --version Creaci\u00f3n de un Nuevo Proyecto MkDocs Ahora que tienes MkDocs y MkDocs-Material instalados, puedes crear un nuevo proyecto de documentaci\u00f3n. Ve a la carpeta ra\u00edz de tu proyecto y ejecuta el siguiente comando para crear un nuevo proyecto MkDocs: mkdocs new my-docs Esto crear\u00e1 una nueva carpeta llamada my-docs con la estructura b\u00e1sica de un proyecto MkDocs. Configuraci\u00f3n de tu Proyecto MkDocs con MkDocs-Material Abre el archivo mkdocs.yml en tu editor de texto favorito para configurar tu proyecto con el tema MkDocs-Material. Puedes personalizar el t\u00edtulo de tu sitio y agregar enlaces a la barra de navegaci\u00f3n principal. Aqu\u00ed hay un ejemplo de configuraci\u00f3n: site_name : Mi Documentaci\u00f3n con MkDocs-Material theme : name : material language : es nav : - Principal : index.md - Gu\u00eda de Uso : guia.md En el ejemplo anterior, hemos configurado el tema como material y el idioma como es (espa\u00f1ol). Tambi\u00e9n hemos agregado dos p\u00e1ginas a la barra de navegaci\u00f3n principal. Escritura de Documentaci\u00f3n Visualmente Atractiva Comienza a escribir tu documentaci\u00f3n en archivos Markdown dentro de la carpeta docs/ . MkDocs-Material utiliza Markdown enriquecido, lo que significa que puedes usar Markdown est\u00e1ndar junto con caracter\u00edsticas adicionales para crear contenido m\u00e1s atractivo. Por ejemplo, puedes crear una tabla de contenido autom\u00e1ticamente utilizando el siguiente c\u00f3digo: [[TOC]] Adem\u00e1s, MkDocs-Material admite diagramas, resaltado de sintaxis avanzado, tablas interactivas y m\u00e1s. Consulta la documentaci\u00f3n de MkDocs-Material para obtener m\u00e1s detalles sobre c\u00f3mo utilizar estas caracter\u00edsticas. Vista Previa Local Para ver una vista previa de tu sitio de documentaci\u00f3n de MkDocs-Material en tu m\u00e1quina local, ejecuta el siguiente comando en la terminal desde la carpeta ra\u00edz de tu proyecto: mkdocs serve Esto lanzar\u00e1 un servidor de desarrollo local y mostrar\u00e1 la URL donde puedes acceder a tu documentaci\u00f3n, generalmente http://127.0.0.1:8000/ . Generaci\u00f3n y Despliegue de la Documentaci\u00f3n Una vez que hayas escrito toda tu documentaci\u00f3n, puedes generar el sitio web est\u00e1tico con el siguiente comando: mkdocs build Esto crear\u00e1 una carpeta llamada site/ que contiene todos los archivos HTML, CSS y otros recursos necesarios para tu sitio de documentaci\u00f3n. Puedes desplegar tu sitio en una variedad de servicios de alojamiento web, como GitHub Pages, Netlify o cualquier otro servicio que admita sitios web est\u00e1ticos. Sube la carpeta site/ generada a tu servicio de alojamiento preferido y tu documentaci\u00f3n estar\u00e1 en l\u00ednea y lista para ser compartida. Personalizaci\u00f3n Avanzada MkDocs-Material ofrece una serie de opciones de personalizaci\u00f3n avanzada que te permiten ajustar el aspecto y la funcionalidad de tu sitio de documentaci\u00f3n. Puedes modificar la paleta de colores, agregar tu propio logotipo, personalizar el pie de p\u00e1gina y mucho m\u00e1s. Consulta la documentaci\u00f3n de personalizaci\u00f3n de MkDocs-Material para obtener detalles completos. Conclusiones MkDocs-Material es una extensi\u00f3n impresionante que lleva la documentaci\u00f3n de MkDocs al siguiente nivel. Con su tema moderno y caracter\u00edsticas adicionales, puedes crear documentaci\u00f3n visualmente atractiva y funcional en poco tiempo. As\u00ed que, \u00bfpor qu\u00e9 no comenzar a documentar tus proyectos de manera profesional con MkDocs-Material? Referencias Sitio web oficial de MkDocs-Material: https://squidfunk.github.io/mkdocs-material/ Documentaci\u00f3n de MkDocs-Material: https://squidfunk.github.io/mkdocs-material/getting-started/","title":"MkDocs-Material"},{"location":"documentation/mkdocs-material/#mkdocs-material","text":"La documentaci\u00f3n es una parte esencial de cualquier proyecto de software. Para que sea efectiva, debe ser clara, accesible y visualmente atractiva. MkDocs-Material es una extensi\u00f3n del popular generador de sitios de documentaci\u00f3n MkDocs que permite crear documentaci\u00f3n atractiva con facilidad. En este art\u00edculo, exploraremos MkDocs-Material en detalle, aprenderemos c\u00f3mo instalarlo, configurarlo y crear documentaci\u00f3n visualmente impresionante para tu proyecto.","title":"MkDocs-Material"},{"location":"documentation/mkdocs-material/#que-es-mkdocs-material","text":"MkDocs-Material es una extensi\u00f3n para MkDocs que proporciona un tema de documentaci\u00f3n moderno y atractivo, junto con una serie de caracter\u00edsticas adicionales para mejorar la experiencia de documentaci\u00f3n. Este tema se basa en el dise\u00f1o de Material Design de Google, lo que significa que tu documentaci\u00f3n tendr\u00e1 un aspecto profesional y actualizado.","title":"\u00bfQu\u00e9 es MkDocs-Material?"},{"location":"documentation/mkdocs-material/#instalacion-de-mkdocs-material","text":"Antes de comenzar, aseg\u00farate de que MkDocs est\u00e9 instalado en tu sistema. Si a\u00fan no lo has instalado, puedes hacerlo ejecutando el siguiente comando: pip install mkdocs Luego, para instalar MkDocs-Material, ejecuta el siguiente comando: pip install mkdocs-material Una vez que MkDocs-Material est\u00e9 instalado, puedes verificar su versi\u00f3n con: mkdocs --version","title":"Instalaci\u00f3n de MkDocs-Material"},{"location":"documentation/mkdocs-material/#creacion-de-un-nuevo-proyecto-mkdocs","text":"Ahora que tienes MkDocs y MkDocs-Material instalados, puedes crear un nuevo proyecto de documentaci\u00f3n. Ve a la carpeta ra\u00edz de tu proyecto y ejecuta el siguiente comando para crear un nuevo proyecto MkDocs: mkdocs new my-docs Esto crear\u00e1 una nueva carpeta llamada my-docs con la estructura b\u00e1sica de un proyecto MkDocs.","title":"Creaci\u00f3n de un Nuevo Proyecto MkDocs"},{"location":"documentation/mkdocs-material/#configuracion-de-tu-proyecto-mkdocs-con-mkdocs-material","text":"Abre el archivo mkdocs.yml en tu editor de texto favorito para configurar tu proyecto con el tema MkDocs-Material. Puedes personalizar el t\u00edtulo de tu sitio y agregar enlaces a la barra de navegaci\u00f3n principal. Aqu\u00ed hay un ejemplo de configuraci\u00f3n: site_name : Mi Documentaci\u00f3n con MkDocs-Material theme : name : material language : es nav : - Principal : index.md - Gu\u00eda de Uso : guia.md En el ejemplo anterior, hemos configurado el tema como material y el idioma como es (espa\u00f1ol). Tambi\u00e9n hemos agregado dos p\u00e1ginas a la barra de navegaci\u00f3n principal.","title":"Configuraci\u00f3n de tu Proyecto MkDocs con MkDocs-Material"},{"location":"documentation/mkdocs-material/#escritura-de-documentacion-visualmente-atractiva","text":"Comienza a escribir tu documentaci\u00f3n en archivos Markdown dentro de la carpeta docs/ . MkDocs-Material utiliza Markdown enriquecido, lo que significa que puedes usar Markdown est\u00e1ndar junto con caracter\u00edsticas adicionales para crear contenido m\u00e1s atractivo. Por ejemplo, puedes crear una tabla de contenido autom\u00e1ticamente utilizando el siguiente c\u00f3digo: [[TOC]] Adem\u00e1s, MkDocs-Material admite diagramas, resaltado de sintaxis avanzado, tablas interactivas y m\u00e1s. Consulta la documentaci\u00f3n de MkDocs-Material para obtener m\u00e1s detalles sobre c\u00f3mo utilizar estas caracter\u00edsticas.","title":"Escritura de Documentaci\u00f3n Visualmente Atractiva"},{"location":"documentation/mkdocs-material/#vista-previa-local","text":"Para ver una vista previa de tu sitio de documentaci\u00f3n de MkDocs-Material en tu m\u00e1quina local, ejecuta el siguiente comando en la terminal desde la carpeta ra\u00edz de tu proyecto: mkdocs serve Esto lanzar\u00e1 un servidor de desarrollo local y mostrar\u00e1 la URL donde puedes acceder a tu documentaci\u00f3n, generalmente http://127.0.0.1:8000/ .","title":"Vista Previa Local"},{"location":"documentation/mkdocs-material/#generacion-y-despliegue-de-la-documentacion","text":"Una vez que hayas escrito toda tu documentaci\u00f3n, puedes generar el sitio web est\u00e1tico con el siguiente comando: mkdocs build Esto crear\u00e1 una carpeta llamada site/ que contiene todos los archivos HTML, CSS y otros recursos necesarios para tu sitio de documentaci\u00f3n. Puedes desplegar tu sitio en una variedad de servicios de alojamiento web, como GitHub Pages, Netlify o cualquier otro servicio que admita sitios web est\u00e1ticos. Sube la carpeta site/ generada a tu servicio de alojamiento preferido y tu documentaci\u00f3n estar\u00e1 en l\u00ednea y lista para ser compartida.","title":"Generaci\u00f3n y Despliegue de la Documentaci\u00f3n"},{"location":"documentation/mkdocs-material/#personalizacion-avanzada","text":"MkDocs-Material ofrece una serie de opciones de personalizaci\u00f3n avanzada que te permiten ajustar el aspecto y la funcionalidad de tu sitio de documentaci\u00f3n. Puedes modificar la paleta de colores, agregar tu propio logotipo, personalizar el pie de p\u00e1gina y mucho m\u00e1s. Consulta la documentaci\u00f3n de personalizaci\u00f3n de MkDocs-Material para obtener detalles completos.","title":"Personalizaci\u00f3n Avanzada"},{"location":"documentation/mkdocs-material/#conclusiones","text":"MkDocs-Material es una extensi\u00f3n impresionante que lleva la documentaci\u00f3n de MkDocs al siguiente nivel. Con su tema moderno y caracter\u00edsticas adicionales, puedes crear documentaci\u00f3n visualmente atractiva y funcional en poco tiempo. As\u00ed que, \u00bfpor qu\u00e9 no comenzar a documentar tus proyectos de manera profesional con MkDocs-Material?","title":"Conclusiones"},{"location":"documentation/mkdocs-material/#referencias","text":"Sitio web oficial de MkDocs-Material: https://squidfunk.github.io/mkdocs-material/ Documentaci\u00f3n de MkDocs-Material: https://squidfunk.github.io/mkdocs-material/getting-started/","title":"Referencias"},{"location":"documentation/mkdocs-plugging/","text":"Mkdocs-Plugging MkDocs es una excelente herramienta para crear documentaciones limpias y sencillas, pero en ocasiones, necesitas caracter\u00edsticas adicionales para hacer que tu documentaci\u00f3n sea a\u00fan m\u00e1s efectiva. Las extensiones de MkDocs son complementos que te permiten agregar funcionalidades personalizadas a tu sitio de documentaci\u00f3n. En este art\u00edculo, exploraremos tres extensiones populares: mkdocstrings , mkdocs-bibtex , y neoteroi-mkdocs . Veremos c\u00f3mo instalar y utilizar estas extensiones, junto con ejemplos pr\u00e1cticos de su funcionalidad. 1. mkdocstrings mkdocstrings es una extensi\u00f3n de MkDocs que genera documentaci\u00f3n autom\u00e1ticamente a partir de docstrings en el c\u00f3digo fuente de Python. Esto es especialmente \u00fatil para documentar bibliotecas y m\u00f3dulos de Python de una manera coherente y mantenible. Instalaci\u00f3n Para instalar mkdocstrings , ejecuta el siguiente comando: pip install mkdocstrings Configuraci\u00f3n Agregar mkdocstrings a tu configuraci\u00f3n de MkDocs es sencillo. En tu archivo mkdocs.yml , agrega el siguiente complemento: plugins : - mkdocstrings Uso A continuaci\u00f3n, proporcionamos un ejemplo de c\u00f3mo documentar una funci\u00f3n Python y luego generar la documentaci\u00f3n con mkdocstrings : # mymodule.py def add_numbers ( a , b ): \"\"\" Esta funci\u00f3n suma dos n\u00fameros. Args: a (int): El primer n\u00famero. b (int): El segundo n\u00famero. Returns: int: La suma de a y b. \"\"\" return a + b Una vez que hayas agregado docstrings a tu c\u00f3digo, puedes ejecutar el siguiente comando para generar la documentaci\u00f3n: mkdocs serve La documentaci\u00f3n se generar\u00e1 autom\u00e1ticamente y estar\u00e1 disponible en tu sitio MkDocs local. 2. mkdocs-bibtex mkdocs-bibtex es una extensi\u00f3n que te permite incluir citas bibliogr\u00e1ficas y referencias en tu documentaci\u00f3n. Esto es \u00fatil cuando necesitas respaldar tus afirmaciones con fuentes acad\u00e9micas o proporcionar cr\u00e9ditos adecuados. Instalaci\u00f3n Para instalar mkdocs-bibtex , ejecuta el siguiente comando: pip install mkdocs-bibtex Configuraci\u00f3n Agrega mkdocs-bibtex a tu configuraci\u00f3n de MkDocs en mkdocs.yml : plugins : - search - mkdocs-bibtex Uso Para incluir una cita bibliogr\u00e1fica en tu documentaci\u00f3n, puedes usar un marcador especial en tu archivo Markdown: {% bibtex key %} Luego, en tu archivo mkdocs.yml , define la referencia utilizando el siguiente formato: extra : bibtex_bibfiles : - references.bib Aseg\u00farate de tener un archivo references.bib con tus citas bibliogr\u00e1ficas en la misma carpeta que tu proyecto. 3. neoteroi-mkdocs neoteroi-mkdocs es una extensi\u00f3n que agrega una serie de mejoras y caracter\u00edsticas adicionales a MkDocs. Esto incluye soporte para tablas de contenido expandibles, numeraci\u00f3n de secciones, \u00edndices y m\u00e1s. Instalaci\u00f3n Para instalar neoteroi-mkdocs , ejecuta el siguiente comando: pip install mkdocs-neoteroi Configuraci\u00f3n Agrega neoteroi-mkdocs a tu configuraci\u00f3n de MkDocs en mkdocs.yml : plugins : - search - neoteroi Uso neoteroi-mkdocs agrega varias caracter\u00edsticas \u00fatiles a tu documentaci\u00f3n, como tablas de contenido plegables. Aqu\u00ed hay un ejemplo de c\u00f3mo usarlo: ## Secci\u00f3n 1 <details> <summary>Ver contenido</summary> Contenido de la secci\u00f3n 1. </details> ## Secci\u00f3n 2 <details> <summary>Ver contenido</summary> Contenido de la secci\u00f3n 2. </details> Las secciones estar\u00e1n plegadas por defecto y los usuarios podr\u00e1n expandirlas para ver su contenido. Conclusi\u00f3n Las extensiones de MkDocs pueden mejorar significativamente la calidad y funcionalidad de tu documentaci\u00f3n. Ya sea que necesites documentar autom\u00e1ticamente tus m\u00f3dulos de Python, agregar citas bibliogr\u00e1ficas o mejorar la experiencia general de tus lectores, estas extensiones te proporcionan las herramientas necesarias para hacerlo de manera efectiva. \u00a1Explora estas extensiones y eleva tu documentaci\u00f3n al siguiente nivel! Referencias Repositorio de mkdocstrings : https://github.com/pawamoy/mkdocstrings Repositorio de mkdocs-bibtex : https://github.com/hristo-ivanov/mkdocs-bibtex Repositorio de neoteroi-mkdocs : https://github.com/neoteroi/mkdocs Esperamos que esta gu\u00eda te ayude a aprovechar al m\u00e1ximo estas extensiones de MkDocs y a crear documentaci\u00f3n de alta calidad. \u00a1Disfruta documentando tu proyecto!","title":"Mkdocs-Plugging"},{"location":"documentation/mkdocs-plugging/#mkdocs-plugging","text":"MkDocs es una excelente herramienta para crear documentaciones limpias y sencillas, pero en ocasiones, necesitas caracter\u00edsticas adicionales para hacer que tu documentaci\u00f3n sea a\u00fan m\u00e1s efectiva. Las extensiones de MkDocs son complementos que te permiten agregar funcionalidades personalizadas a tu sitio de documentaci\u00f3n. En este art\u00edculo, exploraremos tres extensiones populares: mkdocstrings , mkdocs-bibtex , y neoteroi-mkdocs . Veremos c\u00f3mo instalar y utilizar estas extensiones, junto con ejemplos pr\u00e1cticos de su funcionalidad.","title":"Mkdocs-Plugging"},{"location":"documentation/mkdocs-plugging/#1-mkdocstrings","text":"mkdocstrings es una extensi\u00f3n de MkDocs que genera documentaci\u00f3n autom\u00e1ticamente a partir de docstrings en el c\u00f3digo fuente de Python. Esto es especialmente \u00fatil para documentar bibliotecas y m\u00f3dulos de Python de una manera coherente y mantenible.","title":"1. mkdocstrings"},{"location":"documentation/mkdocs-plugging/#instalacion","text":"Para instalar mkdocstrings , ejecuta el siguiente comando: pip install mkdocstrings","title":"Instalaci\u00f3n"},{"location":"documentation/mkdocs-plugging/#configuracion","text":"Agregar mkdocstrings a tu configuraci\u00f3n de MkDocs es sencillo. En tu archivo mkdocs.yml , agrega el siguiente complemento: plugins : - mkdocstrings","title":"Configuraci\u00f3n"},{"location":"documentation/mkdocs-plugging/#uso","text":"A continuaci\u00f3n, proporcionamos un ejemplo de c\u00f3mo documentar una funci\u00f3n Python y luego generar la documentaci\u00f3n con mkdocstrings : # mymodule.py def add_numbers ( a , b ): \"\"\" Esta funci\u00f3n suma dos n\u00fameros. Args: a (int): El primer n\u00famero. b (int): El segundo n\u00famero. Returns: int: La suma de a y b. \"\"\" return a + b Una vez que hayas agregado docstrings a tu c\u00f3digo, puedes ejecutar el siguiente comando para generar la documentaci\u00f3n: mkdocs serve La documentaci\u00f3n se generar\u00e1 autom\u00e1ticamente y estar\u00e1 disponible en tu sitio MkDocs local.","title":"Uso"},{"location":"documentation/mkdocs-plugging/#2-mkdocs-bibtex","text":"mkdocs-bibtex es una extensi\u00f3n que te permite incluir citas bibliogr\u00e1ficas y referencias en tu documentaci\u00f3n. Esto es \u00fatil cuando necesitas respaldar tus afirmaciones con fuentes acad\u00e9micas o proporcionar cr\u00e9ditos adecuados.","title":"2. mkdocs-bibtex"},{"location":"documentation/mkdocs-plugging/#instalacion_1","text":"Para instalar mkdocs-bibtex , ejecuta el siguiente comando: pip install mkdocs-bibtex","title":"Instalaci\u00f3n"},{"location":"documentation/mkdocs-plugging/#configuracion_1","text":"Agrega mkdocs-bibtex a tu configuraci\u00f3n de MkDocs en mkdocs.yml : plugins : - search - mkdocs-bibtex","title":"Configuraci\u00f3n"},{"location":"documentation/mkdocs-plugging/#uso_1","text":"Para incluir una cita bibliogr\u00e1fica en tu documentaci\u00f3n, puedes usar un marcador especial en tu archivo Markdown: {% bibtex key %} Luego, en tu archivo mkdocs.yml , define la referencia utilizando el siguiente formato: extra : bibtex_bibfiles : - references.bib Aseg\u00farate de tener un archivo references.bib con tus citas bibliogr\u00e1ficas en la misma carpeta que tu proyecto.","title":"Uso"},{"location":"documentation/mkdocs-plugging/#3-neoteroi-mkdocs","text":"neoteroi-mkdocs es una extensi\u00f3n que agrega una serie de mejoras y caracter\u00edsticas adicionales a MkDocs. Esto incluye soporte para tablas de contenido expandibles, numeraci\u00f3n de secciones, \u00edndices y m\u00e1s.","title":"3. neoteroi-mkdocs"},{"location":"documentation/mkdocs-plugging/#instalacion_2","text":"Para instalar neoteroi-mkdocs , ejecuta el siguiente comando: pip install mkdocs-neoteroi","title":"Instalaci\u00f3n"},{"location":"documentation/mkdocs-plugging/#configuracion_2","text":"Agrega neoteroi-mkdocs a tu configuraci\u00f3n de MkDocs en mkdocs.yml : plugins : - search - neoteroi","title":"Configuraci\u00f3n"},{"location":"documentation/mkdocs-plugging/#uso_2","text":"neoteroi-mkdocs agrega varias caracter\u00edsticas \u00fatiles a tu documentaci\u00f3n, como tablas de contenido plegables. Aqu\u00ed hay un ejemplo de c\u00f3mo usarlo: ## Secci\u00f3n 1 <details> <summary>Ver contenido</summary> Contenido de la secci\u00f3n 1. </details> ## Secci\u00f3n 2 <details> <summary>Ver contenido</summary> Contenido de la secci\u00f3n 2. </details> Las secciones estar\u00e1n plegadas por defecto y los usuarios podr\u00e1n expandirlas para ver su contenido.","title":"Uso"},{"location":"documentation/mkdocs-plugging/#conclusion","text":"Las extensiones de MkDocs pueden mejorar significativamente la calidad y funcionalidad de tu documentaci\u00f3n. Ya sea que necesites documentar autom\u00e1ticamente tus m\u00f3dulos de Python, agregar citas bibliogr\u00e1ficas o mejorar la experiencia general de tus lectores, estas extensiones te proporcionan las herramientas necesarias para hacerlo de manera efectiva. \u00a1Explora estas extensiones y eleva tu documentaci\u00f3n al siguiente nivel!","title":"Conclusi\u00f3n"},{"location":"documentation/mkdocs-plugging/#referencias","text":"Repositorio de mkdocstrings : https://github.com/pawamoy/mkdocstrings Repositorio de mkdocs-bibtex : https://github.com/hristo-ivanov/mkdocs-bibtex Repositorio de neoteroi-mkdocs : https://github.com/neoteroi/mkdocs Esperamos que esta gu\u00eda te ayude a aprovechar al m\u00e1ximo estas extensiones de MkDocs y a crear documentaci\u00f3n de alta calidad. \u00a1Disfruta documentando tu proyecto!","title":"Referencias"},{"location":"documentation/mkdocs/","text":"MkDocs La documentaci\u00f3n es una parte esencial de cualquier proyecto de software. Proporciona a los desarrolladores y usuarios una gu\u00eda sobre c\u00f3mo usar y entender el c\u00f3digo. Una de las herramientas m\u00e1s populares para crear documentaci\u00f3n en Python es MkDocs. En este art\u00edculo, exploraremos MkDocs en detalle, aprenderemos c\u00f3mo instalarlo, configurarlo y crear documentaci\u00f3n elegante para tu proyecto. \u00bfQu\u00e9 es MkDocs? MkDocs es una herramienta de c\u00f3digo abierto que permite crear documentaci\u00f3n est\u00e1tica a partir de archivos Markdown. Markdown es un lenguaje de marcado ligero que es f\u00e1cil de aprender y usar. MkDocs toma estos archivos Markdown y los convierte en un sitio web de documentaci\u00f3n listo para ser publicado. Instalaci\u00f3n de MkDocs Para comenzar a usar MkDocs, primero debes instalarlo en tu sistema. La instalaci\u00f3n de MkDocs es sencilla y se realiza a trav\u00e9s de pip, el administrador de paquetes de Python. Abre tu terminal y ejecuta el siguiente comando: pip install mkdocs Una vez que MkDocs est\u00e9 instalado, puedes verificar la versi\u00f3n con: mkdocs --version Creaci\u00f3n de un Nuevo Proyecto MkDocs Ahora que MkDocs est\u00e1 instalado, puedes crear un nuevo proyecto de documentaci\u00f3n. Dir\u00edgete a la carpeta ra\u00edz de tu proyecto y ejecuta el siguiente comando para crear un nuevo proyecto MkDocs: mkdocs new my-docs Esto crear\u00e1 una nueva carpeta llamada my-docs con la estructura b\u00e1sica de un proyecto MkDocs: my-docs/ mkdocs.yml docs/ index.md mkdocs.yml : Este archivo de configuraci\u00f3n contiene la configuraci\u00f3n del proyecto, como el t\u00edtulo del sitio y la lista de p\u00e1ginas de documentaci\u00f3n. docs/ : Esta carpeta es donde colocar\u00e1s tus archivos Markdown que se convertir\u00e1n en p\u00e1ginas de documentaci\u00f3n. Configuraci\u00f3n de tu Proyecto MkDocs Abre el archivo mkdocs.yml en tu editor de texto favorito para configurar tu proyecto. Puedes personalizar el t\u00edtulo de tu sitio y agregar enlaces a la barra de navegaci\u00f3n principal. Por ejemplo: site_name : Mi Documentaci\u00f3n nav : - Principal : index.md - Gu\u00eda de Uso : guia.md Escritura de Documentaci\u00f3n Comienza a escribir tu documentaci\u00f3n en archivos Markdown dentro de la carpeta docs/ . Por ejemplo, crea un archivo guia.md y agrega contenido como este: # Gu\u00eda de Uso En esta gu\u00eda aprender\u00e1s c\u00f3mo utilizar nuestra biblioteca incre\u00edblemente \u00fatil. ## Instalaci\u00f3n Para comenzar, primero debes instalar la biblioteca. Ejecuta el siguiente comando: ```bash pip install biblioteca-increible Uso B\u00e1sico Ahora puedes importar la biblioteca en tu c\u00f3digo Python y empezar a usarla: import biblioteca_increible # Haz cosas asombrosas con la biblioteca \u00a1Y eso es todo! Has completado la instalaci\u00f3n y ahora est\u00e1s listo para utilizar nuestra biblioteca incre\u00edblemente \u00fatil. ## Vista Previa Local Para ver una vista previa de tu sitio de documentaci\u00f3n de MkDocs en tu m\u00e1quina local, ejecuta el siguiente comando en la terminal desde la carpeta ra\u00edz de tu proyecto: ```bash mkdocs serve Esto lanzar\u00e1 un servidor de desarrollo local y mostrar\u00e1 la URL donde puedes acceder a tu documentaci\u00f3n, por lo general, http://127.0.0.1:8000/ . Generaci\u00f3n y Despliegue de la Documentaci\u00f3n Una vez que hayas escrito toda tu documentaci\u00f3n, puedes generar el sitio web est\u00e1tico con el siguiente comando: mkdocs build Esto crear\u00e1 una carpeta llamada site/ que contiene todos los archivos HTML, CSS y otros recursos necesarios para tu sitio de documentaci\u00f3n. Puedes desplegar tu sitio en una variedad de servicios de alojamiento web, como GitHub Pages, Netlify o cualquier otro servicio que admita sitios web est\u00e1ticos. Sube la carpeta site/ generada a tu servicio de alojamiento preferido y tu documentaci\u00f3n estar\u00e1 en l\u00ednea y lista para ser compartida. Temas y Personalizaci\u00f3n MkDocs ofrece varios temas predefin idos para personalizar el aspecto de tu documentaci\u00f3n. Puedes configurar el tema en tu archivo mkdocs.yml . Tambi\u00e9n puedes personalizar a\u00fan m\u00e1s tu sitio mediante la edici\u00f3n de archivos CSS y HTML seg\u00fan tus necesidades. Conclusiones MkDocs es una herramienta poderosa y f\u00e1cil de usar para crear documentaci\u00f3n elegante para tus proyectos. Con su formato simple de Markdown y su capacidad para generar sitios web est\u00e1ticos, puedes crear documentaci\u00f3n de alta calidad en poco tiempo. \u00a1As\u00ed que comienza a documentar tus proyectos y comparte tu conocimiento con el mundo! Referencias Sitio web oficial de MkDocs: https://www.mkdocs.org/ Documentaci\u00f3n de MkDocs: https://www.mkdocs.org/user-guide/","title":"MkDocs"},{"location":"documentation/mkdocs/#mkdocs","text":"La documentaci\u00f3n es una parte esencial de cualquier proyecto de software. Proporciona a los desarrolladores y usuarios una gu\u00eda sobre c\u00f3mo usar y entender el c\u00f3digo. Una de las herramientas m\u00e1s populares para crear documentaci\u00f3n en Python es MkDocs. En este art\u00edculo, exploraremos MkDocs en detalle, aprenderemos c\u00f3mo instalarlo, configurarlo y crear documentaci\u00f3n elegante para tu proyecto.","title":"MkDocs"},{"location":"documentation/mkdocs/#que-es-mkdocs","text":"MkDocs es una herramienta de c\u00f3digo abierto que permite crear documentaci\u00f3n est\u00e1tica a partir de archivos Markdown. Markdown es un lenguaje de marcado ligero que es f\u00e1cil de aprender y usar. MkDocs toma estos archivos Markdown y los convierte en un sitio web de documentaci\u00f3n listo para ser publicado.","title":"\u00bfQu\u00e9 es MkDocs?"},{"location":"documentation/mkdocs/#instalacion-de-mkdocs","text":"Para comenzar a usar MkDocs, primero debes instalarlo en tu sistema. La instalaci\u00f3n de MkDocs es sencilla y se realiza a trav\u00e9s de pip, el administrador de paquetes de Python. Abre tu terminal y ejecuta el siguiente comando: pip install mkdocs Una vez que MkDocs est\u00e9 instalado, puedes verificar la versi\u00f3n con: mkdocs --version","title":"Instalaci\u00f3n de MkDocs"},{"location":"documentation/mkdocs/#creacion-de-un-nuevo-proyecto-mkdocs","text":"Ahora que MkDocs est\u00e1 instalado, puedes crear un nuevo proyecto de documentaci\u00f3n. Dir\u00edgete a la carpeta ra\u00edz de tu proyecto y ejecuta el siguiente comando para crear un nuevo proyecto MkDocs: mkdocs new my-docs Esto crear\u00e1 una nueva carpeta llamada my-docs con la estructura b\u00e1sica de un proyecto MkDocs: my-docs/ mkdocs.yml docs/ index.md mkdocs.yml : Este archivo de configuraci\u00f3n contiene la configuraci\u00f3n del proyecto, como el t\u00edtulo del sitio y la lista de p\u00e1ginas de documentaci\u00f3n. docs/ : Esta carpeta es donde colocar\u00e1s tus archivos Markdown que se convertir\u00e1n en p\u00e1ginas de documentaci\u00f3n.","title":"Creaci\u00f3n de un Nuevo Proyecto MkDocs"},{"location":"documentation/mkdocs/#configuracion-de-tu-proyecto-mkdocs","text":"Abre el archivo mkdocs.yml en tu editor de texto favorito para configurar tu proyecto. Puedes personalizar el t\u00edtulo de tu sitio y agregar enlaces a la barra de navegaci\u00f3n principal. Por ejemplo: site_name : Mi Documentaci\u00f3n nav : - Principal : index.md - Gu\u00eda de Uso : guia.md","title":"Configuraci\u00f3n de tu Proyecto MkDocs"},{"location":"documentation/mkdocs/#escritura-de-documentacion","text":"Comienza a escribir tu documentaci\u00f3n en archivos Markdown dentro de la carpeta docs/ . Por ejemplo, crea un archivo guia.md y agrega contenido como este: # Gu\u00eda de Uso En esta gu\u00eda aprender\u00e1s c\u00f3mo utilizar nuestra biblioteca incre\u00edblemente \u00fatil. ## Instalaci\u00f3n Para comenzar, primero debes instalar la biblioteca. Ejecuta el siguiente comando: ```bash pip install biblioteca-increible","title":"Escritura de Documentaci\u00f3n"},{"location":"documentation/mkdocs/#uso-basico","text":"Ahora puedes importar la biblioteca en tu c\u00f3digo Python y empezar a usarla: import biblioteca_increible # Haz cosas asombrosas con la biblioteca \u00a1Y eso es todo! Has completado la instalaci\u00f3n y ahora est\u00e1s listo para utilizar nuestra biblioteca incre\u00edblemente \u00fatil. ## Vista Previa Local Para ver una vista previa de tu sitio de documentaci\u00f3n de MkDocs en tu m\u00e1quina local, ejecuta el siguiente comando en la terminal desde la carpeta ra\u00edz de tu proyecto: ```bash mkdocs serve Esto lanzar\u00e1 un servidor de desarrollo local y mostrar\u00e1 la URL donde puedes acceder a tu documentaci\u00f3n, por lo general, http://127.0.0.1:8000/ .","title":"Uso B\u00e1sico"},{"location":"documentation/mkdocs/#generacion-y-despliegue-de-la-documentacion","text":"Una vez que hayas escrito toda tu documentaci\u00f3n, puedes generar el sitio web est\u00e1tico con el siguiente comando: mkdocs build Esto crear\u00e1 una carpeta llamada site/ que contiene todos los archivos HTML, CSS y otros recursos necesarios para tu sitio de documentaci\u00f3n. Puedes desplegar tu sitio en una variedad de servicios de alojamiento web, como GitHub Pages, Netlify o cualquier otro servicio que admita sitios web est\u00e1ticos. Sube la carpeta site/ generada a tu servicio de alojamiento preferido y tu documentaci\u00f3n estar\u00e1 en l\u00ednea y lista para ser compartida.","title":"Generaci\u00f3n y Despliegue de la Documentaci\u00f3n"},{"location":"documentation/mkdocs/#temas-y-personalizacion","text":"MkDocs ofrece varios temas predefin idos para personalizar el aspecto de tu documentaci\u00f3n. Puedes configurar el tema en tu archivo mkdocs.yml . Tambi\u00e9n puedes personalizar a\u00fan m\u00e1s tu sitio mediante la edici\u00f3n de archivos CSS y HTML seg\u00fan tus necesidades.","title":"Temas y Personalizaci\u00f3n"},{"location":"documentation/mkdocs/#conclusiones","text":"MkDocs es una herramienta poderosa y f\u00e1cil de usar para crear documentaci\u00f3n elegante para tus proyectos. Con su formato simple de Markdown y su capacidad para generar sitios web est\u00e1ticos, puedes crear documentaci\u00f3n de alta calidad en poco tiempo. \u00a1As\u00ed que comienza a documentar tus proyectos y comparte tu conocimiento con el mundo!","title":"Conclusiones"},{"location":"documentation/mkdocs/#referencias","text":"Sitio web oficial de MkDocs: https://www.mkdocs.org/ Documentaci\u00f3n de MkDocs: https://www.mkdocs.org/user-guide/","title":"Referencias"},{"location":"ecosystem/pydantic/","text":"Pydantic 1. Introducci\u00f3n a Pydantic \u00bfQu\u00e9 es Pydantic? Pydantic es una biblioteca Python que proporciona una forma sencilla y declarativa de definir modelos de datos y realizar validaci\u00f3n de datos. Su objetivo principal es facilitar la validaci\u00f3n de datos y la serializaci\u00f3n de objetos en aplicaciones Python. Pydantic se basa en la anotaci\u00f3n de tipos introducida en Python 3.5 y utiliza estas anotaciones de tipos para definir la estructura de datos esperada. Luego, realiza autom\u00e1ticamente la validaci\u00f3n de datos y la conversi\u00f3n de tipos seg\u00fan las reglas especificadas. Instalaci\u00f3n de Pydantic Puede instalar Pydantic f\u00e1cilmente utilizando pip: pip install pydantic Una vez que lo haya instalado, est\u00e1 listo para comenzar a usarlo en sus proyectos. 2. Definici\u00f3n de Modelos Creaci\u00f3n de Modelos En Pydantic, los modelos se crean mediante clases que heredan de pydantic.BaseModel . Dentro de estas clases, se definen los campos que compondr\u00e1n el modelo utilizando las anotaciones de tipos . Veamos un ejemplo simple de un modelo de persona: from pydantic import BaseModel class Person ( BaseModel ): name : str age : int En este ejemplo, hemos definido un modelo Person con dos campos: name de tipo str y age de tipo int . Anotaciones de Tipos Pydantic utiliza anotaciones de tipos para definir la estructura de datos esperada en sus modelos. Las anotaciones de tipos son claras y legibles, lo que facilita la comprensi\u00f3n de la estructura de datos de un vistazo. Puedes utilizar una variedad de tipos de Python incorporados (como str , int , float , bool ) o incluso tipos personalizados. Valores Predeterminados Puede proporcionar valores predeterminados para los campos de su modelo utilizando el operador de asignaci\u00f3n ( = ). Estos valores se utilizar\u00e1n si no se proporciona un valor para el campo durante la creaci\u00f3n del objeto: class Person ( BaseModel ): name : str = \"John Doe\" age : int = 30 En este ejemplo, si no se proporciona un nombre o una edad al crear un objeto Person , se utilizar\u00e1n los valores predeterminados. 3. Validaci\u00f3n de Datos Validaci\u00f3n Autom\u00e1tica Una de las caracter\u00edsticas m\u00e1s poderosas de Pydantic es su capacidad para realizar validaci\u00f3n de datos de forma autom\u00e1tica. Cuando crea una instancia de un modelo, Pydantic verifica si los datos proporcionados cumplen con las reglas definidas en el modelo. Veamos un ejemplo: data = { \"name\" : \"Alice\" , \"age\" : 25 } person = Person ( ** data ) # Crear una instancia de Person con los datos Pydantic verifica que data contenga los campos name y age , y que name sea de tipo str y age sea de tipo int . Si los datos no cumplen con estas reglas, Pydantic genera una excepci\u00f3n ValidationError . Excepciones de Validaci\u00f3n Cuando se produce una excepci\u00f3n de validaci\u00f3n, Pydantic proporciona informaci\u00f3n detallada sobre los errores, incluyendo el campo afectado y un mensaje de error. Puede capturar y manejar estas excepciones seg\u00fan sea necesario en su aplicaci\u00f3n. from pydantic import ValidationError try : person = Person ( name = \"Alice\" , age = \"25\" ) # 'age' debe ser int, pero se proporciona str except ValidationError as e : print ( e ) 4. Serializaci\u00f3n y Deserializaci\u00f3n Pydantic facilita la serializaci\u00f3n de objetos a formatos como JSON y la deserializaci\u00f3n desde estos formatos. Serializaci\u00f3n a JSON Puede convertir f\u00e1cilmente un objeto Pydantic a formato JSON utilizando el m\u00e9todo json() : person = Person ( name = \"Alice\" , age = 25 ) json_data = person . json () print ( json_data ) El resultado ser\u00e1: { \"name\" : \"Alice\" , \"age\" : 25 } Deserializaci\u00f3n desde JSON Para deserializar datos JSON en un objeto Pydantic, simplemente cree una instancia del modelo y pase los datos JSON como argumentos: json_data = '{\"name\": \"Bob\", \"age\": 30}' person = Person . parse_raw ( json_data ) Pydantic se encargar\u00e1 de validar y convertir los datos JSON en un objeto Pydantic. 5. Modelos Anidados y Herencia Modelos Anidados Pydantic permite la creaci\u00f3n de modelos anidados para representar estructuras de datos m\u00e1s complejas. Puede definir modelos dentro de otros modelos y utilizarlos para representar objetos anidados. from typing import List class Address ( BaseModel ): street : str city : str class Person ( BaseModel ): name : str age : int addresses : List [ Address ] En este ejemplo, el modelo Person tiene una lista de direcciones, donde cada direcci\u00f3n es un objeto Address . Esto permite representar datos anidados de manera clara y estructurada. Herencia de Modelos Pydantic admite la herencia de modelos, lo que facilita la creaci\u00f3n de modelos especializados basados en modelos existentes. Puede heredar campos y comportamientos de un modelo base y personalizarlos seg\u00fan sus necesidades. class Employee ( Person ): employee_id : int En este ejemplo, Employee hereda los campos name y age del modelo Person y agrega un campo adicional employee_id . Esto permite reutilizar c\u00f3digo y definir modelos de manera eficiente. 6. Configuraci\u00f3n de Modelos Configuraciones de Modelo Pydantic permite configurar modelos utilizando la clase Config . Puede personalizar varios aspectos del comportamiento de un modelo, como el control de alias, la validaci\u00f3n de campos adicionales y m\u00e1s. from pydantic import BaseModel , Field class Person ( BaseModel ): name : str = Field ( ... , alias = \"fullName\" ) class Config : allow_population_by_field_name = True validate_all = True En este ejemplo, hemos configurado el modelo Person para que permita la asignaci\u00f3n de valores utilizando el nombre del campo ( allow_population_by_field_name ) y para que realice validaci\u00f3n en todos los campos, incluso aquellos sin anotaciones de tipo ( validate_all ). Ignorar Campos Desconocidos Puede configurar un modelo para que ignore campos desconocidos utilizando Config : from pydantic import BaseModel class Person ( BaseModel ): name : str class Config : ignore_extra = True Esto significa que al crear una instancia de Person , cualquier campo no definido en el modelo ser\u00e1 ignorado en lugar de generar un error de validaci\u00f3n. 7. Uso en Aplicaciones Web Integraci\u00f3n con Frameworks Web Pydantic se integra perfectamente con marcos web populares como FastAPI y Flask. Aqu\u00ed, veremos c\u00f3mo usar Pydantic con FastAPI para validar solicitudes HTTP y respuestas. Ejemplo de Validaci\u00f3n de Solicitud HTTP en FastAPI Supongamos que estamos construyendo una API RESTful en FastAPI y deseamos validar una solicitud POST que contiene datos de usuario en formato JSON. Utilizaremos un modelo Pydantic para definir la estructura esperada de la solicitud y realizar la validaci\u00f3n: from fastapi import FastAPI , HTTPException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str email : str @app . post ( \"/create_user/\" ) async def create_user ( user : User ): # 'user' ya est\u00e1 validado por Pydantic # Procesamos la solicitud y creamos el usuario en la base de datos return { \"message\" : \"Usuario creado exitosamente\" } En este ejemplo, definimos un modelo Pydantic llamado User , que especifica la estructura de datos esperada en la solicitud. FastAPI se encarga autom\u00e1ticamente de validar la solicitud y, si los datos no cumplen con el modelo, devuelve una respuesta de error. Ejemplo de Validaci\u00f3n de Respuesta HTTP en FastAPI Tambi\u00e9n podemos utilizar Pydantic para validar las respuestas de nuestras rutas en FastAPI. Supongamos que queremos validar la respuesta de un usuario: from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str email : str @app . get ( \"/user/ {user_id} \" , response_model = User ) async def read_user ( user_id : int ): # Recuperar datos del usuario de la base de datos user_data = { \"username\" : \"alice\" , \"email\" : \"alice@example.com\" } return user_data En este ejemplo, hemos especificado response_model=User en la ruta, lo que indica que la respuesta debe cumplir con el modelo User . Si la respuesta no coincide con el modelo, FastAPI generar\u00e1 una respuesta de error autom\u00e1ticamente. 8. Personalizaci\u00f3n Avanzada Validadores Personalizados Pydantic permite crear validadores personalizados para aplicar l\u00f3gica de validaci\u00f3n adicional a los campos de un modelo. Esto es \u00fatil cuando necesita reglas de validaci\u00f3n espec\u00edficas para sus datos. Ejemplo de Validador Personalizado Supongamos que estamos creando un modelo para representar fechas de nacimiento y queremos asegurarnos de que las fechas sean v\u00e1lidas y no futuras. Podemos crear un validador personalizado para lograr esto: from pydantic import BaseModel , validator from datetime import date class Person ( BaseModel ): birthdate : date @validator ( \"birthdate\" ) def validate_birthdate ( cls , value ): if value >= date . today (): raise ValueError ( \"La fecha de nacimiento no puede ser en el futuro\" ) return value En este ejemplo, hemos definido un validador personalizado llamado validate_birthdate que verifica si la fecha de nacimiento es v\u00e1lida. Si la fecha es futura, se genera un error. Conversiones Personalizadas Pydantic permite definir m\u00e9todos de clase personalizados para realizar conversiones personalizadas al analizar datos de entrada. Ejemplo de Conversi\u00f3n Personalizada Supongamos que queremos representar un campo score en nuestro modelo como un valor flotante, pero las solicitudes pueden enviarlo como una cadena. Podemos realizar una conversi\u00f3n personalizada para manejar esto: from pydantic import BaseModel class Player ( BaseModel ): name : str score : float @classmethod def parse_obj ( cls , obj ): if isinstance ( obj . get ( \"score\" ), str ): obj [ \"score\" ] = float ( obj [ \"score\" ]) return super () . parse_obj ( obj ) En este ejemplo, hemos definido el m\u00e9todo parse_obj para convertir el campo score de una cadena a un flotante antes de crear una instancia del modelo Player . 9. Manejo de Errores y Excepciones Pydantic proporciona excepciones espec\u00edficas para ayudar en el manejo de errores de validaci\u00f3n. Esto permite que su c\u00f3digo sea m\u00e1s robusto y proporciona informaci\u00f3n detallada sobre los problemas de validaci\u00f3n. Manejo de Excepciones de Validaci\u00f3n Supongamos que estamos creando una aplicaci\u00f3n que procesa datos de encuestas y deseamos manejar excepciones de validaci\u00f3n de manera adecuada: from pydantic import BaseModel , ValidationError class SurveyResult ( BaseModel ): question : str answer : int data = { \"question\" : \"\u00bfCu\u00e1l es tu edad?\" , \"answer\" : \"veinticinco\" # Esto deber\u00eda ser un n\u00famero entero } try : result = SurveyResult ( ** data ) except ValidationError as e : print ( f \"Error de validaci\u00f3n: { e } \" ) En este ejemplo, cuando answer es una cadena en lugar de un entero, se genera una excepci\u00f3n ValidationError . Esto le permite manejar el error de manera adecuada en su aplicaci\u00f3n. 10. Documentaci\u00f3n Autom\u00e1tica Puede generar documentaci\u00f3n autom\u00e1ticamente para sus modelos Pydantic utilizando herramientas como Sphinx y sphinx-pydantic . Esto facilita la creaci\u00f3n de documentaci\u00f3n precisa y legible para sus API y aplicaciones. 11. Casos de Uso del Mundo Real Ejemplos Pr\u00e1cticos Validaci\u00f3n en Aplicaciones Web Pydantic es especialmente \u00fatil en aplicaciones web, donde se deben validar las solicitudes entrantes y las respuestas salientes. Procesamiento de Datos Puede utilizar Pydantic para validar y convertir datos en scripts de procesamiento de datos, lo que garantiza la integridad de los datos en todo momento. Configuraci\u00f3n de Aplicaciones Pydantic se puede usar para cargar y validar archivos de configuraci\u00f3n, lo que facilita la configuraci\u00f3n de aplicaciones de manera segura y estructurada. Aplicaciones Comunes APIs RESTful Pydantic es una elecci\u00f3n s\u00f3lida para validar datos en solicitudes y respuestas de APIs RESTful, lo que mejora la calidad y la seguridad de sus servicios web. Scripts de Procesamiento Al utilizar Pydantic en scripts de procesamiento de datos, puede garantizar que los datos se ajusten a las especificaciones deseadas antes de ser procesados. Configuraci\u00f3n de Aplicaciones La validaci\u00f3n de archivos de configuraci\u00f3n con Pydantic ayuda a evitar errores de configuraci\u00f3n y simplifica la gesti\u00f3n de la configuraci\u00f3n de la aplicaci\u00f3n. 12. Rendimiento y Consideraciones Es fundamental tener en cuenta el rendimiento al utilizar Pydantic en aplicaciones que requieren una alta velocidad de procesamiento. Si bien Pydantic es r\u00e1pido, la validaci\u00f3n de datos y la conversi\u00f3n de tipos tienen un costo computacional. Es importante evaluar el impacto en el rendimiento en aplicaciones cr\u00edticas. 13. Conclusiones Pydantic es una biblioteca Python poderosa y vers\u00e1til que simplifica la validaci\u00f3n y el modelado de datos. Desde la integraci\u00f3n con marcos web hasta la creaci\u00f3n de validadores y conversiones personalizadas, Pydantic ofrece una amplia gama de caracter\u00edsticas para mejorar la calidad y la robustez de su c\u00f3digo. Al aplicar Pydantic en sus proyectos, puede garantizar la integridad de sus datos y simplificar la validaci\u00f3n, lo que conduce a aplicaciones m\u00e1s s\u00f3lidas y seguras. Esta gu\u00eda profunda ha explorado en detalle c\u00f3mo utilizar Pydantic en escenarios del mundo real. Sin embargo, recuerde que Pydantic es una herramienta vers\u00e1til con a\u00fan m\u00e1s caracter\u00edsticas por descubrir. Consulte la documentaci\u00f3n oficial de Pydantic para obtener informaci\u00f3n adicional y ejemplos detallados, y no dude en explorar y aplicar Pydantic en sus propios proyectos para aprovechar al m\u00e1ximo esta valiosa biblioteca de validaci\u00f3n de datos en Python. \u00a1La calidad y la confiabilidad de su c\u00f3digo mejorar\u00e1n significativamente con su uso!","title":"Pydantic"},{"location":"ecosystem/pydantic/#pydantic","text":"","title":"Pydantic"},{"location":"ecosystem/pydantic/#1-introduccion-a-pydantic","text":"","title":"1. Introducci\u00f3n a Pydantic"},{"location":"ecosystem/pydantic/#que-es-pydantic","text":"Pydantic es una biblioteca Python que proporciona una forma sencilla y declarativa de definir modelos de datos y realizar validaci\u00f3n de datos. Su objetivo principal es facilitar la validaci\u00f3n de datos y la serializaci\u00f3n de objetos en aplicaciones Python. Pydantic se basa en la anotaci\u00f3n de tipos introducida en Python 3.5 y utiliza estas anotaciones de tipos para definir la estructura de datos esperada. Luego, realiza autom\u00e1ticamente la validaci\u00f3n de datos y la conversi\u00f3n de tipos seg\u00fan las reglas especificadas.","title":"\u00bfQu\u00e9 es Pydantic?"},{"location":"ecosystem/pydantic/#instalacion-de-pydantic","text":"Puede instalar Pydantic f\u00e1cilmente utilizando pip: pip install pydantic Una vez que lo haya instalado, est\u00e1 listo para comenzar a usarlo en sus proyectos.","title":"Instalaci\u00f3n de Pydantic"},{"location":"ecosystem/pydantic/#2-definicion-de-modelos","text":"","title":"2. Definici\u00f3n de Modelos"},{"location":"ecosystem/pydantic/#creacion-de-modelos","text":"En Pydantic, los modelos se crean mediante clases que heredan de pydantic.BaseModel . Dentro de estas clases, se definen los campos que compondr\u00e1n el modelo utilizando las anotaciones de tipos . Veamos un ejemplo simple de un modelo de persona: from pydantic import BaseModel class Person ( BaseModel ): name : str age : int En este ejemplo, hemos definido un modelo Person con dos campos: name de tipo str y age de tipo int .","title":"Creaci\u00f3n de Modelos"},{"location":"ecosystem/pydantic/#anotaciones-de-tipos","text":"Pydantic utiliza anotaciones de tipos para definir la estructura de datos esperada en sus modelos. Las anotaciones de tipos son claras y legibles, lo que facilita la comprensi\u00f3n de la estructura de datos de un vistazo. Puedes utilizar una variedad de tipos de Python incorporados (como str , int , float , bool ) o incluso tipos personalizados.","title":"Anotaciones de Tipos"},{"location":"ecosystem/pydantic/#valores-predeterminados","text":"Puede proporcionar valores predeterminados para los campos de su modelo utilizando el operador de asignaci\u00f3n ( = ). Estos valores se utilizar\u00e1n si no se proporciona un valor para el campo durante la creaci\u00f3n del objeto: class Person ( BaseModel ): name : str = \"John Doe\" age : int = 30 En este ejemplo, si no se proporciona un nombre o una edad al crear un objeto Person , se utilizar\u00e1n los valores predeterminados.","title":"Valores Predeterminados"},{"location":"ecosystem/pydantic/#3-validacion-de-datos","text":"","title":"3. Validaci\u00f3n de Datos"},{"location":"ecosystem/pydantic/#validacion-automatica","text":"Una de las caracter\u00edsticas m\u00e1s poderosas de Pydantic es su capacidad para realizar validaci\u00f3n de datos de forma autom\u00e1tica. Cuando crea una instancia de un modelo, Pydantic verifica si los datos proporcionados cumplen con las reglas definidas en el modelo. Veamos un ejemplo: data = { \"name\" : \"Alice\" , \"age\" : 25 } person = Person ( ** data ) # Crear una instancia de Person con los datos Pydantic verifica que data contenga los campos name y age , y que name sea de tipo str y age sea de tipo int . Si los datos no cumplen con estas reglas, Pydantic genera una excepci\u00f3n ValidationError .","title":"Validaci\u00f3n Autom\u00e1tica"},{"location":"ecosystem/pydantic/#excepciones-de-validacion","text":"Cuando se produce una excepci\u00f3n de validaci\u00f3n, Pydantic proporciona informaci\u00f3n detallada sobre los errores, incluyendo el campo afectado y un mensaje de error. Puede capturar y manejar estas excepciones seg\u00fan sea necesario en su aplicaci\u00f3n. from pydantic import ValidationError try : person = Person ( name = \"Alice\" , age = \"25\" ) # 'age' debe ser int, pero se proporciona str except ValidationError as e : print ( e )","title":"Excepciones de Validaci\u00f3n"},{"location":"ecosystem/pydantic/#4-serializacion-y-deserializacion","text":"Pydantic facilita la serializaci\u00f3n de objetos a formatos como JSON y la deserializaci\u00f3n desde estos formatos.","title":"4. Serializaci\u00f3n y Deserializaci\u00f3n"},{"location":"ecosystem/pydantic/#serializacion-a-json","text":"Puede convertir f\u00e1cilmente un objeto Pydantic a formato JSON utilizando el m\u00e9todo json() : person = Person ( name = \"Alice\" , age = 25 ) json_data = person . json () print ( json_data ) El resultado ser\u00e1: { \"name\" : \"Alice\" , \"age\" : 25 }","title":"Serializaci\u00f3n a JSON"},{"location":"ecosystem/pydantic/#deserializacion-desde-json","text":"Para deserializar datos JSON en un objeto Pydantic, simplemente cree una instancia del modelo y pase los datos JSON como argumentos: json_data = '{\"name\": \"Bob\", \"age\": 30}' person = Person . parse_raw ( json_data ) Pydantic se encargar\u00e1 de validar y convertir los datos JSON en un objeto Pydantic.","title":"Deserializaci\u00f3n desde JSON"},{"location":"ecosystem/pydantic/#5-modelos-anidados-y-herencia","text":"","title":"5. Modelos Anidados y Herencia"},{"location":"ecosystem/pydantic/#modelos-anidados","text":"Pydantic permite la creaci\u00f3n de modelos anidados para representar estructuras de datos m\u00e1s complejas. Puede definir modelos dentro de otros modelos y utilizarlos para representar objetos anidados. from typing import List class Address ( BaseModel ): street : str city : str class Person ( BaseModel ): name : str age : int addresses : List [ Address ] En este ejemplo, el modelo Person tiene una lista de direcciones, donde cada direcci\u00f3n es un objeto Address . Esto permite representar datos anidados de manera clara y estructurada.","title":"Modelos Anidados"},{"location":"ecosystem/pydantic/#herencia-de-modelos","text":"Pydantic admite la herencia de modelos, lo que facilita la creaci\u00f3n de modelos especializados basados en modelos existentes. Puede heredar campos y comportamientos de un modelo base y personalizarlos seg\u00fan sus necesidades. class Employee ( Person ): employee_id : int En este ejemplo, Employee hereda los campos name y age del modelo Person y agrega un campo adicional employee_id . Esto permite reutilizar c\u00f3digo y definir modelos de manera eficiente.","title":"Herencia de Modelos"},{"location":"ecosystem/pydantic/#6-configuracion-de-modelos","text":"","title":"6. Configuraci\u00f3n de Modelos"},{"location":"ecosystem/pydantic/#configuraciones-de-modelo","text":"Pydantic permite configurar modelos utilizando la clase Config . Puede personalizar varios aspectos del comportamiento de un modelo, como el control de alias, la validaci\u00f3n de campos adicionales y m\u00e1s. from pydantic import BaseModel , Field class Person ( BaseModel ): name : str = Field ( ... , alias = \"fullName\" ) class Config : allow_population_by_field_name = True validate_all = True En este ejemplo, hemos configurado el modelo Person para que permita la asignaci\u00f3n de valores utilizando el nombre del campo ( allow_population_by_field_name ) y para que realice validaci\u00f3n en todos los campos, incluso aquellos sin anotaciones de tipo ( validate_all ).","title":"Configuraciones de Modelo"},{"location":"ecosystem/pydantic/#ignorar-campos-desconocidos","text":"Puede configurar un modelo para que ignore campos desconocidos utilizando Config : from pydantic import BaseModel class Person ( BaseModel ): name : str class Config : ignore_extra = True Esto significa que al crear una instancia de Person , cualquier campo no definido en el modelo ser\u00e1 ignorado en lugar de generar un error de validaci\u00f3n.","title":"Ignorar Campos Desconocidos"},{"location":"ecosystem/pydantic/#7-uso-en-aplicaciones-web","text":"","title":"7. Uso en Aplicaciones Web"},{"location":"ecosystem/pydantic/#integracion-con-frameworks-web","text":"Pydantic se integra perfectamente con marcos web populares como FastAPI y Flask. Aqu\u00ed, veremos c\u00f3mo usar Pydantic con FastAPI para validar solicitudes HTTP y respuestas.","title":"Integraci\u00f3n con Frameworks Web"},{"location":"ecosystem/pydantic/#ejemplo-de-validacion-de-solicitud-http-en-fastapi","text":"Supongamos que estamos construyendo una API RESTful en FastAPI y deseamos validar una solicitud POST que contiene datos de usuario en formato JSON. Utilizaremos un modelo Pydantic para definir la estructura esperada de la solicitud y realizar la validaci\u00f3n: from fastapi import FastAPI , HTTPException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str email : str @app . post ( \"/create_user/\" ) async def create_user ( user : User ): # 'user' ya est\u00e1 validado por Pydantic # Procesamos la solicitud y creamos el usuario en la base de datos return { \"message\" : \"Usuario creado exitosamente\" } En este ejemplo, definimos un modelo Pydantic llamado User , que especifica la estructura de datos esperada en la solicitud. FastAPI se encarga autom\u00e1ticamente de validar la solicitud y, si los datos no cumplen con el modelo, devuelve una respuesta de error.","title":"Ejemplo de Validaci\u00f3n de Solicitud HTTP en FastAPI"},{"location":"ecosystem/pydantic/#ejemplo-de-validacion-de-respuesta-http-en-fastapi","text":"Tambi\u00e9n podemos utilizar Pydantic para validar las respuestas de nuestras rutas en FastAPI. Supongamos que queremos validar la respuesta de un usuario: from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str email : str @app . get ( \"/user/ {user_id} \" , response_model = User ) async def read_user ( user_id : int ): # Recuperar datos del usuario de la base de datos user_data = { \"username\" : \"alice\" , \"email\" : \"alice@example.com\" } return user_data En este ejemplo, hemos especificado response_model=User en la ruta, lo que indica que la respuesta debe cumplir con el modelo User . Si la respuesta no coincide con el modelo, FastAPI generar\u00e1 una respuesta de error autom\u00e1ticamente.","title":"Ejemplo de Validaci\u00f3n de Respuesta HTTP en FastAPI"},{"location":"ecosystem/pydantic/#8-personalizacion-avanzada","text":"","title":"8. Personalizaci\u00f3n Avanzada"},{"location":"ecosystem/pydantic/#validadores-personalizados","text":"Pydantic permite crear validadores personalizados para aplicar l\u00f3gica de validaci\u00f3n adicional a los campos de un modelo. Esto es \u00fatil cuando necesita reglas de validaci\u00f3n espec\u00edficas para sus datos.","title":"Validadores Personalizados"},{"location":"ecosystem/pydantic/#ejemplo-de-validador-personalizado","text":"Supongamos que estamos creando un modelo para representar fechas de nacimiento y queremos asegurarnos de que las fechas sean v\u00e1lidas y no futuras. Podemos crear un validador personalizado para lograr esto: from pydantic import BaseModel , validator from datetime import date class Person ( BaseModel ): birthdate : date @validator ( \"birthdate\" ) def validate_birthdate ( cls , value ): if value >= date . today (): raise ValueError ( \"La fecha de nacimiento no puede ser en el futuro\" ) return value En este ejemplo, hemos definido un validador personalizado llamado validate_birthdate que verifica si la fecha de nacimiento es v\u00e1lida. Si la fecha es futura, se genera un error.","title":"Ejemplo de Validador Personalizado"},{"location":"ecosystem/pydantic/#conversiones-personalizadas","text":"Pydantic permite definir m\u00e9todos de clase personalizados para realizar conversiones personalizadas al analizar datos de entrada.","title":"Conversiones Personalizadas"},{"location":"ecosystem/pydantic/#ejemplo-de-conversion-personalizada","text":"Supongamos que queremos representar un campo score en nuestro modelo como un valor flotante, pero las solicitudes pueden enviarlo como una cadena. Podemos realizar una conversi\u00f3n personalizada para manejar esto: from pydantic import BaseModel class Player ( BaseModel ): name : str score : float @classmethod def parse_obj ( cls , obj ): if isinstance ( obj . get ( \"score\" ), str ): obj [ \"score\" ] = float ( obj [ \"score\" ]) return super () . parse_obj ( obj ) En este ejemplo, hemos definido el m\u00e9todo parse_obj para convertir el campo score de una cadena a un flotante antes de crear una instancia del modelo Player .","title":"Ejemplo de Conversi\u00f3n Personalizada"},{"location":"ecosystem/pydantic/#9-manejo-de-errores-y-excepciones","text":"Pydantic proporciona excepciones espec\u00edficas para ayudar en el manejo de errores de validaci\u00f3n. Esto permite que su c\u00f3digo sea m\u00e1s robusto y proporciona informaci\u00f3n detallada sobre los problemas de validaci\u00f3n.","title":"9. Manejo de Errores y Excepciones"},{"location":"ecosystem/pydantic/#manejo-de-excepciones-de-validacion","text":"Supongamos que estamos creando una aplicaci\u00f3n que procesa datos de encuestas y deseamos manejar excepciones de validaci\u00f3n de manera adecuada: from pydantic import BaseModel , ValidationError class SurveyResult ( BaseModel ): question : str answer : int data = { \"question\" : \"\u00bfCu\u00e1l es tu edad?\" , \"answer\" : \"veinticinco\" # Esto deber\u00eda ser un n\u00famero entero } try : result = SurveyResult ( ** data ) except ValidationError as e : print ( f \"Error de validaci\u00f3n: { e } \" ) En este ejemplo, cuando answer es una cadena en lugar de un entero, se genera una excepci\u00f3n ValidationError . Esto le permite manejar el error de manera adecuada en su aplicaci\u00f3n.","title":"Manejo de Excepciones de Validaci\u00f3n"},{"location":"ecosystem/pydantic/#10-documentacion-automatica","text":"Puede generar documentaci\u00f3n autom\u00e1ticamente para sus modelos Pydantic utilizando herramientas como Sphinx y sphinx-pydantic . Esto facilita la creaci\u00f3n de documentaci\u00f3n precisa y legible para sus API y aplicaciones.","title":"10. Documentaci\u00f3n Autom\u00e1tica"},{"location":"ecosystem/pydantic/#11-casos-de-uso-del-mundo-real","text":"","title":"11. Casos de Uso del Mundo Real"},{"location":"ecosystem/pydantic/#ejemplos-practicos","text":"","title":"Ejemplos Pr\u00e1cticos"},{"location":"ecosystem/pydantic/#validacion-en-aplicaciones-web","text":"Pydantic es especialmente \u00fatil en aplicaciones web, donde se deben validar las solicitudes entrantes y las respuestas salientes.","title":"Validaci\u00f3n en Aplicaciones Web"},{"location":"ecosystem/pydantic/#procesamiento-de-datos","text":"Puede utilizar Pydantic para validar y convertir datos en scripts de procesamiento de datos, lo que garantiza la integridad de los datos en todo momento.","title":"Procesamiento de Datos"},{"location":"ecosystem/pydantic/#configuracion-de-aplicaciones","text":"Pydantic se puede usar para cargar y validar archivos de configuraci\u00f3n, lo que facilita la configuraci\u00f3n de aplicaciones de manera segura y estructurada.","title":"Configuraci\u00f3n de Aplicaciones"},{"location":"ecosystem/pydantic/#aplicaciones-comunes","text":"","title":"Aplicaciones Comunes"},{"location":"ecosystem/pydantic/#apis-restful","text":"Pydantic es una elecci\u00f3n s\u00f3lida para validar datos en solicitudes y respuestas de APIs RESTful, lo que mejora la calidad y la seguridad de sus servicios web.","title":"APIs RESTful"},{"location":"ecosystem/pydantic/#scripts-de-procesamiento","text":"Al utilizar Pydantic en scripts de procesamiento de datos, puede garantizar que los datos se ajusten a las especificaciones deseadas antes de ser procesados.","title":"Scripts de Procesamiento"},{"location":"ecosystem/pydantic/#configuracion","text":"de Aplicaciones La validaci\u00f3n de archivos de configuraci\u00f3n con Pydantic ayuda a evitar errores de configuraci\u00f3n y simplifica la gesti\u00f3n de la configuraci\u00f3n de la aplicaci\u00f3n.","title":"Configuraci\u00f3n"},{"location":"ecosystem/pydantic/#12-rendimiento-y-consideraciones","text":"Es fundamental tener en cuenta el rendimiento al utilizar Pydantic en aplicaciones que requieren una alta velocidad de procesamiento. Si bien Pydantic es r\u00e1pido, la validaci\u00f3n de datos y la conversi\u00f3n de tipos tienen un costo computacional. Es importante evaluar el impacto en el rendimiento en aplicaciones cr\u00edticas.","title":"12. Rendimiento y Consideraciones"},{"location":"ecosystem/pydantic/#13-conclusiones","text":"Pydantic es una biblioteca Python poderosa y vers\u00e1til que simplifica la validaci\u00f3n y el modelado de datos. Desde la integraci\u00f3n con marcos web hasta la creaci\u00f3n de validadores y conversiones personalizadas, Pydantic ofrece una amplia gama de caracter\u00edsticas para mejorar la calidad y la robustez de su c\u00f3digo. Al aplicar Pydantic en sus proyectos, puede garantizar la integridad de sus datos y simplificar la validaci\u00f3n, lo que conduce a aplicaciones m\u00e1s s\u00f3lidas y seguras. Esta gu\u00eda profunda ha explorado en detalle c\u00f3mo utilizar Pydantic en escenarios del mundo real. Sin embargo, recuerde que Pydantic es una herramienta vers\u00e1til con a\u00fan m\u00e1s caracter\u00edsticas por descubrir. Consulte la documentaci\u00f3n oficial de Pydantic para obtener informaci\u00f3n adicional y ejemplos detallados, y no dude en explorar y aplicar Pydantic en sus propios proyectos para aprovechar al m\u00e1ximo esta valiosa biblioteca de validaci\u00f3n de datos en Python. \u00a1La calidad y la confiabilidad de su c\u00f3digo mejorar\u00e1n significativamente con su uso!","title":"13. Conclusiones"},{"location":"ecosystem/typing/","text":"Typing Python es conocido por su simplicidad y flexibilidad, pero a medida que los proyectos crecen en complejidad, puede ser beneficioso agregar una capa de tipado est\u00e1tico para mejorar la legibilidad del c\u00f3digo y reducir errores. La biblioteca typing es una parte esencial de la caja de herramientas de Python para el tipado est\u00e1tico. En este art\u00edculo, exploraremos a fondo la biblioteca typing , sus caracter\u00edsticas, ejemplos y c\u00f3mo se relaciona con los Protocolos PEP (Python Enhancement Proposals). Introducci\u00f3n a typing La biblioteca typing se introdujo en Python 3.5 y se utiliza para agregar anotaciones de tipos est\u00e1ticos a las variables, argumentos de funci\u00f3n y valores de retorno en el c\u00f3digo Python. Aunque Python es un lenguaje de tipado din\u00e1mico, estas anotaciones proporcionan informaci\u00f3n adicional sobre los tipos de datos esperados, lo que puede hacer que el c\u00f3digo sea m\u00e1s claro y permitir a las herramientas de an\u00e1lisis de c\u00f3digo encontrar errores m\u00e1s f\u00e1cilmente. Anotaciones de Tipos Simples Empecemos por lo b\u00e1sico: c\u00f3mo usar typing para anotar tipos de variables simples. Enteros, Flotantes y Cadenas from typing import List , Dict # Anotaci\u00f3n de tipos simples x : int = 5 y : float = 3.14 name : str = \"Python\" En el c\u00f3digo anterior, hemos anotado tres variables con tipos simples: int , float y str . Listas y Diccionarios typing tambi\u00e9n permite anotar estructuras de datos m\u00e1s complejas como listas y diccionarios. # Anotaci\u00f3n de tipos para listas y diccionarios numbers : List [ int ] = [ 1 , 2 , 3 ] student_grades : Dict [ str , float ] = { 'Alice' : 95.5 , 'Bob' : 89.0 , 'Charlie' : 78.5 } Aqu\u00ed, hemos anotado numbers como una lista de enteros y student_grades como un diccionario que asigna nombres de estudiantes a calificaciones en punto flotante. Tipado de Funciones Adem\u00e1s de anotar variables, typing nos permite especificar los tipos de argumentos y valores de retorno en las funciones. Funciones sin Tipo de Retorno def greet ( name : str ) -> None : print ( f \"Hello, { name } !\" ) greet ( \"Alice\" ) En este ejemplo, hemos definido una funci\u00f3n greet que toma un argumento name de tipo str y no devuelve nada ( None ). Funciones con Valores de Retorno def add ( a : int , b : int ) -> int : return a + b result : int = add ( 3 , 4 ) La funci\u00f3n add toma dos argumentos enteros y devuelve un entero. Hemos anotado tanto los argumentos como el valor de retorno. Tipado de Estructuras de Datos typing tambi\u00e9n es \u00fatil para definir estructuras de datos personalizadas, como tuplas y clases. Tuplas from typing import Tuple point : Tuple [ int , int ] = ( 3 , 4 ) En este ejemplo, hemos anotado la variable point como una tupla de dos enteros. Clases y Atributos class Person : def __init__ ( self , name : str , age : int ): self . name = name self . age = age def greet ( self ) -> str : return f \"Hello, I'm { self . name } and I'm { self . age } years old.\" person : Person = Person ( \"Alice\" , 30 ) Hemos definido una clase Person con anotaciones de tipos para el constructor __init__ y el m\u00e9todo greet . Luego, hemos creado una instancia de Person llamada person . Tipado de Contenedores Gen\u00e9ricos Python permite crear estructuras de datos gen\u00e9ricas utilizando la notaci\u00f3n de tipo typing , lo que facilita la creaci\u00f3n de contenedores altamente flexibles. Listas Gen\u00e9ricas from typing import List , TypeVar # Definir un tipo gen\u00e9rico T = TypeVar ( 'T' ) def first_element ( items : List [ T ]) -> T : return items [ 0 ] numbers : List [ int ] = [ 1 , 2 , 3 ] result : int = first_element ( numbers ) En este ejemplo, hemos definido una funci\u00f3n first_element que toma una lista gen\u00e9rica de elementos de tipo T y devuelve un elemento de tipo T . Luego, hemos utilizado esta funci\u00f3n con una lista de enteros. Diccionarios Gen\u00e9ricos from typing import Dict , TypeVar K = TypeVar ( 'K' ) V = TypeVar ( 'V' ) def get_value ( d : Dict [ K , V ], key : K ) -> V : return d [ key ] grades : Dict [ str , float ] = { 'Alice' : 95.5 , 'Bob' : 89.0 , 'Charlie' : 78.5 } result : float = get_value ( grades , 'Alice' ) Aqu\u00ed, hemos definido una funci\u00f3n get_value que toma un diccionario gen\u00e9rico con claves de tipo K y valores de tipo V . La funci\u00f3n devuelve un valor de tipo V dado una clave de tipo K . Anotaciones de Tipo para Variables Nulas typing tambi\u00e9n admite anotaciones de tipo para variables que pueden ser nulas (None). from typing import Optional def divide ( a : float , b : float ) -> Optional [ float ]: if b == 0 : return None return a / b result : Optional [ float ] = divide ( 10 , 2 ) En este ejemplo, hemos anotado la funci\u00f3n divide para que devuelva un valor opcional ( Optional[float] ). Esto indica que la funci\u00f3n puede devolver un n\u00famero en punto flotante o None si la divisi\u00f3n no es v\u00e1lida. Protocolos PEP (PEP 544) Los Protocolos PEP son una parte importante de typing . Estos protocolos proporcionan una forma de definir las caracter\u00edsticas esperadas de un tipo de manera m\u00e1s abstracta. El PEP 544 introduce la idea de Protocolos de Tipo, que se utilizan para describir interfaces en lugar de clases concretas. Definici\u00f3n de un Protocolo Veamos c\u00f3mo definir un protocolo usando typing.Protocol : from typing import Protocol class Printable ( Protocol ): def __str__ ( self ) -> str : ... En este ejemplo, hemos definido un protocolo llamado Printable que describe un objeto que puede convertirse en una cadena. Implementaci\u00f3n de un Protocolo Luego, podemos hacer que una clase implemente este protocolo: class Book : def __init__ ( self , title : str , author : str ) -> None : self . title = title self . author = author def __str__ ( self ) -> str : return f \" { self . title } by { self . author } \" book : Printable = Book ( \"The Python Guide\" , \"Python Enthusiast\" ) Hemos definido una clase Book que implementa el protocolo Printable proporcionando una implementaci\u00f3n del m\u00e9todo __str__ . Ahora podemos anotar una variable book como un objeto Printable . Usando el Protocolo def print_info ( item : Printable ) -> None : print ( str ( item )) print_info ( book ) La funci\u00f3n print_info toma un argumento item de tipo Printable y lo imprime. Hemos pasado nuestra instancia de Book , que cumple con el protocolo Printable , a esta funci\u00f3n. Conclusiones La biblioteca typing de Python es una herramienta poderosa para agregar anotaciones de tipo est\u00e1tico a su c\u00f3digo, lo que lo hace m\u00e1s claro y ayuda a detectar errores m\u00e1s temprano en el ciclo de desarrollo. Con typing , puede anotar variables, argumentos de funci\u00f3n, valores de retorno y estructuras de datos complejas. Adem\u00e1s, los Protocolos PEP le permiten definir interfaces abstractas y crear c\u00f3digo m\u00e1s flexible. Al aprovechar al m\u00e1ximo typing , puede mejorar la calidad y la mantenibilidad de su c\u00f3digo Python. A medida que explore m\u00e1s a fondo estas caracter\u00edsticas y las incorpore en su desarrollo, estar\u00e1 mejor equipado para abordar proyectos m\u00e1s grandes y complejos. Es importante recordar que las anotaciones de tipo son opcionales en Python, pero pueden ser muy beneficiosas en t\u00e9rminos de claridad y detecci\u00f3n temprana de errores. La elecci\u00f3n de utilizar typing en su proyecto depende de sus necesidades y preferencias personales. A medida que contin\u00faa su viaje en Python, siga explorando y experimentando con typing y los Protocolos PEP para aprovechar al m\u00e1ximo esta poderosa herramienta de tipado est\u00e1tico.","title":"Typing"},{"location":"ecosystem/typing/#typing","text":"Python es conocido por su simplicidad y flexibilidad, pero a medida que los proyectos crecen en complejidad, puede ser beneficioso agregar una capa de tipado est\u00e1tico para mejorar la legibilidad del c\u00f3digo y reducir errores. La biblioteca typing es una parte esencial de la caja de herramientas de Python para el tipado est\u00e1tico. En este art\u00edculo, exploraremos a fondo la biblioteca typing , sus caracter\u00edsticas, ejemplos y c\u00f3mo se relaciona con los Protocolos PEP (Python Enhancement Proposals).","title":"Typing"},{"location":"ecosystem/typing/#introduccion-a-typing","text":"La biblioteca typing se introdujo en Python 3.5 y se utiliza para agregar anotaciones de tipos est\u00e1ticos a las variables, argumentos de funci\u00f3n y valores de retorno en el c\u00f3digo Python. Aunque Python es un lenguaje de tipado din\u00e1mico, estas anotaciones proporcionan informaci\u00f3n adicional sobre los tipos de datos esperados, lo que puede hacer que el c\u00f3digo sea m\u00e1s claro y permitir a las herramientas de an\u00e1lisis de c\u00f3digo encontrar errores m\u00e1s f\u00e1cilmente.","title":"Introducci\u00f3n a typing"},{"location":"ecosystem/typing/#anotaciones-de-tipos-simples","text":"Empecemos por lo b\u00e1sico: c\u00f3mo usar typing para anotar tipos de variables simples.","title":"Anotaciones de Tipos Simples"},{"location":"ecosystem/typing/#enteros-flotantes-y-cadenas","text":"from typing import List , Dict # Anotaci\u00f3n de tipos simples x : int = 5 y : float = 3.14 name : str = \"Python\" En el c\u00f3digo anterior, hemos anotado tres variables con tipos simples: int , float y str .","title":"Enteros, Flotantes y Cadenas"},{"location":"ecosystem/typing/#listas-y-diccionarios","text":"typing tambi\u00e9n permite anotar estructuras de datos m\u00e1s complejas como listas y diccionarios. # Anotaci\u00f3n de tipos para listas y diccionarios numbers : List [ int ] = [ 1 , 2 , 3 ] student_grades : Dict [ str , float ] = { 'Alice' : 95.5 , 'Bob' : 89.0 , 'Charlie' : 78.5 } Aqu\u00ed, hemos anotado numbers como una lista de enteros y student_grades como un diccionario que asigna nombres de estudiantes a calificaciones en punto flotante.","title":"Listas y Diccionarios"},{"location":"ecosystem/typing/#tipado-de-funciones","text":"Adem\u00e1s de anotar variables, typing nos permite especificar los tipos de argumentos y valores de retorno en las funciones.","title":"Tipado de Funciones"},{"location":"ecosystem/typing/#funciones-sin-tipo-de-retorno","text":"def greet ( name : str ) -> None : print ( f \"Hello, { name } !\" ) greet ( \"Alice\" ) En este ejemplo, hemos definido una funci\u00f3n greet que toma un argumento name de tipo str y no devuelve nada ( None ).","title":"Funciones sin Tipo de Retorno"},{"location":"ecosystem/typing/#funciones-con-valores-de-retorno","text":"def add ( a : int , b : int ) -> int : return a + b result : int = add ( 3 , 4 ) La funci\u00f3n add toma dos argumentos enteros y devuelve un entero. Hemos anotado tanto los argumentos como el valor de retorno.","title":"Funciones con Valores de Retorno"},{"location":"ecosystem/typing/#tipado-de-estructuras-de-datos","text":"typing tambi\u00e9n es \u00fatil para definir estructuras de datos personalizadas, como tuplas y clases.","title":"Tipado de Estructuras de Datos"},{"location":"ecosystem/typing/#tuplas","text":"from typing import Tuple point : Tuple [ int , int ] = ( 3 , 4 ) En este ejemplo, hemos anotado la variable point como una tupla de dos enteros.","title":"Tuplas"},{"location":"ecosystem/typing/#clases-y-atributos","text":"class Person : def __init__ ( self , name : str , age : int ): self . name = name self . age = age def greet ( self ) -> str : return f \"Hello, I'm { self . name } and I'm { self . age } years old.\" person : Person = Person ( \"Alice\" , 30 ) Hemos definido una clase Person con anotaciones de tipos para el constructor __init__ y el m\u00e9todo greet . Luego, hemos creado una instancia de Person llamada person .","title":"Clases y Atributos"},{"location":"ecosystem/typing/#tipado-de-contenedores-genericos","text":"Python permite crear estructuras de datos gen\u00e9ricas utilizando la notaci\u00f3n de tipo typing , lo que facilita la creaci\u00f3n de contenedores altamente flexibles.","title":"Tipado de Contenedores Gen\u00e9ricos"},{"location":"ecosystem/typing/#listas-genericas","text":"from typing import List , TypeVar # Definir un tipo gen\u00e9rico T = TypeVar ( 'T' ) def first_element ( items : List [ T ]) -> T : return items [ 0 ] numbers : List [ int ] = [ 1 , 2 , 3 ] result : int = first_element ( numbers ) En este ejemplo, hemos definido una funci\u00f3n first_element que toma una lista gen\u00e9rica de elementos de tipo T y devuelve un elemento de tipo T . Luego, hemos utilizado esta funci\u00f3n con una lista de enteros.","title":"Listas Gen\u00e9ricas"},{"location":"ecosystem/typing/#diccionarios-genericos","text":"from typing import Dict , TypeVar K = TypeVar ( 'K' ) V = TypeVar ( 'V' ) def get_value ( d : Dict [ K , V ], key : K ) -> V : return d [ key ] grades : Dict [ str , float ] = { 'Alice' : 95.5 , 'Bob' : 89.0 , 'Charlie' : 78.5 } result : float = get_value ( grades , 'Alice' ) Aqu\u00ed, hemos definido una funci\u00f3n get_value que toma un diccionario gen\u00e9rico con claves de tipo K y valores de tipo V . La funci\u00f3n devuelve un valor de tipo V dado una clave de tipo K .","title":"Diccionarios Gen\u00e9ricos"},{"location":"ecosystem/typing/#anotaciones-de-tipo-para-variables-nulas","text":"typing tambi\u00e9n admite anotaciones de tipo para variables que pueden ser nulas (None). from typing import Optional def divide ( a : float , b : float ) -> Optional [ float ]: if b == 0 : return None return a / b result : Optional [ float ] = divide ( 10 , 2 ) En este ejemplo, hemos anotado la funci\u00f3n divide para que devuelva un valor opcional ( Optional[float] ). Esto indica que la funci\u00f3n puede devolver un n\u00famero en punto flotante o None si la divisi\u00f3n no es v\u00e1lida.","title":"Anotaciones de Tipo para Variables Nulas"},{"location":"ecosystem/typing/#protocolos-pep-pep-544","text":"Los Protocolos PEP son una parte importante de typing . Estos protocolos proporcionan una forma de definir las caracter\u00edsticas esperadas de un tipo de manera m\u00e1s abstracta. El PEP 544 introduce la idea de Protocolos de Tipo, que se utilizan para describir interfaces en lugar de clases concretas.","title":"Protocolos PEP (PEP 544)"},{"location":"ecosystem/typing/#definicion-de-un-protocolo","text":"Veamos c\u00f3mo definir un protocolo usando typing.Protocol : from typing import Protocol class Printable ( Protocol ): def __str__ ( self ) -> str : ... En este ejemplo, hemos definido un protocolo llamado Printable que describe un objeto que puede convertirse en una cadena.","title":"Definici\u00f3n de un Protocolo"},{"location":"ecosystem/typing/#implementacion-de-un-protocolo","text":"Luego, podemos hacer que una clase implemente este protocolo: class Book : def __init__ ( self , title : str , author : str ) -> None : self . title = title self . author = author def __str__ ( self ) -> str : return f \" { self . title } by { self . author } \" book : Printable = Book ( \"The Python Guide\" , \"Python Enthusiast\" ) Hemos definido una clase Book que implementa el protocolo Printable proporcionando una implementaci\u00f3n del m\u00e9todo __str__ . Ahora podemos anotar una variable book como un objeto Printable .","title":"Implementaci\u00f3n de un Protocolo"},{"location":"ecosystem/typing/#usando-el-protocolo","text":"def print_info ( item : Printable ) -> None : print ( str ( item )) print_info ( book ) La funci\u00f3n print_info toma un argumento item de tipo Printable y lo imprime. Hemos pasado nuestra instancia de Book , que cumple con el protocolo Printable , a esta funci\u00f3n.","title":"Usando el Protocolo"},{"location":"ecosystem/typing/#conclusiones","text":"La biblioteca typing de Python es una herramienta poderosa para agregar anotaciones de tipo est\u00e1tico a su c\u00f3digo, lo que lo hace m\u00e1s claro y ayuda a detectar errores m\u00e1s temprano en el ciclo de desarrollo. Con typing , puede anotar variables, argumentos de funci\u00f3n, valores de retorno y estructuras de datos complejas. Adem\u00e1s, los Protocolos PEP le permiten definir interfaces abstractas y crear c\u00f3digo m\u00e1s flexible. Al aprovechar al m\u00e1ximo typing , puede mejorar la calidad y la mantenibilidad de su c\u00f3digo Python. A medida que explore m\u00e1s a fondo estas caracter\u00edsticas y las incorpore en su desarrollo, estar\u00e1 mejor equipado para abordar proyectos m\u00e1s grandes y complejos. Es importante recordar que las anotaciones de tipo son opcionales en Python, pero pueden ser muy beneficiosas en t\u00e9rminos de claridad y detecci\u00f3n temprana de errores. La elecci\u00f3n de utilizar typing en su proyecto depende de sus necesidades y preferencias personales. A medida que contin\u00faa su viaje en Python, siga explorando y experimentando con typing y los Protocolos PEP para aprovechar al m\u00e1ximo esta poderosa herramienta de tipado est\u00e1tico.","title":"Conclusiones"},{"location":"git/git/","text":"Git Git es un sistema de control de versiones ampliamente utilizado que permite rastrear cambios en archivos y colaborar en proyectos de desarrollo de software. En esta gu\u00eda completa de Git, exploraremos sus or\u00edgenes, comandos b\u00e1sicos y avanzados, y proporcionaremos ejemplos detallados para ayudarte a comprender este poderoso sistema de control de versiones. 1. Or\u00edgenes de Git Git fue creado por Linus Torvalds en 2005, el mismo creador del kernel de Linux. La necesidad de un sistema de control de versiones distribuido y eficiente para administrar el desarrollo del kernel de Linux condujo a la creaci\u00f3n de Git. Algunos de los principios clave que impulsaron su desarrollo incluyen: Distribuci\u00f3n : Git es un sistema de control de versiones distribuido, lo que significa que cada usuario tiene una copia completa del historial del repositorio en su m\u00e1quina local. Velocidad : Git se dise\u00f1\u00f3 para ser r\u00e1pido y eficiente, lo que lo hace adecuado para proyectos de cualquier tama\u00f1o. Integridad de los datos : Los datos almacenados en Git se verifican mediante sumas de comprobaci\u00f3n criptogr\u00e1ficas, lo que garantiza que los archivos y las revisiones no se da\u00f1en ni se modifiquen sin autorizaci\u00f3n. Soporte para ramificaci\u00f3n y fusi\u00f3n : Git facilita la creaci\u00f3n de ramas para experimentar y el proceso de fusi\u00f3n de ramas cuando se completan las caracter\u00edsticas o las correcciones de errores. Flexibilidad : Git es altamente flexible y admite una variedad de flujos de trabajo de desarrollo. 2. Configuraci\u00f3n de Git Antes de comenzar a usar Git, es importante configurar su identidad. Esto asegura que las confirmaciones que realice tengan la informaci\u00f3n correcta del autor. Puede configurar su nombre de usuario y direcci\u00f3n de correo electr\u00f3nico utilizando los siguientes comandos: git config --global user.name \"Tu Nombre\" git config --global user.email \"tu@email.com\" 3. Comandos B\u00e1sicos de Git Iniciar un Repositorio Para comenzar a usar Git en un proyecto existente, o para crear un nuevo repositorio desde cero, puede usar el siguiente comando: git init Clonar un Repositorio Para clonar un repositorio existente desde un servidor remoto (como GitHub), use el comando git clone . Esto crear\u00e1 una copia local del repositorio en su m\u00e1quina: git clone URL_del_repositorio Realizar Confirmaciones Despu\u00e9s de realizar cambios en sus archivos, puede confirmarlos en Git con el siguiente flujo de comandos: git add archivo_modificado git commit -m \"Mensaje de confirmaci\u00f3n descriptivo\" Ver el Estado del Repositorio Para verificar el estado actual de su repositorio y ver qu\u00e9 archivos est\u00e1n en la etapa de preparaci\u00f3n y cu\u00e1les no, use: git status Ver el Historial de Confirmaciones Puede ver el historial de confirmaciones de su repositorio con el siguiente comando: git log 4. Ramificaci\u00f3n y Fusi\u00f3n Crear una Rama Las ramas en Git permiten trabajar en caracter\u00edsticas o correcciones de errores de forma aislada. Para crear una nueva rama, use: git branch nombre_de_la_rama Cambiar de Rama Puede cambiar entre ramas utilizando: git checkout nombre_de_la_rama Fusionar Ramas Para fusionar los cambios de una rama en otra, use: git checkout rama_destino git merge rama_fuente 5. Comandos Avanzados de Git Rebase La rebase es una operaci\u00f3n que permite reorganizar el historial de confirmaciones para que parezca que las confirmaciones de una rama se hicieron despu\u00e9s de las de otra. Esto es \u00fatil para mantener un historial limpio y ordenado. Para realizar un rebase, use: git rebase rama_fuente Stash El comando git stash le permite guardar temporalmente cambios sin confirmar en una pila y trabajar en otra rama. Esto es \u00fatil cuando necesita cambiar de rama pero no desea confirmar los cambios en curso. Los cambios guardados se pueden aplicar m\u00e1s tarde. Para guardar cambios en una pila, use: git stash Cherry-Pick El cherry-pick le permite aplicar una confirmaci\u00f3n espec\u00edfica desde una rama a otra. Esto es \u00fatil cuando solo necesita aplicar ciertos cambios de una rama en lugar de fusionar toda la rama. Para realizar un cherry-pick, use: git cherry-pick hash_de_la_confirmaci\u00f3n Subm\u00f3dulos Los subm\u00f3dulos permiten incluir otros repositorios de Git dentro de su propio repositorio. Esto es \u00fatil cuando necesita incluir bibliotecas o dependencias externas en su proyecto. Para agregar un subm\u00f3dulo, use: git submodule add URL_del_repositorio Reflog Reflog es una herramienta \u00fatil para recuperar confirmaciones \"perdidas\" o para volver a estados anteriores del repositorio. Le permite ver el historial de referencia de Git. Para ver el reflog, use: git reflog 6. Ramificaci\u00f3n Remota Agregar un Repositorio Remoto Puede agregar un repositorio remoto a su repositorio local con el siguiente comando: git remote add nombre_remoto URL_del_repositorio_remoto Enviar Cambios a un Repositorio Remoto Para enviar sus cambios locales a un repositorio remoto, use: git push nombre_remoto nombre_rama Obtener Cambios de un Repositorio Remoto Para obtener los cambios realizados en un repositorio remoto, use: git pull nombre_remoto nombre_rama 7. Git en la Pr\u00e1ctica Ejemplo: Creaci\u00f3n de un Repositorio y Confirmaci\u00f3n de Cambios Comencemos con un ejemplo pr\u00e1ctico. Supongamos que desea iniciar un nuevo proyecto y rastrear los cambios utilizando Git. Aqu\u00ed hay una serie de pasos que puede seguir: Paso 1: Inicializar un Repositorio Primero, cree un directorio para su proyecto y navegue a \u00e9l en la terminal. Luego, ejecute el siguiente comando para iniciar un repositorio Git en ese directorio: mkdir mi_proyecto cd mi_proyecto git init Paso 2: Agregar y Confirmar Cambios Cree un archivo en su proyecto (por ejemplo, main.py ) y agregue algo de c\u00f3digo. Luego, use los siguientes comandos para agregar y confirmar sus cambios: echo \"print('Hola, mundo')\" > main.py git add main.py git commit -m \"Agregado archivo main.py con un saludo\" Paso 3: Ver el Historial Puede ver el historial de confirmaciones utilizando el comando git log : git log Ejemplo: Trabajo con Ramas Supongamos que desea trabajar en una nueva caracter\u00edstica para su proyecto en una rama separada. A continuaci\u00f3n, se muestra c\u00f3mo puede hacerlo: Paso 1: Crear una Rama git branch nueva_caracteristica Paso 2: Cambiar de Rama git checkout nueva_caracteristica Paso 3: Realizar Cambios y Confirmar Haga los cambios necesarios en su proyecto y conf\u00edrmelos en la nueva rama: echo \"print('Nueva caracter\u00edstica agregada')\" >> main.py git add main.py git commit -m \"Agregada nueva caracter\u00edstica\" Paso 4: Fusionar la Rama Una vez que haya completado su nueva caracter\u00edstica, puede fusionarla con la rama principal de la siguiente manera: git checkout master git merge nueva_caracteristica 8. Conclusiones Git es una herramienta esencial para cualquier desarrollador de software. Permite el control de versiones, la colaboraci\u00f3n en proyectos y el seguimiento de cambios de manera eficiente. Conocer los comandos b\u00e1sicos y avanzados de Git es fundamental para trabajar de manera efectiva en proyectos de desarrollo. Esta gu\u00eda completa ha cubierto una variedad de conceptos y comandos de Git, desde la configuraci\u00f3n inicial hasta operaciones m\u00e1s avanzadas como rebase, stash y cherry-pick. Al aplicar estos conocimientos en su flujo de trabajo diario, se convertir\u00e1 en un desarrollador m\u00e1s eficiente y colaborativo. Recuerde que la pr\u00e1ctica constante es clave para dominar Git. A medida que trabaje en proyectos reales y colabore con otros desarrolladores, fortalecer\u00e1 sus habilidades y comprensi\u00f3n de Git. \u00a1As\u00ed que adelante, cree su repositorio, colabore en proyectos y aproveche al m\u00e1ximo esta poderosa herramienta de control de versiones!","title":"Git"},{"location":"git/git/#git","text":"Git es un sistema de control de versiones ampliamente utilizado que permite rastrear cambios en archivos y colaborar en proyectos de desarrollo de software. En esta gu\u00eda completa de Git, exploraremos sus or\u00edgenes, comandos b\u00e1sicos y avanzados, y proporcionaremos ejemplos detallados para ayudarte a comprender este poderoso sistema de control de versiones.","title":"Git"},{"location":"git/git/#1-origenes-de-git","text":"Git fue creado por Linus Torvalds en 2005, el mismo creador del kernel de Linux. La necesidad de un sistema de control de versiones distribuido y eficiente para administrar el desarrollo del kernel de Linux condujo a la creaci\u00f3n de Git. Algunos de los principios clave que impulsaron su desarrollo incluyen: Distribuci\u00f3n : Git es un sistema de control de versiones distribuido, lo que significa que cada usuario tiene una copia completa del historial del repositorio en su m\u00e1quina local. Velocidad : Git se dise\u00f1\u00f3 para ser r\u00e1pido y eficiente, lo que lo hace adecuado para proyectos de cualquier tama\u00f1o. Integridad de los datos : Los datos almacenados en Git se verifican mediante sumas de comprobaci\u00f3n criptogr\u00e1ficas, lo que garantiza que los archivos y las revisiones no se da\u00f1en ni se modifiquen sin autorizaci\u00f3n. Soporte para ramificaci\u00f3n y fusi\u00f3n : Git facilita la creaci\u00f3n de ramas para experimentar y el proceso de fusi\u00f3n de ramas cuando se completan las caracter\u00edsticas o las correcciones de errores. Flexibilidad : Git es altamente flexible y admite una variedad de flujos de trabajo de desarrollo.","title":"1. Or\u00edgenes de Git"},{"location":"git/git/#2-configuracion-de-git","text":"Antes de comenzar a usar Git, es importante configurar su identidad. Esto asegura que las confirmaciones que realice tengan la informaci\u00f3n correcta del autor. Puede configurar su nombre de usuario y direcci\u00f3n de correo electr\u00f3nico utilizando los siguientes comandos: git config --global user.name \"Tu Nombre\" git config --global user.email \"tu@email.com\"","title":"2. Configuraci\u00f3n de Git"},{"location":"git/git/#3-comandos-basicos-de-git","text":"","title":"3. Comandos B\u00e1sicos de Git"},{"location":"git/git/#iniciar-un-repositorio","text":"Para comenzar a usar Git en un proyecto existente, o para crear un nuevo repositorio desde cero, puede usar el siguiente comando: git init","title":"Iniciar un Repositorio"},{"location":"git/git/#clonar-un-repositorio","text":"Para clonar un repositorio existente desde un servidor remoto (como GitHub), use el comando git clone . Esto crear\u00e1 una copia local del repositorio en su m\u00e1quina: git clone URL_del_repositorio","title":"Clonar un Repositorio"},{"location":"git/git/#realizar-confirmaciones","text":"Despu\u00e9s de realizar cambios en sus archivos, puede confirmarlos en Git con el siguiente flujo de comandos: git add archivo_modificado git commit -m \"Mensaje de confirmaci\u00f3n descriptivo\"","title":"Realizar Confirmaciones"},{"location":"git/git/#ver-el-estado-del-repositorio","text":"Para verificar el estado actual de su repositorio y ver qu\u00e9 archivos est\u00e1n en la etapa de preparaci\u00f3n y cu\u00e1les no, use: git status","title":"Ver el Estado del Repositorio"},{"location":"git/git/#ver-el-historial-de-confirmaciones","text":"Puede ver el historial de confirmaciones de su repositorio con el siguiente comando: git log","title":"Ver el Historial de Confirmaciones"},{"location":"git/git/#4-ramificacion-y-fusion","text":"","title":"4. Ramificaci\u00f3n y Fusi\u00f3n"},{"location":"git/git/#crear-una-rama","text":"Las ramas en Git permiten trabajar en caracter\u00edsticas o correcciones de errores de forma aislada. Para crear una nueva rama, use: git branch nombre_de_la_rama","title":"Crear una Rama"},{"location":"git/git/#cambiar-de-rama","text":"Puede cambiar entre ramas utilizando: git checkout nombre_de_la_rama","title":"Cambiar de Rama"},{"location":"git/git/#fusionar-ramas","text":"Para fusionar los cambios de una rama en otra, use: git checkout rama_destino git merge rama_fuente","title":"Fusionar Ramas"},{"location":"git/git/#5-comandos-avanzados-de-git","text":"","title":"5. Comandos Avanzados de Git"},{"location":"git/git/#rebase","text":"La rebase es una operaci\u00f3n que permite reorganizar el historial de confirmaciones para que parezca que las confirmaciones de una rama se hicieron despu\u00e9s de las de otra. Esto es \u00fatil para mantener un historial limpio y ordenado. Para realizar un rebase, use: git rebase rama_fuente","title":"Rebase"},{"location":"git/git/#stash","text":"El comando git stash le permite guardar temporalmente cambios sin confirmar en una pila y trabajar en otra rama. Esto es \u00fatil cuando necesita cambiar de rama pero no desea confirmar los cambios en curso. Los cambios guardados se pueden aplicar m\u00e1s tarde. Para guardar cambios en una pila, use: git stash","title":"Stash"},{"location":"git/git/#cherry-pick","text":"El cherry-pick le permite aplicar una confirmaci\u00f3n espec\u00edfica desde una rama a otra. Esto es \u00fatil cuando solo necesita aplicar ciertos cambios de una rama en lugar de fusionar toda la rama. Para realizar un cherry-pick, use: git cherry-pick hash_de_la_confirmaci\u00f3n","title":"Cherry-Pick"},{"location":"git/git/#submodulos","text":"Los subm\u00f3dulos permiten incluir otros repositorios de Git dentro de su propio repositorio. Esto es \u00fatil cuando necesita incluir bibliotecas o dependencias externas en su proyecto. Para agregar un subm\u00f3dulo, use: git submodule add URL_del_repositorio","title":"Subm\u00f3dulos"},{"location":"git/git/#reflog","text":"Reflog es una herramienta \u00fatil para recuperar confirmaciones \"perdidas\" o para volver a estados anteriores del repositorio. Le permite ver el historial de referencia de Git. Para ver el reflog, use: git reflog","title":"Reflog"},{"location":"git/git/#6-ramificacion-remota","text":"","title":"6. Ramificaci\u00f3n Remota"},{"location":"git/git/#_1","text":"Agregar un Repositorio Remoto Puede agregar un repositorio remoto a su repositorio local con el siguiente comando: git remote add nombre_remoto URL_del_repositorio_remoto","title":""},{"location":"git/git/#enviar-cambios-a-un-repositorio-remoto","text":"Para enviar sus cambios locales a un repositorio remoto, use: git push nombre_remoto nombre_rama","title":"Enviar Cambios a un Repositorio Remoto"},{"location":"git/git/#obtener-cambios-de-un-repositorio-remoto","text":"Para obtener los cambios realizados en un repositorio remoto, use: git pull nombre_remoto nombre_rama","title":"Obtener Cambios de un Repositorio Remoto"},{"location":"git/git/#7-git-en-la-practica","text":"","title":"7. Git en la Pr\u00e1ctica"},{"location":"git/git/#ejemplo-creacion-de-un-repositorio-y-confirmacion-de-cambios","text":"Comencemos con un ejemplo pr\u00e1ctico. Supongamos que desea iniciar un nuevo proyecto y rastrear los cambios utilizando Git. Aqu\u00ed hay una serie de pasos que puede seguir:","title":"Ejemplo: Creaci\u00f3n de un Repositorio y Confirmaci\u00f3n de Cambios"},{"location":"git/git/#paso-1-inicializar-un-repositorio","text":"Primero, cree un directorio para su proyecto y navegue a \u00e9l en la terminal. Luego, ejecute el siguiente comando para iniciar un repositorio Git en ese directorio: mkdir mi_proyecto cd mi_proyecto git init","title":"Paso 1: Inicializar un Repositorio"},{"location":"git/git/#paso-2-agregar-y-confirmar-cambios","text":"Cree un archivo en su proyecto (por ejemplo, main.py ) y agregue algo de c\u00f3digo. Luego, use los siguientes comandos para agregar y confirmar sus cambios: echo \"print('Hola, mundo')\" > main.py git add main.py git commit -m \"Agregado archivo main.py con un saludo\"","title":"Paso 2: Agregar y Confirmar Cambios"},{"location":"git/git/#paso-3-ver-el-historial","text":"Puede ver el historial de confirmaciones utilizando el comando git log : git log","title":"Paso 3: Ver el Historial"},{"location":"git/git/#ejemplo-trabajo-con-ramas","text":"Supongamos que desea trabajar en una nueva caracter\u00edstica para su proyecto en una rama separada. A continuaci\u00f3n, se muestra c\u00f3mo puede hacerlo:","title":"Ejemplo: Trabajo con Ramas"},{"location":"git/git/#paso-1-crear-una-rama","text":"git branch nueva_caracteristica","title":"Paso 1: Crear una Rama"},{"location":"git/git/#paso-2-cambiar-de-rama","text":"git checkout nueva_caracteristica","title":"Paso 2: Cambiar de Rama"},{"location":"git/git/#paso-3-realizar-cambios-y-confirmar","text":"Haga los cambios necesarios en su proyecto y conf\u00edrmelos en la nueva rama: echo \"print('Nueva caracter\u00edstica agregada')\" >> main.py git add main.py git commit -m \"Agregada nueva caracter\u00edstica\"","title":"Paso 3: Realizar Cambios y Confirmar"},{"location":"git/git/#paso-4-fusionar-la-rama","text":"Una vez que haya completado su nueva caracter\u00edstica, puede fusionarla con la rama principal de la siguiente manera: git checkout master git merge nueva_caracteristica","title":"Paso 4: Fusionar la Rama"},{"location":"git/git/#8-conclusiones","text":"Git es una herramienta esencial para cualquier desarrollador de software. Permite el control de versiones, la colaboraci\u00f3n en proyectos y el seguimiento de cambios de manera eficiente. Conocer los comandos b\u00e1sicos y avanzados de Git es fundamental para trabajar de manera efectiva en proyectos de desarrollo. Esta gu\u00eda completa ha cubierto una variedad de conceptos y comandos de Git, desde la configuraci\u00f3n inicial hasta operaciones m\u00e1s avanzadas como rebase, stash y cherry-pick. Al aplicar estos conocimientos en su flujo de trabajo diario, se convertir\u00e1 en un desarrollador m\u00e1s eficiente y colaborativo. Recuerde que la pr\u00e1ctica constante es clave para dominar Git. A medida que trabaje en proyectos reales y colabore con otros desarrolladores, fortalecer\u00e1 sus habilidades y comprensi\u00f3n de Git. \u00a1As\u00ed que adelante, cree su repositorio, colabore en proyectos y aproveche al m\u00e1ximo esta poderosa herramienta de control de versiones!","title":"8. Conclusiones"},{"location":"git/github/","text":"GitHub GitHub es una plataforma de desarrollo colaborativo que utiliza Git como sistema de control de versiones. En esta gu\u00eda completa y detallada de GitHub, exploraremos sus or\u00edgenes, comandos b\u00e1sicos y avanzados, y proporcionaremos ejemplos detallados para ayudarte a comprender esta poderosa plataforma. 1. Or\u00edgenes de GitHub GitHub fue fundado en abril de 2008 por Chris Wanstrath, PJ Hyett y Tom Preston-Werner. La plataforma se cre\u00f3 con el prop\u00f3sito de proporcionar a los desarrolladores un lugar donde pudieran colaborar en proyectos de c\u00f3digo abierto utilizando Git. Algunos de los principios clave que impulsaron su desarrollo incluyen: Colaboraci\u00f3n en equipo : GitHub permite a los equipos de desarrollo trabajar de manera colaborativa en proyectos de software, facilitando la comunicaci\u00f3n y la contribuci\u00f3n de m\u00faltiples desarrolladores desde cualquier parte del mundo. Control de versiones : GitHub utiliza Git como sistema de control de versiones, lo que permite rastrear cambios en archivos y colaborar en proyectos mientras se mantiene un historial completo de cambios. Esto es esencial para llevar un registro de qui\u00e9n hizo qu\u00e9 y cu\u00e1ndo. Comunidad de c\u00f3digo abierto : GitHub se ha convertido en un lugar central para la comunidad de c\u00f3digo abierto. Facilita la colaboraci\u00f3n en proyectos de c\u00f3digo abierto, lo que permite a los desarrolladores de todo el mundo contribuir y mejorar proyectos de software de manera colaborativa. 2. Creaci\u00f3n de una Cuenta de GitHub Antes de comenzar a usar GitHub, necesitar\u00e1s crear una cuenta en su sitio web. Puedes registrarte en GitHub.com de forma gratuita. Una vez que tengas una cuenta, podr\u00e1s crear y gestionar repositorios, colaborar en proyectos y contribuir al c\u00f3digo abierto. Si ya tienes una cuenta, inicia sesi\u00f3n con tus credenciales. 3. Comandos B\u00e1sicos de Git en GitHub Crear un Repositorio Para crear un nuevo repositorio en GitHub, sigue estos pasos: Inicia sesi\u00f3n en tu cuenta de GitHub. Haz clic en el bot\u00f3n \"+\" en la esquina superior derecha de la p\u00e1gina y selecciona \"Nuevo repositorio\". Proporciona un nombre para tu repositorio, una descripci\u00f3n opcional y configura las opciones deseadas. Puedes elegir entre crear un repositorio p\u00fablico (visible para todos) o privado (visible solo para ti y los colaboradores que invites). Puedes inicializar el repositorio con un archivo README, un archivo Gitignore y una licencia si es necesario. Haz clic en \"Crear repositorio\". Clonar un Repositorio Para clonar un repositorio existente desde GitHub a tu m\u00e1quina local, utiliza el comando git clone seguido de la URL del repositorio. Por ejemplo: git clone https://github.com/usuario/nombre-repositorio.git Esto descargar\u00e1 una copia del repositorio a tu m\u00e1quina local y configurar\u00e1 autom\u00e1ticamente la conexi\u00f3n con el repositorio en l\u00ednea. Realizar Confirmaciones (Commits) Despu\u00e9s de realizar cambios en tus archivos, puedes confirmarlos en Git y enviarlos a GitHub con los siguientes comandos: git add archivo_modificado git commit -m \"Mensaje de confirmaci\u00f3n descriptivo\" git push origin nombre_rama git add : Este comando agrega los cambios realizados en un archivo al \u00e1rea de preparaci\u00f3n (staging area), lo que significa que se incluir\u00e1n en la pr\u00f3xima confirmaci\u00f3n. git commit : Confirma los cambios en el repositorio localmente con un mensaje descriptivo que explica qu\u00e9 cambios se realizaron. git push : Env\u00eda los cambios confirmados al repositorio remoto en GitHub. Realizar Solicitudes de Extracci\u00f3n (Pull Requests) Las solicitudes de extracci\u00f3n (Pull Requests o PR) son una forma com\u00fan de colaborar en GitHub. Permite a otros revisar tus cambios antes de fusionarlos en la rama principal. Aqu\u00ed tienes una breve descripci\u00f3n de c\u00f3mo funcionan: Fork (Bifurcar) : Antes de contribuir a un repositorio, puedes crear una copia (fork) de ese repositorio en tu propia cuenta de GitHub. Clone (Clonar) : Clona tu repositorio (fork) en tu m\u00e1quina local. Branch (Rama) : Crea una nueva rama para realizar tus cambios. Es importante mantener los cambios de tu rama separados de la rama principal. Commit (Confirmar) : Realiza cambios y realiza confirmaciones (commits) en tu rama. Push (Enviar) : Env\u00eda tus cambios a tu repositorio en GitHub. Pull Request (Solicitud de Extracci\u00f3n) : Crea una solicitud de extracci\u00f3n desde tu rama a la rama principal del repositorio original. Revisi\u00f3n y Fusi\u00f3n : Otros colaboradores revisar\u00e1n tus cambios y, si todo est\u00e1 en orden, fusionar\u00e1n tu rama en la rama principal. Ramificaci\u00f3n y Fusi\u00f3n GitHub facilita la creaci\u00f3n de ramas y la fusi\u00f3n de cambios. Las ramas permiten trabajar en nuevas caracter\u00edsticas o correcciones sin afectar la rama principal del proyecto. Cuando tus cambios est\u00e1n listos para ser incluidos en la rama principal, puedes solicitar su fusi\u00f3n. Esto se hace t\u00edpicamente a trav\u00e9s de una solicitud de extracci\u00f3n. 4. Comandos Avanzados de GitHub Colaboraci\u00f3n en Repositorios GitHub ofrece una variedad de herramientas para colaborar en repositorios. Algunas de las acciones avanzadas incluyen: Asignaci\u00f3n de Problemas : Puedes asignar problemas a usuarios espec\u00edficos para indicar qui\u00e9n est\u00e1 trabajando en ellos. Etiquetado de Problemas y Solicitudes de Extracci\u00f3n : Utiliza etiquetas para categorizar problemas y solicitudes de extracci\u00f3n, lo que facilita la b\u00fasqueda y organizaci\u00f3n. Comentarios y Revisi\u00f3n : Puedes comentar en problemas, solicitudes de extracci\u00f3n y confirmaciones (commits) para discutir cambios y proporcionar retroalimentaci\u00f3n. GitHub Actions : Esta funci\u00f3n te permite automatizar flujos de trabajo, como pruebas de c\u00f3digo y despliegues, directamente desde tu repositorio. Integraci\u00f3n con Servicios de CI/CD : Puedes integrar GitHub con servicios de Integraci\u00f3n Continua/Entrega Continua (CI/CD) para automatizar la construcci\u00f3n, prueba y despliegue de tu c\u00f3digo. 5. Gesti\u00f3n de Problemas (Issues) \u00bfQu\u00e9 son los Problemas en GitHub? Los problemas en GitHub son una forma de realizar un seguimiento de tareas, sugerencias, mejoras y errores en tus proyectos. Son una herramienta fundamental para la comunicaci\u00f3n y la colaboraci\u00f3n dentro de un equipo de desarrollo. Aqu\u00ed hay algunos aspectos clave sobre los problemas: Creaci\u00f3n de Problemas : Cualquier persona con acceso al repositorio puede crear un problema. Esto es \u00fatil para que los usuarios o colaboradores informen sobre problemas que encuentren. Asignaci\u00f3n : Puedes asignar un problema a un miembro espec\u00edfico del equipo para indicar qui\u00e9n es responsable de resolverlo. Etiquetas : Las etiquetas se utilizan para categorizar problemas y facilitar la b\u00fasqueda y organizaci\u00f3n. Por ejemplo, puedes etiquetar un problema como \"bug\" o \"mejora\". Comentarios : Los problemas admiten comentarios que permiten la discusi\u00f3n y el seguimiento del estado de la tarea. Referencias Cruzadas : Puedes vincular problemas entre s\u00ed, lo que es \u00fatil cuando un problema depende de la resoluci\u00f3n de otro. Flujo de Trabajo de Problemas El flujo de trabajo t\u00edpico para problemas en GitHub suele ser el siguiente: Creaci\u00f3n de un Problema : Alguien crea un problema para informar sobre un error o una mejora. Asignaci\u00f3n : El problema se asigna a un miembro del equipo o al responsable adecuado. Discusi\u00f3n : Los colaboradores pueden comentar en el problema para discutir los detalles y posibles soluciones. Trabajo en la Soluci\u00f3n : El asignado trabaja en la soluci\u00f3n del problema y realiza confirmaciones (commits) en una rama espec\u00edfica. Referencia Cruzada : Si se abren problemas adicionales relacionados, se pueden vincular entre s\u00ed. Revisi\u00f3n y Confirmaci\u00f3n : Otros miembros del equipo revisan los cambios y proporcionan retroalimentaci\u00f3n. Una vez que se revisa y aprueba la soluci\u00f3n, se confirma (hace un commit) en la rama principal o se fusiona a trav\u00e9s de una solicitud de extracci\u00f3n (Pull Request). Cierre del Problema : Una vez que se ha solucionado el problema y se ha confirmado, se cierra. 6. GitHub Pages GitHub Pages es una funci\u00f3n de GitHub que te permite alojar sitios web est\u00e1ticos directamente desde tu repositorio. Esto es ideal para la documentaci\u00f3n de proyectos, blogs personales, sitios web personales y proyectos web peque\u00f1os. Aqu\u00ed tienes una gu\u00eda detallada sobre c\u00f3mo configurar GitHub Pages: Habilitar GitHub Pages Para habilitar GitHub Pages para tu repositorio, sigue estos pasos: Crear un Repositorio : Aseg\u00farate de que tu proyecto est\u00e9 en un repositorio de GitHub. Ir a la Configuraci\u00f3n del Repositorio : En la p\u00e1gina de inicio de tu repositorio, haz clic en la pesta\u00f1a \"Configuraci\u00f3n\" en la parte superior. Despl\u00e1zate hacia abajo : Despl\u00e1zate hacia abajo hasta la secci\u00f3n \"GitHub Pages\". Seleccionar Rama : En la secci\u00f3n de GitHub Pages, elige la rama que contiene los archivos de tu sitio web. Por lo general, esto es \"main\" o \"master\". Elegir Carpeta (Opcional) : Puedes especificar una carpeta en tu repositorio que GitHub Pages utilizar\u00e1 como directorio ra\u00edz de tu sitio web. Si no se especifica, se utilizar\u00e1 la ra\u00edz del repositorio. Guardar : Haz clic en el bot\u00f3n \"Guardar\" o \"Guardar cambios\" para habilitar GitHub Pages. Obtener la URL : Una vez que GitHub Pages est\u00e9 habilitado, se te proporcionar\u00e1 una URL donde estar\u00e1 alojado tu sitio web. Personalizaci\u00f3n Puedes personalizar tu sitio web de GitHub Pages de varias maneras: Tema : Puedes seleccionar un tema para tu sitio web desde la secci\u00f3n de GitHub Pages en la configuraci\u00f3n de tu repositorio. Los temas son conjuntos predefinidos de estilos y dise\u00f1os que pueden mejorar la apariencia de tu sitio web. Configuraci\u00f3n de Dominio Personalizado : Si tienes tu propio dominio, puedes configurarlo para que ap unte a tu sitio de GitHub Pages. Archivos Personalizados : Puedes agregar tus propios archivos HTML, CSS y JavaScript para personalizar a\u00fan m\u00e1s tu sitio. Uso de GitHub Pages para Documentaci\u00f3n Una de las aplicaciones m\u00e1s comunes de GitHub Pages es alojar la documentaci\u00f3n de tu proyecto. Puedes escribir documentaci\u00f3n utilizando Markdown y organizarla en directorios. GitHub Pages comprender\u00e1 autom\u00e1ticamente la estructura de directorios y generar\u00e1 un sitio web f\u00e1cil de navegar. 7. GitHub Actions GitHub Actions es una plataforma de automatizaci\u00f3n de flujos de trabajo integrada directamente en GitHub. Te permite automatizar tareas, flujos de trabajo y procesos en respuesta a eventos espec\u00edficos en tu repositorio. Aqu\u00ed te explicamos c\u00f3mo aprovechar al m\u00e1ximo GitHub Actions: Flujo de Trabajo de GitHub Actions Un flujo de trabajo de GitHub Actions consta de uno o varios trabajos, que a su vez consisten en una serie de pasos. Cada paso representa una tarea que se ejecutar\u00e1 en un entorno espec\u00edfico. Aqu\u00ed hay una descripci\u00f3n general del flujo de trabajo: Evento Disparador : Un evento en tu repositorio, como la confirmaci\u00f3n de c\u00f3digo, la creaci\u00f3n de una solicitud de extracci\u00f3n o el cronograma, desencadena el flujo de trabajo. Ejecuci\u00f3n de Trabajos : El flujo de trabajo comienza ejecutando uno o varios trabajos en paralelo o secuencialmente, seg\u00fan lo configuremos. Pasos : Cada trabajo consiste en una serie de pasos. Los pasos son tareas individuales que se ejecutan en un entorno espec\u00edfico. Por ejemplo, puedes tener un paso para construir tu aplicaci\u00f3n, otro paso para ejecutar pruebas y un paso final para implementar en producci\u00f3n. Matriz (Matrix) : Puedes configurar matrices para ejecutar pasos en diferentes versiones de sistemas operativos, entornos o configuraciones. Esto es \u00fatil para probar la compatibilidad con m\u00faltiples plataformas. Almacenamiento en Cach\u00e9 : GitHub Actions permite el almacenamiento en cach\u00e9 de dependencias o archivos para acelerar las ejecuciones posteriores. Notificaciones : Puedes configurar notificaciones por correo electr\u00f3nico, mensajes de chat o integraciones con otras herramientas para recibir alertas sobre el estado de los flujos de trabajo. Crear un Flujo de Trabajo Para crear un flujo de trabajo de GitHub Actions, debes crear un archivo YAML en el directorio .github/workflows de tu repositorio. Este archivo define c\u00f3mo se ejecutar\u00e1 el flujo de trabajo y qu\u00e9 pasos debe seguir. Aqu\u00ed hay un ejemplo de un archivo YAML simple para un flujo de trabajo que ejecuta pruebas en cada confirmaci\u00f3n de c\u00f3digo: name : CI/CD Pipeline on : push : branches : - main jobs : build : runs-on : ubuntu-latest steps : - name : Checkout Repository uses : actions/checkout@v2 - name : Set Up Python uses : actions/setup-python@v2 with : python-version : 3.8 - name : Install Dependencies run : pip install -r requirements.txt - name : Run Tests run : pytest Este archivo define un flujo de trabajo llamado \"CI/CD Pipeline\" que se ejecutar\u00e1 en cada empuje (push) a la rama principal. El flujo de trabajo se ejecuta en un entorno Ubuntu, donde se realiza la configuraci\u00f3n de Python, se instalan las dependencias y se ejecutan las pruebas. Usos Comunes de GitHub Actions GitHub Actions se utiliza para automatizar una amplia variedad de flujos de trabajo, como: Pruebas Continuas (CI) : Ejecutar pruebas automatizadas en cada confirmaci\u00f3n de c\u00f3digo para garantizar que el c\u00f3digo funcione correctamente. Entrega Continua (CD) : Automatizar la implementaci\u00f3n de c\u00f3digo en entornos de producci\u00f3n despu\u00e9s de que las pruebas hayan pasado con \u00e9xito. Publicaci\u00f3n de Paquetes : Publicar autom\u00e1ticamente bibliotecas y paquetes en repositorios de paquetes como PyPI o npm. Notificaciones y Comentarios : Enviar notificaciones o comentarios autom\u00e1ticos en respuestas a eventos espec\u00edficos. Generaci\u00f3n de Documentaci\u00f3n : Generar y alojar autom\u00e1ticamente documentaci\u00f3n actualizada en GitHub Pages. An\u00e1lisis de C\u00f3digo : Realizar an\u00e1lisis de c\u00f3digo est\u00e1tico y generar informes autom\u00e1ticamente. Automatizaci\u00f3n de Tareas : Automatizar tareas de mantenimiento, como limpieza de cach\u00e9, copias de seguridad y m\u00e1s. Ejemplo Avanzado de GitHub Actions Veamos un ejemplo m\u00e1s avanzado de GitHub Actions que incluye pruebas, implementaci\u00f3n y notificaciones: name : CI/CD Pipeline on : push : branches : - main jobs : build : runs-on : ubuntu-latest steps : - name : Checkout Repository uses : actions/checkout@v2 - name : Set Up Python uses : actions/setup-python@v2 with : python-version : 3.8 - name : Install Dependencies run : pip install -r requirements.txt - name : Run Tests run : pytest deploy : needs : build runs-on : ubuntu-latest steps : - name : Deploy to Production run : | if [ ${{ success() }} = \"true\" ]; then ssh user@production-server \"cd /var/www/myapp && git pull origin main && systemctl restart myapp\" fi env : SSH_PRIVATE_KEY : ${{ secrets.SSH_PRIVATE_KEY }} notify : needs : deploy runs-on : ubuntu-latest steps : - name : Send Notification uses : appleboy/telegram-action@v0.1.2 with : to : ${{ secrets.TELEGRAM_TO }} token : ${{ secrets.TELEGRAM_TOKEN }} message : \"Deployment successful!\" Este ejemplo incluye tres trabajos en el flujo de trabajo: build : Realiza las pruebas de c\u00f3digo y asegura que todo est\u00e9 funcionando correctamente. deploy : Implementa el c\u00f3digo en un servidor de producci\u00f3n si las pruebas han pasado con \u00e9xito. Utiliza una clave SSH almacenada en secretos para la autenticaci\u00f3n. notify : Env\u00eda una notificaci\u00f3n de Telegram para informar sobre el \u00e9xito de la implementaci\u00f3n. 9. Conclusiones GitHub ofrece una amplia gama de caracter\u00edsticas y herramientas poderosas para la gesti\u00f3n de problemas, la publicaci\u00f3n de sitios web y la automatizaci\u00f3n de flujos de trabajo. La gesti\u00f3n de problemas es esencial para la colaboraci\u00f3n efectiva en proyectos, GitHub Pages facilita la creaci\u00f3n y el alojamiento de sitios web, y GitHub Actions permite la automatizaci\u00f3n de tareas y flujos de trabajo. A medida que explores m\u00e1s a fondo estas herramientas y las integres en tu flujo de trabajo de desarrollo, podr\u00e1s mejorar la eficiencia de tu equipo y la calidad de tus proyectos. Sigue explorando la documentaci\u00f3n de GitHub y experimenta con ejemplos para dominar estas capacidades y aprovechar al m\u00e1ximo la plataforma.","title":"GitHub"},{"location":"git/github/#github","text":"GitHub es una plataforma de desarrollo colaborativo que utiliza Git como sistema de control de versiones. En esta gu\u00eda completa y detallada de GitHub, exploraremos sus or\u00edgenes, comandos b\u00e1sicos y avanzados, y proporcionaremos ejemplos detallados para ayudarte a comprender esta poderosa plataforma.","title":"GitHub"},{"location":"git/github/#1-origenes-de-github","text":"GitHub fue fundado en abril de 2008 por Chris Wanstrath, PJ Hyett y Tom Preston-Werner. La plataforma se cre\u00f3 con el prop\u00f3sito de proporcionar a los desarrolladores un lugar donde pudieran colaborar en proyectos de c\u00f3digo abierto utilizando Git. Algunos de los principios clave que impulsaron su desarrollo incluyen: Colaboraci\u00f3n en equipo : GitHub permite a los equipos de desarrollo trabajar de manera colaborativa en proyectos de software, facilitando la comunicaci\u00f3n y la contribuci\u00f3n de m\u00faltiples desarrolladores desde cualquier parte del mundo. Control de versiones : GitHub utiliza Git como sistema de control de versiones, lo que permite rastrear cambios en archivos y colaborar en proyectos mientras se mantiene un historial completo de cambios. Esto es esencial para llevar un registro de qui\u00e9n hizo qu\u00e9 y cu\u00e1ndo. Comunidad de c\u00f3digo abierto : GitHub se ha convertido en un lugar central para la comunidad de c\u00f3digo abierto. Facilita la colaboraci\u00f3n en proyectos de c\u00f3digo abierto, lo que permite a los desarrolladores de todo el mundo contribuir y mejorar proyectos de software de manera colaborativa.","title":"1. Or\u00edgenes de GitHub"},{"location":"git/github/#2-creacion-de-una-cuenta-de-github","text":"Antes de comenzar a usar GitHub, necesitar\u00e1s crear una cuenta en su sitio web. Puedes registrarte en GitHub.com de forma gratuita. Una vez que tengas una cuenta, podr\u00e1s crear y gestionar repositorios, colaborar en proyectos y contribuir al c\u00f3digo abierto. Si ya tienes una cuenta, inicia sesi\u00f3n con tus credenciales.","title":"2. Creaci\u00f3n de una Cuenta de GitHub"},{"location":"git/github/#3-comandos-basicos-de-git-en-github","text":"","title":"3. Comandos B\u00e1sicos de Git en GitHub"},{"location":"git/github/#crear-un-repositorio","text":"Para crear un nuevo repositorio en GitHub, sigue estos pasos: Inicia sesi\u00f3n en tu cuenta de GitHub. Haz clic en el bot\u00f3n \"+\" en la esquina superior derecha de la p\u00e1gina y selecciona \"Nuevo repositorio\". Proporciona un nombre para tu repositorio, una descripci\u00f3n opcional y configura las opciones deseadas. Puedes elegir entre crear un repositorio p\u00fablico (visible para todos) o privado (visible solo para ti y los colaboradores que invites). Puedes inicializar el repositorio con un archivo README, un archivo Gitignore y una licencia si es necesario. Haz clic en \"Crear repositorio\".","title":"Crear un Repositorio"},{"location":"git/github/#clonar-un-repositorio","text":"Para clonar un repositorio existente desde GitHub a tu m\u00e1quina local, utiliza el comando git clone seguido de la URL del repositorio. Por ejemplo: git clone https://github.com/usuario/nombre-repositorio.git Esto descargar\u00e1 una copia del repositorio a tu m\u00e1quina local y configurar\u00e1 autom\u00e1ticamente la conexi\u00f3n con el repositorio en l\u00ednea.","title":"Clonar un Repositorio"},{"location":"git/github/#realizar-confirmaciones-commits","text":"Despu\u00e9s de realizar cambios en tus archivos, puedes confirmarlos en Git y enviarlos a GitHub con los siguientes comandos: git add archivo_modificado git commit -m \"Mensaje de confirmaci\u00f3n descriptivo\" git push origin nombre_rama git add : Este comando agrega los cambios realizados en un archivo al \u00e1rea de preparaci\u00f3n (staging area), lo que significa que se incluir\u00e1n en la pr\u00f3xima confirmaci\u00f3n. git commit : Confirma los cambios en el repositorio localmente con un mensaje descriptivo que explica qu\u00e9 cambios se realizaron. git push : Env\u00eda los cambios confirmados al repositorio remoto en GitHub.","title":"Realizar Confirmaciones (Commits)"},{"location":"git/github/#realizar-solicitudes-de-extraccion-pull-requests","text":"Las solicitudes de extracci\u00f3n (Pull Requests o PR) son una forma com\u00fan de colaborar en GitHub. Permite a otros revisar tus cambios antes de fusionarlos en la rama principal. Aqu\u00ed tienes una breve descripci\u00f3n de c\u00f3mo funcionan: Fork (Bifurcar) : Antes de contribuir a un repositorio, puedes crear una copia (fork) de ese repositorio en tu propia cuenta de GitHub. Clone (Clonar) : Clona tu repositorio (fork) en tu m\u00e1quina local. Branch (Rama) : Crea una nueva rama para realizar tus cambios. Es importante mantener los cambios de tu rama separados de la rama principal. Commit (Confirmar) : Realiza cambios y realiza confirmaciones (commits) en tu rama. Push (Enviar) : Env\u00eda tus cambios a tu repositorio en GitHub. Pull Request (Solicitud de Extracci\u00f3n) : Crea una solicitud de extracci\u00f3n desde tu rama a la rama principal del repositorio original. Revisi\u00f3n y Fusi\u00f3n : Otros colaboradores revisar\u00e1n tus cambios y, si todo est\u00e1 en orden, fusionar\u00e1n tu rama en la rama principal.","title":"Realizar Solicitudes de Extracci\u00f3n (Pull Requests)"},{"location":"git/github/#ramificacion-y-fusion","text":"GitHub facilita la creaci\u00f3n de ramas y la fusi\u00f3n de cambios. Las ramas permiten trabajar en nuevas caracter\u00edsticas o correcciones sin afectar la rama principal del proyecto. Cuando tus cambios est\u00e1n listos para ser incluidos en la rama principal, puedes solicitar su fusi\u00f3n. Esto se hace t\u00edpicamente a trav\u00e9s de una solicitud de extracci\u00f3n.","title":"Ramificaci\u00f3n y Fusi\u00f3n"},{"location":"git/github/#4-comandos-avanzados-de-github","text":"","title":"4. Comandos Avanzados de GitHub"},{"location":"git/github/#colaboracion-en-repositorios","text":"GitHub ofrece una variedad de herramientas para colaborar en repositorios. Algunas de las acciones avanzadas incluyen: Asignaci\u00f3n de Problemas : Puedes asignar problemas a usuarios espec\u00edficos para indicar qui\u00e9n est\u00e1 trabajando en ellos. Etiquetado de Problemas y Solicitudes de Extracci\u00f3n : Utiliza etiquetas para categorizar problemas y solicitudes de extracci\u00f3n, lo que facilita la b\u00fasqueda y organizaci\u00f3n. Comentarios y Revisi\u00f3n : Puedes comentar en problemas, solicitudes de extracci\u00f3n y confirmaciones (commits) para discutir cambios y proporcionar retroalimentaci\u00f3n. GitHub Actions : Esta funci\u00f3n te permite automatizar flujos de trabajo, como pruebas de c\u00f3digo y despliegues, directamente desde tu repositorio. Integraci\u00f3n con Servicios de CI/CD : Puedes integrar GitHub con servicios de Integraci\u00f3n Continua/Entrega Continua (CI/CD) para automatizar la construcci\u00f3n, prueba y despliegue de tu c\u00f3digo.","title":"Colaboraci\u00f3n en Repositorios"},{"location":"git/github/#5-gestion-de-problemas-issues","text":"","title":"5. Gesti\u00f3n de Problemas (Issues)"},{"location":"git/github/#que-son-los-problemas-en-github","text":"Los problemas en GitHub son una forma de realizar un seguimiento de tareas, sugerencias, mejoras y errores en tus proyectos. Son una herramienta fundamental para la comunicaci\u00f3n y la colaboraci\u00f3n dentro de un equipo de desarrollo. Aqu\u00ed hay algunos aspectos clave sobre los problemas: Creaci\u00f3n de Problemas : Cualquier persona con acceso al repositorio puede crear un problema. Esto es \u00fatil para que los usuarios o colaboradores informen sobre problemas que encuentren. Asignaci\u00f3n : Puedes asignar un problema a un miembro espec\u00edfico del equipo para indicar qui\u00e9n es responsable de resolverlo. Etiquetas : Las etiquetas se utilizan para categorizar problemas y facilitar la b\u00fasqueda y organizaci\u00f3n. Por ejemplo, puedes etiquetar un problema como \"bug\" o \"mejora\". Comentarios : Los problemas admiten comentarios que permiten la discusi\u00f3n y el seguimiento del estado de la tarea. Referencias Cruzadas : Puedes vincular problemas entre s\u00ed, lo que es \u00fatil cuando un problema depende de la resoluci\u00f3n de otro.","title":"\u00bfQu\u00e9 son los Problemas en GitHub?"},{"location":"git/github/#flujo-de-trabajo-de-problemas","text":"El flujo de trabajo t\u00edpico para problemas en GitHub suele ser el siguiente: Creaci\u00f3n de un Problema : Alguien crea un problema para informar sobre un error o una mejora. Asignaci\u00f3n : El problema se asigna a un miembro del equipo o al responsable adecuado. Discusi\u00f3n : Los colaboradores pueden comentar en el problema para discutir los detalles y posibles soluciones. Trabajo en la Soluci\u00f3n : El asignado trabaja en la soluci\u00f3n del problema y realiza confirmaciones (commits) en una rama espec\u00edfica. Referencia Cruzada : Si se abren problemas adicionales relacionados, se pueden vincular entre s\u00ed. Revisi\u00f3n y Confirmaci\u00f3n : Otros miembros del equipo revisan los cambios y proporcionan retroalimentaci\u00f3n. Una vez que se revisa y aprueba la soluci\u00f3n, se confirma (hace un commit) en la rama principal o se fusiona a trav\u00e9s de una solicitud de extracci\u00f3n (Pull Request). Cierre del Problema : Una vez que se ha solucionado el problema y se ha confirmado, se cierra.","title":"Flujo de Trabajo de Problemas"},{"location":"git/github/#6-github-pages","text":"GitHub Pages es una funci\u00f3n de GitHub que te permite alojar sitios web est\u00e1ticos directamente desde tu repositorio. Esto es ideal para la documentaci\u00f3n de proyectos, blogs personales, sitios web personales y proyectos web peque\u00f1os. Aqu\u00ed tienes una gu\u00eda detallada sobre c\u00f3mo configurar GitHub Pages:","title":"6. GitHub Pages"},{"location":"git/github/#habilitar-github-pages","text":"Para habilitar GitHub Pages para tu repositorio, sigue estos pasos: Crear un Repositorio : Aseg\u00farate de que tu proyecto est\u00e9 en un repositorio de GitHub. Ir a la Configuraci\u00f3n del Repositorio : En la p\u00e1gina de inicio de tu repositorio, haz clic en la pesta\u00f1a \"Configuraci\u00f3n\" en la parte superior. Despl\u00e1zate hacia abajo : Despl\u00e1zate hacia abajo hasta la secci\u00f3n \"GitHub Pages\". Seleccionar Rama : En la secci\u00f3n de GitHub Pages, elige la rama que contiene los archivos de tu sitio web. Por lo general, esto es \"main\" o \"master\". Elegir Carpeta (Opcional) : Puedes especificar una carpeta en tu repositorio que GitHub Pages utilizar\u00e1 como directorio ra\u00edz de tu sitio web. Si no se especifica, se utilizar\u00e1 la ra\u00edz del repositorio. Guardar : Haz clic en el bot\u00f3n \"Guardar\" o \"Guardar cambios\" para habilitar GitHub Pages. Obtener la URL : Una vez que GitHub Pages est\u00e9 habilitado, se te proporcionar\u00e1 una URL donde estar\u00e1 alojado tu sitio web.","title":"Habilitar GitHub Pages"},{"location":"git/github/#personalizacion","text":"Puedes personalizar tu sitio web de GitHub Pages de varias maneras: Tema : Puedes seleccionar un tema para tu sitio web desde la secci\u00f3n de GitHub Pages en la configuraci\u00f3n de tu repositorio. Los temas son conjuntos predefinidos de estilos y dise\u00f1os que pueden mejorar la apariencia de tu sitio web. Configuraci\u00f3n de Dominio Personalizado : Si tienes tu propio dominio, puedes configurarlo para que ap unte a tu sitio de GitHub Pages. Archivos Personalizados : Puedes agregar tus propios archivos HTML, CSS y JavaScript para personalizar a\u00fan m\u00e1s tu sitio.","title":"Personalizaci\u00f3n"},{"location":"git/github/#uso-de-github-pages-para-documentacion","text":"Una de las aplicaciones m\u00e1s comunes de GitHub Pages es alojar la documentaci\u00f3n de tu proyecto. Puedes escribir documentaci\u00f3n utilizando Markdown y organizarla en directorios. GitHub Pages comprender\u00e1 autom\u00e1ticamente la estructura de directorios y generar\u00e1 un sitio web f\u00e1cil de navegar.","title":"Uso de GitHub Pages para Documentaci\u00f3n"},{"location":"git/github/#7-github-actions","text":"GitHub Actions es una plataforma de automatizaci\u00f3n de flujos de trabajo integrada directamente en GitHub. Te permite automatizar tareas, flujos de trabajo y procesos en respuesta a eventos espec\u00edficos en tu repositorio. Aqu\u00ed te explicamos c\u00f3mo aprovechar al m\u00e1ximo GitHub Actions:","title":"7. GitHub Actions"},{"location":"git/github/#flujo-de-trabajo-de-github-actions","text":"Un flujo de trabajo de GitHub Actions consta de uno o varios trabajos, que a su vez consisten en una serie de pasos. Cada paso representa una tarea que se ejecutar\u00e1 en un entorno espec\u00edfico. Aqu\u00ed hay una descripci\u00f3n general del flujo de trabajo: Evento Disparador : Un evento en tu repositorio, como la confirmaci\u00f3n de c\u00f3digo, la creaci\u00f3n de una solicitud de extracci\u00f3n o el cronograma, desencadena el flujo de trabajo. Ejecuci\u00f3n de Trabajos : El flujo de trabajo comienza ejecutando uno o varios trabajos en paralelo o secuencialmente, seg\u00fan lo configuremos. Pasos : Cada trabajo consiste en una serie de pasos. Los pasos son tareas individuales que se ejecutan en un entorno espec\u00edfico. Por ejemplo, puedes tener un paso para construir tu aplicaci\u00f3n, otro paso para ejecutar pruebas y un paso final para implementar en producci\u00f3n. Matriz (Matrix) : Puedes configurar matrices para ejecutar pasos en diferentes versiones de sistemas operativos, entornos o configuraciones. Esto es \u00fatil para probar la compatibilidad con m\u00faltiples plataformas. Almacenamiento en Cach\u00e9 : GitHub Actions permite el almacenamiento en cach\u00e9 de dependencias o archivos para acelerar las ejecuciones posteriores. Notificaciones : Puedes configurar notificaciones por correo electr\u00f3nico, mensajes de chat o integraciones con otras herramientas para recibir alertas sobre el estado de los flujos de trabajo.","title":"Flujo de Trabajo de GitHub Actions"},{"location":"git/github/#crear-un-flujo-de-trabajo","text":"Para crear un flujo de trabajo de GitHub Actions, debes crear un archivo YAML en el directorio .github/workflows de tu repositorio. Este archivo define c\u00f3mo se ejecutar\u00e1 el flujo de trabajo y qu\u00e9 pasos debe seguir. Aqu\u00ed hay un ejemplo de un archivo YAML simple para un flujo de trabajo que ejecuta pruebas en cada confirmaci\u00f3n de c\u00f3digo: name : CI/CD Pipeline on : push : branches : - main jobs : build : runs-on : ubuntu-latest steps : - name : Checkout Repository uses : actions/checkout@v2 - name : Set Up Python uses : actions/setup-python@v2 with : python-version : 3.8 - name : Install Dependencies run : pip install -r requirements.txt - name : Run Tests run : pytest Este archivo define un flujo de trabajo llamado \"CI/CD Pipeline\" que se ejecutar\u00e1 en cada empuje (push) a la rama principal. El flujo de trabajo se ejecuta en un entorno Ubuntu, donde se realiza la configuraci\u00f3n de Python, se instalan las dependencias y se ejecutan las pruebas.","title":"Crear un Flujo de Trabajo"},{"location":"git/github/#usos-comunes-de-github-actions","text":"GitHub Actions se utiliza para automatizar una amplia variedad de flujos de trabajo, como: Pruebas Continuas (CI) : Ejecutar pruebas automatizadas en cada confirmaci\u00f3n de c\u00f3digo para garantizar que el c\u00f3digo funcione correctamente. Entrega Continua (CD) : Automatizar la implementaci\u00f3n de c\u00f3digo en entornos de producci\u00f3n despu\u00e9s de que las pruebas hayan pasado con \u00e9xito. Publicaci\u00f3n de Paquetes : Publicar autom\u00e1ticamente bibliotecas y paquetes en repositorios de paquetes como PyPI o npm. Notificaciones y Comentarios : Enviar notificaciones o comentarios autom\u00e1ticos en respuestas a eventos espec\u00edficos. Generaci\u00f3n de Documentaci\u00f3n : Generar y alojar autom\u00e1ticamente documentaci\u00f3n actualizada en GitHub Pages. An\u00e1lisis de C\u00f3digo : Realizar an\u00e1lisis de c\u00f3digo est\u00e1tico y generar informes autom\u00e1ticamente. Automatizaci\u00f3n de Tareas : Automatizar tareas de mantenimiento, como limpieza de cach\u00e9, copias de seguridad y m\u00e1s.","title":"Usos Comunes de GitHub Actions"},{"location":"git/github/#ejemplo-avanzado-de-github-actions","text":"Veamos un ejemplo m\u00e1s avanzado de GitHub Actions que incluye pruebas, implementaci\u00f3n y notificaciones: name : CI/CD Pipeline on : push : branches : - main jobs : build : runs-on : ubuntu-latest steps : - name : Checkout Repository uses : actions/checkout@v2 - name : Set Up Python uses : actions/setup-python@v2 with : python-version : 3.8 - name : Install Dependencies run : pip install -r requirements.txt - name : Run Tests run : pytest deploy : needs : build runs-on : ubuntu-latest steps : - name : Deploy to Production run : | if [ ${{ success() }} = \"true\" ]; then ssh user@production-server \"cd /var/www/myapp && git pull origin main && systemctl restart myapp\" fi env : SSH_PRIVATE_KEY : ${{ secrets.SSH_PRIVATE_KEY }} notify : needs : deploy runs-on : ubuntu-latest steps : - name : Send Notification uses : appleboy/telegram-action@v0.1.2 with : to : ${{ secrets.TELEGRAM_TO }} token : ${{ secrets.TELEGRAM_TOKEN }} message : \"Deployment successful!\" Este ejemplo incluye tres trabajos en el flujo de trabajo: build : Realiza las pruebas de c\u00f3digo y asegura que todo est\u00e9 funcionando correctamente. deploy : Implementa el c\u00f3digo en un servidor de producci\u00f3n si las pruebas han pasado con \u00e9xito. Utiliza una clave SSH almacenada en secretos para la autenticaci\u00f3n. notify : Env\u00eda una notificaci\u00f3n de Telegram para informar sobre el \u00e9xito de la implementaci\u00f3n.","title":"Ejemplo Avanzado de GitHub Actions"},{"location":"git/github/#9-conclusiones","text":"GitHub ofrece una amplia gama de caracter\u00edsticas y herramientas poderosas para la gesti\u00f3n de problemas, la publicaci\u00f3n de sitios web y la automatizaci\u00f3n de flujos de trabajo. La gesti\u00f3n de problemas es esencial para la colaboraci\u00f3n efectiva en proyectos, GitHub Pages facilita la creaci\u00f3n y el alojamiento de sitios web, y GitHub Actions permite la automatizaci\u00f3n de tareas y flujos de trabajo. A medida que explores m\u00e1s a fondo estas herramientas y las integres en tu flujo de trabajo de desarrollo, podr\u00e1s mejorar la eficiencia de tu equipo y la calidad de tus proyectos. Sigue explorando la documentaci\u00f3n de GitHub y experimenta con ejemplos para dominar estas capacidades y aprovechar al m\u00e1ximo la plataforma.","title":"9. Conclusiones"},{"location":"programming/classes/","text":"Programaci\u00f3n Orientada a Objetos La programaci\u00f3n orientada a objetos (POO) en Python es un enfoque de programaci\u00f3n que se basa en la creaci\u00f3n y manipulaci\u00f3n de objetos. Para comprender la POO en Python, es fundamental conocer los conceptos b\u00e1sicos relacionados con las clases, los objetos, los constructores y los m\u00e9todos. En este art\u00edculo, exploraremos en detalle estos conceptos fundamentales con ejemplos pr\u00e1cticos. Clases y Objetos en Python Clases Una clase es una plantilla o un plano para crear objetos. Define las propiedades (atributos) y los comportamientos (m\u00e9todos) que los objetos creados a partir de ella tendr\u00e1n. En Python, se define una clase utilizando la palabra clave class . class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad def saludar ( self ): return f \"Hola, soy { self . nombre } y tengo { self . edad } a\u00f1os.\" En este ejemplo, hemos definido una clase Persona con un constructor __init__ y un m\u00e9todo saludar . Objetos Un objeto es una instancia espec\u00edfica de una clase. Se crea un objeto llamando al constructor de la clase. Los objetos tienen sus propios valores para los atributos y pueden llamar a los m\u00e9todos de la clase. juan = Persona ( \"Juan\" , 30 ) maria = Persona ( \"Maria\" , 25 ) print ( juan . saludar ()) # Output: Hola, soy Juan y tengo 30 a\u00f1os. print ( maria . saludar ()) # Output: Hola, soy Maria y tengo 25 a\u00f1os. En este ejemplo, juan y maria son objetos de la clase Persona , cada uno con sus propios valores para nombre y edad . Constructores en Python Constructor __init__ El constructor es un m\u00e9todo especial en Python que se llama autom\u00e1ticamente cuando se crea un objeto de una clase. En la mayor\u00eda de los casos, se llama __init__ . Recibe self como primer par\u00e1metro, que se refiere al objeto en s\u00ed. El constructor se utiliza para inicializar los atributos de un objeto. class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad En este ejemplo, el constructor __init__ toma dos par\u00e1metros ( nombre y edad ) y los utiliza para inicializar los atributos self.nombre y self.edad . Otros Constructores Aunque __init__ es el constructor m\u00e1s com\u00fan, Python permite definir otros constructores utilizando el m\u00e9todo especial __new__ . Sin embargo, esto es menos com\u00fan y no se utiliza con frecuencia en la programaci\u00f3n cotidiana. Atributos de Clase y de Instancias Atributos de Clase Los atributos de clase son compartidos entre todas las instancias de una clase. Se definen directamente en la clase y no en un m\u00e9todo del objeto. Un ejemplo de un atributo de clase podr\u00eda ser un contador que rastrea el n\u00famero de instancias creadas de una clase. Aqu\u00ed hay un ejemplo: class Coche : contador = 0 # Atributo de clase def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo Coche . contador += 1 # Incrementar el contador en cada creaci\u00f3n de objeto def obtener_informacion ( self ): return f \" { self . marca } { self . modelo } \" # Uso de la clase Coche coche1 = Coche ( \"Toyota\" , \"Camry\" ) coche2 = Coche ( \"Honda\" , \"Accord\" ) print ( f \"Total de coches creados: { Coche . contador } \" ) contador es un atributo de clase que se incrementa cada vez que se crea un objeto de la clase Coche . Atributos de Instancia Los atributos de instancia son espec\u00edficos de cada objeto y se definen en el constructor de la clase. Cada objeto tiene su propio conjunto de valores para estos atributos. En el ejemplo anterior, marca y modelo son atributos de instancia. class Coche : def __init__ ( self , marca , modelo ): self . marca = marca # Atributo de instancia self . modelo = modelo # Atributo de instancia M\u00e9todos en Python M\u00e9todos de Instancia Los m\u00e9todos de instancia son funciones definidas dentro de una clase que operan en los atributos de un objeto espec\u00edfico. Los m\u00e9todos de instancia toman self como su primer par\u00e1metro, que se refiere al objeto en s\u00ed. class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad def saludar ( self ): return f \"Hola, soy { self . nombre } y tengo { self . edad } a\u00f1os.\" En este ejemplo, saludar() es un m\u00e9todo de instancia que opera en los atributos nombre y edad del objeto. M\u00e9todos Est\u00e1ticos Los m\u00e9todos est\u00e1ticos son funciones definidas en una clase que no toman self como par\u00e1metro y no operan en atributos de objeto espec\u00edficos. Se utilizan para funcionalidades relacionadas con la clase en su conjunto. class Calculadora : @staticmethod def sumar ( a , b ): return a + b En este ejemplo, sumar() es un m\u00e9todo est\u00e1tico de la clase Calculadora que no requiere la creaci\u00f3n de un objeto para ser utilizado. M\u00e9todos de Clase Los m\u00e9todos de clase son funciones definidas en una clase que operan en atributos de clase en lugar de atributos de objeto espec\u00edficos. Se utilizan con el decorador @classmethod y toman cls como su primer par\u00e1metro, que se refiere a la clase en s\u00ed. class Coche : total_coches = 0 def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo Coche . total_coches += 1 @classmethod def total ( cls ): return cls . total_coches En este ejemplo, total() es un m\u00e9todo de clase que accede al atributo de clase total_coches . Principios Fundamentales 1. Encapsulaci\u00f3n La encapsulaci\u00f3n es el principio de POO que se refiere a la ocultaci\u00f3n de los detalles internos de un objeto y la exposici\u00f3n de una interfaz p\u00fablica para interactuar con \u00e9l. En Python, la encapsulaci\u00f3n se implementa utilizando modificadores de acceso como _ , __ , y @property . Ejemplo de Encapsulaci\u00f3n class Persona : def __init__ ( self , nombre , edad ): self . _nombre = nombre # Atributo protegido self . __edad = edad # Atributo privado def get_nombre ( self ): return self . _nombre def set_nombre ( self , nuevo_nombre ): self . _nombre = nuevo_nombre @property def edad ( self ): return self . __edad @edad . setter def edad ( self , nueva_edad ): if nueva_edad > 0 : self . __edad = nueva_edad # Crear una instancia de Persona persona = Persona ( \"Alice\" , 30 ) # Acceder a atributos protegidos y privados print ( persona . get_nombre ()) # Salida: Alice print ( persona . edad ) # Salida: 30 # Modificar atributos protegidos y privados persona . set_nombre ( \"Bob\" ) persona . edad = 25 # No se recomienda acceder a atributos privados desde fuera de la clase, pero es posible print ( persona . _nombre ) # Salida: Bob print ( persona . _Persona__edad ) # Salida: 25 2. Abstracci\u00f3n La abstracci\u00f3n es el proceso de simplificar la realidad enfoc\u00e1ndonos en los detalles esenciales y ocultando los detalles no esenciales. En POO, las clases y objetos son abstracciones del mundo real. Ejemplo de Abstracci\u00f3n class Vehiculo : def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo def conducir ( self ): pass class Coche ( Vehiculo ): def conducir ( self ): return f \"Conduciendo { self . marca } { self . modelo } a 100 km/h\" class Motocicleta ( Vehiculo ): def conducir ( self ): return f \"Conduciendo { self . marca } { self . modelo } a 80 km/h\" # Crear instancias de Coche y Motocicleta mi_coche = Coche ( \"Toyota\" , \"Corolla\" ) mi_moto = Motocicleta ( \"Honda\" , \"CBR\" ) # Utilizar el m\u00e9todo conducir print ( mi_coche . conducir ()) # Salida: Conduciendo Toyota Corolla a 100 km/h print ( mi_moto . conducir ()) # Salida: Conduciendo Honda CBR a 80 km/h 3. Herencia La herencia es un principio que permite que una clase herede atributos y m\u00e9todos de otra clase, lo que promueve la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas de clases. Ejemplo de Herencia class Animal : def __init__ ( self , nombre ): self . nombre = nombre def hacer_sonido ( self ): pass class Perro ( Animal ): def hacer_sonido ( self ): return \"Guau\" class Gato ( Animal ): def hacer_sonido ( self ): return \"Miau\" # Crear instancias de Perro y Gato mi_perro = Perro ( \"Fido\" ) mi_gato = Gato ( \"Garfield\" ) # Llamar al m\u00e9todo hacer_sonido print ( mi_perro . hacer_sonido ()) # Salida: Guau print ( mi_gato . hacer_sonido ()) # Salida: Miau 4. Polimorfismo El polimorfismo permite que objetos de diferentes clases respondan de manera diferente a los mismos m\u00e9todos, lo que facilita la flexibilidad en el dise\u00f1o de programas. Ejemplo de Polimorfismo def hacer_sonar_animal ( animal ): return animal . hacer_sonido () # Crear instancias de Perro y Gato mi_perro = Perro ( \"Fido\" ) mi_gato = Gato ( \"Garfield\" ) # Utilizar la funci\u00f3n hacer_sonar_animal con diferentes objetos print ( hacer_sonar_animal ( mi_perro )) # Salida: Guau print ( hacer_sonar_animal ( mi_gato )) # Salida: Miau","title":"Programaci\u00f3n Orientada a Objetos"},{"location":"programming/classes/#programacion-orientada-a-objetos","text":"La programaci\u00f3n orientada a objetos (POO) en Python es un enfoque de programaci\u00f3n que se basa en la creaci\u00f3n y manipulaci\u00f3n de objetos. Para comprender la POO en Python, es fundamental conocer los conceptos b\u00e1sicos relacionados con las clases, los objetos, los constructores y los m\u00e9todos. En este art\u00edculo, exploraremos en detalle estos conceptos fundamentales con ejemplos pr\u00e1cticos.","title":"Programaci\u00f3n Orientada a Objetos"},{"location":"programming/classes/#clases-y-objetos-en-python","text":"","title":"Clases y Objetos en Python"},{"location":"programming/classes/#clases","text":"Una clase es una plantilla o un plano para crear objetos. Define las propiedades (atributos) y los comportamientos (m\u00e9todos) que los objetos creados a partir de ella tendr\u00e1n. En Python, se define una clase utilizando la palabra clave class . class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad def saludar ( self ): return f \"Hola, soy { self . nombre } y tengo { self . edad } a\u00f1os.\" En este ejemplo, hemos definido una clase Persona con un constructor __init__ y un m\u00e9todo saludar .","title":"Clases"},{"location":"programming/classes/#objetos","text":"Un objeto es una instancia espec\u00edfica de una clase. Se crea un objeto llamando al constructor de la clase. Los objetos tienen sus propios valores para los atributos y pueden llamar a los m\u00e9todos de la clase. juan = Persona ( \"Juan\" , 30 ) maria = Persona ( \"Maria\" , 25 ) print ( juan . saludar ()) # Output: Hola, soy Juan y tengo 30 a\u00f1os. print ( maria . saludar ()) # Output: Hola, soy Maria y tengo 25 a\u00f1os. En este ejemplo, juan y maria son objetos de la clase Persona , cada uno con sus propios valores para nombre y edad .","title":"Objetos"},{"location":"programming/classes/#constructores-en-python","text":"","title":"Constructores en Python"},{"location":"programming/classes/#constructor-__init__","text":"El constructor es un m\u00e9todo especial en Python que se llama autom\u00e1ticamente cuando se crea un objeto de una clase. En la mayor\u00eda de los casos, se llama __init__ . Recibe self como primer par\u00e1metro, que se refiere al objeto en s\u00ed. El constructor se utiliza para inicializar los atributos de un objeto. class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad En este ejemplo, el constructor __init__ toma dos par\u00e1metros ( nombre y edad ) y los utiliza para inicializar los atributos self.nombre y self.edad .","title":"Constructor __init__"},{"location":"programming/classes/#otros-constructores","text":"Aunque __init__ es el constructor m\u00e1s com\u00fan, Python permite definir otros constructores utilizando el m\u00e9todo especial __new__ . Sin embargo, esto es menos com\u00fan y no se utiliza con frecuencia en la programaci\u00f3n cotidiana.","title":"Otros Constructores"},{"location":"programming/classes/#atributos-de-clase-y-de-instancias","text":"","title":"Atributos de Clase y de Instancias"},{"location":"programming/classes/#atributos-de-clase","text":"Los atributos de clase son compartidos entre todas las instancias de una clase. Se definen directamente en la clase y no en un m\u00e9todo del objeto. Un ejemplo de un atributo de clase podr\u00eda ser un contador que rastrea el n\u00famero de instancias creadas de una clase. Aqu\u00ed hay un ejemplo: class Coche : contador = 0 # Atributo de clase def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo Coche . contador += 1 # Incrementar el contador en cada creaci\u00f3n de objeto def obtener_informacion ( self ): return f \" { self . marca } { self . modelo } \" # Uso de la clase Coche coche1 = Coche ( \"Toyota\" , \"Camry\" ) coche2 = Coche ( \"Honda\" , \"Accord\" ) print ( f \"Total de coches creados: { Coche . contador } \" ) contador es un atributo de clase que se incrementa cada vez que se crea un objeto de la clase Coche .","title":"Atributos de Clase"},{"location":"programming/classes/#atributos-de-instancia","text":"Los atributos de instancia son espec\u00edficos de cada objeto y se definen en el constructor de la clase. Cada objeto tiene su propio conjunto de valores para estos atributos. En el ejemplo anterior, marca y modelo son atributos de instancia. class Coche : def __init__ ( self , marca , modelo ): self . marca = marca # Atributo de instancia self . modelo = modelo # Atributo de instancia","title":"Atributos de Instancia"},{"location":"programming/classes/#metodos-en-python","text":"","title":"M\u00e9todos en Python"},{"location":"programming/classes/#metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones definidas dentro de una clase que operan en los atributos de un objeto espec\u00edfico. Los m\u00e9todos de instancia toman self como su primer par\u00e1metro, que se refiere al objeto en s\u00ed. class Persona : def __init__ ( self , nombre , edad ): self . nombre = nombre self . edad = edad def saludar ( self ): return f \"Hola, soy { self . nombre } y tengo { self . edad } a\u00f1os.\" En este ejemplo, saludar() es un m\u00e9todo de instancia que opera en los atributos nombre y edad del objeto.","title":"M\u00e9todos de Instancia"},{"location":"programming/classes/#metodos-estaticos","text":"Los m\u00e9todos est\u00e1ticos son funciones definidas en una clase que no toman self como par\u00e1metro y no operan en atributos de objeto espec\u00edficos. Se utilizan para funcionalidades relacionadas con la clase en su conjunto. class Calculadora : @staticmethod def sumar ( a , b ): return a + b En este ejemplo, sumar() es un m\u00e9todo est\u00e1tico de la clase Calculadora que no requiere la creaci\u00f3n de un objeto para ser utilizado.","title":"M\u00e9todos Est\u00e1ticos"},{"location":"programming/classes/#metodos-de-clase","text":"Los m\u00e9todos de clase son funciones definidas en una clase que operan en atributos de clase en lugar de atributos de objeto espec\u00edficos. Se utilizan con el decorador @classmethod y toman cls como su primer par\u00e1metro, que se refiere a la clase en s\u00ed. class Coche : total_coches = 0 def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo Coche . total_coches += 1 @classmethod def total ( cls ): return cls . total_coches En este ejemplo, total() es un m\u00e9todo de clase que accede al atributo de clase total_coches .","title":"M\u00e9todos de Clase"},{"location":"programming/classes/#principios-fundamentales","text":"","title":"Principios Fundamentales"},{"location":"programming/classes/#1-encapsulacion","text":"La encapsulaci\u00f3n es el principio de POO que se refiere a la ocultaci\u00f3n de los detalles internos de un objeto y la exposici\u00f3n de una interfaz p\u00fablica para interactuar con \u00e9l. En Python, la encapsulaci\u00f3n se implementa utilizando modificadores de acceso como _ , __ , y @property . Ejemplo de Encapsulaci\u00f3n class Persona : def __init__ ( self , nombre , edad ): self . _nombre = nombre # Atributo protegido self . __edad = edad # Atributo privado def get_nombre ( self ): return self . _nombre def set_nombre ( self , nuevo_nombre ): self . _nombre = nuevo_nombre @property def edad ( self ): return self . __edad @edad . setter def edad ( self , nueva_edad ): if nueva_edad > 0 : self . __edad = nueva_edad # Crear una instancia de Persona persona = Persona ( \"Alice\" , 30 ) # Acceder a atributos protegidos y privados print ( persona . get_nombre ()) # Salida: Alice print ( persona . edad ) # Salida: 30 # Modificar atributos protegidos y privados persona . set_nombre ( \"Bob\" ) persona . edad = 25 # No se recomienda acceder a atributos privados desde fuera de la clase, pero es posible print ( persona . _nombre ) # Salida: Bob print ( persona . _Persona__edad ) # Salida: 25","title":"1. Encapsulaci\u00f3n"},{"location":"programming/classes/#2-abstraccion","text":"La abstracci\u00f3n es el proceso de simplificar la realidad enfoc\u00e1ndonos en los detalles esenciales y ocultando los detalles no esenciales. En POO, las clases y objetos son abstracciones del mundo real. Ejemplo de Abstracci\u00f3n class Vehiculo : def __init__ ( self , marca , modelo ): self . marca = marca self . modelo = modelo def conducir ( self ): pass class Coche ( Vehiculo ): def conducir ( self ): return f \"Conduciendo { self . marca } { self . modelo } a 100 km/h\" class Motocicleta ( Vehiculo ): def conducir ( self ): return f \"Conduciendo { self . marca } { self . modelo } a 80 km/h\" # Crear instancias de Coche y Motocicleta mi_coche = Coche ( \"Toyota\" , \"Corolla\" ) mi_moto = Motocicleta ( \"Honda\" , \"CBR\" ) # Utilizar el m\u00e9todo conducir print ( mi_coche . conducir ()) # Salida: Conduciendo Toyota Corolla a 100 km/h print ( mi_moto . conducir ()) # Salida: Conduciendo Honda CBR a 80 km/h","title":"2. Abstracci\u00f3n"},{"location":"programming/classes/#3-herencia","text":"La herencia es un principio que permite que una clase herede atributos y m\u00e9todos de otra clase, lo que promueve la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas de clases. Ejemplo de Herencia class Animal : def __init__ ( self , nombre ): self . nombre = nombre def hacer_sonido ( self ): pass class Perro ( Animal ): def hacer_sonido ( self ): return \"Guau\" class Gato ( Animal ): def hacer_sonido ( self ): return \"Miau\" # Crear instancias de Perro y Gato mi_perro = Perro ( \"Fido\" ) mi_gato = Gato ( \"Garfield\" ) # Llamar al m\u00e9todo hacer_sonido print ( mi_perro . hacer_sonido ()) # Salida: Guau print ( mi_gato . hacer_sonido ()) # Salida: Miau","title":"3. Herencia"},{"location":"programming/classes/#4-polimorfismo","text":"El polimorfismo permite que objetos de diferentes clases respondan de manera diferente a los mismos m\u00e9todos, lo que facilita la flexibilidad en el dise\u00f1o de programas. Ejemplo de Polimorfismo def hacer_sonar_animal ( animal ): return animal . hacer_sonido () # Crear instancias de Perro y Gato mi_perro = Perro ( \"Fido\" ) mi_gato = Gato ( \"Garfield\" ) # Utilizar la funci\u00f3n hacer_sonar_animal con diferentes objetos print ( hacer_sonar_animal ( mi_perro )) # Salida: Guau print ( hacer_sonar_animal ( mi_gato )) # Salida: Miau","title":"4. Polimorfismo"},{"location":"programming/design_pattern/","text":"Patrones de Dise\u00f1o Los patrones de dise\u00f1o son soluciones generales y reutilizables a problemas comunes que surgen al dise\u00f1ar software. Estas soluciones encapsulan las mejores pr\u00e1cticas y se ha n probado a lo largo del tiempo en el campo del desarrollo de software. En Python, como en otros lenguajes de programaci\u00f3n, los patrones de dise\u00f1o desempe\u00f1an un papel crucial en la creaci\u00f3n de c\u00f3digo limpio, mantenible y escalable. Or\u00edgenes de los Patrones de Dise\u00f1o Los Patrones de Dise\u00f1o se originaron en la comunidad de ingenier\u00eda de software en la d\u00e9cada de 1970 y 1980. El concepto fue popularizado por el libro \"Design Patterns: Elements of Reusable Object-Oriented Software\" publicado en 1994, escrito por Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (a menudo llamados \"Gang of Four\" o GoF). Este libro se convirti\u00f3 en un recurso fundamental para los desarrolladores de software y defini\u00f3 23 patrones de dise\u00f1o comunes que se aplican en el dise\u00f1o de software orientado a objetos. Prop\u00f3sito de los Patrones de Dise\u00f1o El prop\u00f3sito principal de los Patrones de Dise\u00f1o es proporcionar soluciones a problemas comunes y recurrentes en el dise\u00f1o de software. Estos problemas suelen estar relacionados con la creaci\u00f3n de objetos, la estructura de las clases y la interacci\u00f3n entre objetos. Los patrones de dise\u00f1o ofrecen una gu\u00eda probada y efectiva para abordar estos problemas, lo que lleva a un dise\u00f1o m\u00e1s limpio, mantenible y escalable. Algunos de los prop\u00f3sitos clave de los Patrones de Dise\u00f1o son: Reutilizaci\u00f3n de C\u00f3digo: Los patrones de dise\u00f1o promueven la reutilizaci\u00f3n de soluciones probadas. En lugar de reinventar la rueda cada vez que se enfrenta a un problema similar, los desarrolladores pueden aplicar un patr\u00f3n existente. Abstracci\u00f3n y Encapsulaci\u00f3n: Los patrones de dise\u00f1o fomentan la abstracci\u00f3n y la encapsulaci\u00f3n, dos principios fundamentales de la programaci\u00f3n orientada a objetos. Esto conduce a una separaci\u00f3n clara de responsabilidades y facilita la modificaci\u00f3n de partes del sistema sin afectar a otras partes. Flexibilidad y Extensibilidad: Los patrones de dise\u00f1o permiten que los sistemas sean m\u00e1s flexibles y extensibles. Puedes cambiar f\u00e1cilmente el comportamiento de una parte del sistema al reemplazar un objeto por otro que implementa el mismo patr\u00f3n. Comunicaci\u00f3n Universal: Los patrones de dise\u00f1o proporcionan un lenguaje com\u00fan y una forma de comunicaci\u00f3n entre los miembros del equipo de desarrollo. Esto facilita la comprensi\u00f3n y colaboraci\u00f3n en proyectos de software. Mantenibilidad: Los patrones de dise\u00f1o tienden a crear c\u00f3digo m\u00e1s limpio y organizado. Esto simplifica la tarea de mantenimiento y mejora la durabilidad del software a lo largo del tiempo. \u00bfPor qu\u00e9 Deber\u00edan Utilizarse los Patrones de Dise\u00f1o? Los Patrones de Dise\u00f1o deber\u00edan utilizarse por varias razones importantes: Experiencia Compartida: Los patrones de dise\u00f1o encapsulan la experiencia colectiva de la comunidad de desarrollo de software. Beneficiarte de esta experiencia te permite evitar errores comunes y adoptar soluciones probadas. Mejores Pr\u00e1cticas: Los patrones de dise\u00f1o promueven las mejores pr\u00e1cticas de dise\u00f1o de software, como la abstracci\u00f3n, la encapsulaci\u00f3n y la modularidad. Siguiendo estos principios, es m\u00e1s probable que escribas un c\u00f3digo limpio y mantenible. Eficiencia en el Desarrollo: Los patrones de dise\u00f1o pueden acelerar el proceso de desarrollo al proporcionar soluciones predefinidas. Esto ahorra tiempo y esfuerzo, especialmente en proyectos grandes y complejos. Documentaci\u00f3n Impl\u00edcita: El uso de patrones de dise\u00f1o proporciona una documentaci\u00f3n impl\u00edcita del c\u00f3digo. Cuando otros desarrolladores revisan tu c\u00f3digo y reconocen patrones familiares, comprenden de inmediato c\u00f3mo funciona una parte del sistema. Flexibilidad y Adaptabilidad: Los patrones de dise\u00f1o hacen que los sistemas sean m\u00e1s flexibles y adaptables a los cambios. Puedes modificar una parte del sistema al reemplazar un componente con otro que siga el mismo patr\u00f3n, en lugar de realizar cambios extensos. Lenguaje Com\u00fan: Los patrones de dise\u00f1o proporcionan un lenguaje com\u00fan que facilita la comunicaci\u00f3n dentro de un equipo de desarrollo. Los miembros del equipo pueden discutir y comprender mejor las soluciones propuestas. Tipos de Patrones Patrones de Creaci\u00f3n Los Patrones de Creaci\u00f3n se centran en la creaci\u00f3n de objetos. Estos patrones abordan la manera en que los objetos se crean y aseguran que el proceso sea eficiente y flexible. 1. Patr\u00f3n Singleton El Patr\u00f3n Singleton garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia. Esto es \u00fatil cuando una \u00fanica instancia de una clase controla el acceso a un recurso compartido, como una conexi\u00f3n a una base de datos. Ejemplo en Python : class Singleton : _instance = None def __new__ ( cls ): if cls . _instance is None : cls . _instance = super ( Singleton , cls ) . __new__ ( cls ) return cls . _instance 2. Patr\u00f3n Factory Method El Patr\u00f3n Factory Method define una interfaz para crear un objeto, pero permite a las subclases alterar el tipo de objetos que se crear\u00e1n. Esto promueve la flexibilidad y la extensibilidad. Ejemplo en Python : from abc import ABC , abstractmethod class Creator ( ABC ): @abstractmethod def factory_method ( self ): pass class ConcreteCreatorA ( Creator ): def factory_method ( self ): return ConcreteProductA () class ConcreteCreatorB ( Creator ): def factory_method ( self ): return ConcreteProductB () Patrones Estructurales Los Patrones Estructurales se enfocan en c\u00f3mo se componen los objetos para formar estructuras m\u00e1s grandes. 3. Patr\u00f3n Adapter El Patr\u00f3n Adapter permite que las interfaces incompatibles trabajen juntas. Convierte la interfaz de una clase en otra interfaz que los clientes esperan. Ejemplo en Python : class OldSystem : def legacy_method ( self ): return \"Legacy method\" class NewSystem : def modern_method ( self ): return \"Modern method\" class Adapter ( NewSystem ): def legacy_method ( self ): return super () . modern_method () 4. Patr\u00f3n Composite El Patr\u00f3n Composite permite que los objetos se compongan en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Esto permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme. Ejemplo en Python : from abc import ABC , abstractmethod class Component ( ABC ): @abstractmethod def operation ( self ): pass class Leaf ( Component ): def operation ( self ): return \"Leaf\" class Composite ( Component ): def __init__ ( self ): self . children = [] def operation ( self ): results = [] for child in self . children : results . append ( child . operation ()) return f \"Composite [ { ', ' . join ( results ) } ]\" Patrones de Comportamiento Los Patrones de Comportamiento se enfocan en c\u00f3mo se comunican y colaboran los objetos. 5. Patr\u00f3n Observer El Patr\u00f3n Observer define una relaci\u00f3n uno-a-muchos entre objetos, de modo que cuando un objeto cambia su estado, todos los objetos dependientes son notificados y actualizados autom\u00e1ticamente. Ejemplo en Python : from abc import ABC , abstractmethod class Observer ( ABC ): @abstractmethod def update ( self , message ): pass class ConcreteObserver ( Observer ): def __init__ ( self , name ): self . name = name def update ( self , message ): print ( f \" { self . name } received message: { message } \" ) class Subject : def __init__ ( self ): self . observers = [] def add_observer ( self , observer ): self . observers . append ( observer ) def remove_observer ( self , observer ): self . observers . remove ( observer ) def notify_observers ( self , message ): for observer in self . observers : observer . update ( message ) 6. Patr\u00f3n Strategy El Patr\u00f3n Strategy define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Permite que el algoritmo var\u00ede independientemente de los clientes que lo utilizan. Ejemplo en Python : from abc import ABC , abstractmethod class Strategy ( ABC ): @abstractmethod def do_operation ( self ): pass class ConcreteStrategyA ( Strategy ): def do_operation ( self ): return \"Strategy A\" class ConcreteStrategyB ( Strategy ): def do_operation ( self ): return \"Strategy B\" class Context : def __init__ ( self , strategy ): self . strategy = strategy def execute_strategy ( self ): return self . strategy . do_operation () Estos son solo algunos ejemplos de patrones de dise\u00f1o en Python. Los patrones de creaci\u00f3n, estructurales y de comportamiento ofrecen soluciones probadas para desaf\u00edos comunes en el dise\u00f1o de software. Al comprender y aplicar estos patrones de manera efectiva, los desarrolladores pueden mejorar la calidad, la flexibilidad y la mantenibilidad de su c\u00f3digo. Si deseas explorar m\u00e1s patrones de dise\u00f1o o aprender c\u00f3mo aplicarlos en situaciones espec\u00edficas, hay muchas referencias y recursos disponibles para profundizar en este tema fundamental del desarrollo de software.","title":"Patrones de Dise\u00f1o"},{"location":"programming/design_pattern/#patrones-de-diseno","text":"Los patrones de dise\u00f1o son soluciones generales y reutilizables a problemas comunes que surgen al dise\u00f1ar software. Estas soluciones encapsulan las mejores pr\u00e1cticas y se ha n probado a lo largo del tiempo en el campo del desarrollo de software. En Python, como en otros lenguajes de programaci\u00f3n, los patrones de dise\u00f1o desempe\u00f1an un papel crucial en la creaci\u00f3n de c\u00f3digo limpio, mantenible y escalable. Or\u00edgenes de los Patrones de Dise\u00f1o Los Patrones de Dise\u00f1o se originaron en la comunidad de ingenier\u00eda de software en la d\u00e9cada de 1970 y 1980. El concepto fue popularizado por el libro \"Design Patterns: Elements of Reusable Object-Oriented Software\" publicado en 1994, escrito por Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (a menudo llamados \"Gang of Four\" o GoF). Este libro se convirti\u00f3 en un recurso fundamental para los desarrolladores de software y defini\u00f3 23 patrones de dise\u00f1o comunes que se aplican en el dise\u00f1o de software orientado a objetos. Prop\u00f3sito de los Patrones de Dise\u00f1o El prop\u00f3sito principal de los Patrones de Dise\u00f1o es proporcionar soluciones a problemas comunes y recurrentes en el dise\u00f1o de software. Estos problemas suelen estar relacionados con la creaci\u00f3n de objetos, la estructura de las clases y la interacci\u00f3n entre objetos. Los patrones de dise\u00f1o ofrecen una gu\u00eda probada y efectiva para abordar estos problemas, lo que lleva a un dise\u00f1o m\u00e1s limpio, mantenible y escalable. Algunos de los prop\u00f3sitos clave de los Patrones de Dise\u00f1o son: Reutilizaci\u00f3n de C\u00f3digo: Los patrones de dise\u00f1o promueven la reutilizaci\u00f3n de soluciones probadas. En lugar de reinventar la rueda cada vez que se enfrenta a un problema similar, los desarrolladores pueden aplicar un patr\u00f3n existente. Abstracci\u00f3n y Encapsulaci\u00f3n: Los patrones de dise\u00f1o fomentan la abstracci\u00f3n y la encapsulaci\u00f3n, dos principios fundamentales de la programaci\u00f3n orientada a objetos. Esto conduce a una separaci\u00f3n clara de responsabilidades y facilita la modificaci\u00f3n de partes del sistema sin afectar a otras partes. Flexibilidad y Extensibilidad: Los patrones de dise\u00f1o permiten que los sistemas sean m\u00e1s flexibles y extensibles. Puedes cambiar f\u00e1cilmente el comportamiento de una parte del sistema al reemplazar un objeto por otro que implementa el mismo patr\u00f3n. Comunicaci\u00f3n Universal: Los patrones de dise\u00f1o proporcionan un lenguaje com\u00fan y una forma de comunicaci\u00f3n entre los miembros del equipo de desarrollo. Esto facilita la comprensi\u00f3n y colaboraci\u00f3n en proyectos de software. Mantenibilidad: Los patrones de dise\u00f1o tienden a crear c\u00f3digo m\u00e1s limpio y organizado. Esto simplifica la tarea de mantenimiento y mejora la durabilidad del software a lo largo del tiempo. \u00bfPor qu\u00e9 Deber\u00edan Utilizarse los Patrones de Dise\u00f1o? Los Patrones de Dise\u00f1o deber\u00edan utilizarse por varias razones importantes: Experiencia Compartida: Los patrones de dise\u00f1o encapsulan la experiencia colectiva de la comunidad de desarrollo de software. Beneficiarte de esta experiencia te permite evitar errores comunes y adoptar soluciones probadas. Mejores Pr\u00e1cticas: Los patrones de dise\u00f1o promueven las mejores pr\u00e1cticas de dise\u00f1o de software, como la abstracci\u00f3n, la encapsulaci\u00f3n y la modularidad. Siguiendo estos principios, es m\u00e1s probable que escribas un c\u00f3digo limpio y mantenible. Eficiencia en el Desarrollo: Los patrones de dise\u00f1o pueden acelerar el proceso de desarrollo al proporcionar soluciones predefinidas. Esto ahorra tiempo y esfuerzo, especialmente en proyectos grandes y complejos. Documentaci\u00f3n Impl\u00edcita: El uso de patrones de dise\u00f1o proporciona una documentaci\u00f3n impl\u00edcita del c\u00f3digo. Cuando otros desarrolladores revisan tu c\u00f3digo y reconocen patrones familiares, comprenden de inmediato c\u00f3mo funciona una parte del sistema. Flexibilidad y Adaptabilidad: Los patrones de dise\u00f1o hacen que los sistemas sean m\u00e1s flexibles y adaptables a los cambios. Puedes modificar una parte del sistema al reemplazar un componente con otro que siga el mismo patr\u00f3n, en lugar de realizar cambios extensos. Lenguaje Com\u00fan: Los patrones de dise\u00f1o proporcionan un lenguaje com\u00fan que facilita la comunicaci\u00f3n dentro de un equipo de desarrollo. Los miembros del equipo pueden discutir y comprender mejor las soluciones propuestas.","title":"Patrones de Dise\u00f1o"},{"location":"programming/design_pattern/#tipos-de-patrones","text":"","title":"Tipos de Patrones"},{"location":"programming/design_pattern/#patrones-de-creacion","text":"Los Patrones de Creaci\u00f3n se centran en la creaci\u00f3n de objetos. Estos patrones abordan la manera en que los objetos se crean y aseguran que el proceso sea eficiente y flexible.","title":"Patrones de Creaci\u00f3n"},{"location":"programming/design_pattern/#1-patron-singleton","text":"El Patr\u00f3n Singleton garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia. Esto es \u00fatil cuando una \u00fanica instancia de una clase controla el acceso a un recurso compartido, como una conexi\u00f3n a una base de datos. Ejemplo en Python : class Singleton : _instance = None def __new__ ( cls ): if cls . _instance is None : cls . _instance = super ( Singleton , cls ) . __new__ ( cls ) return cls . _instance","title":"1. Patr\u00f3n Singleton"},{"location":"programming/design_pattern/#2-patron-factory-method","text":"El Patr\u00f3n Factory Method define una interfaz para crear un objeto, pero permite a las subclases alterar el tipo de objetos que se crear\u00e1n. Esto promueve la flexibilidad y la extensibilidad. Ejemplo en Python : from abc import ABC , abstractmethod class Creator ( ABC ): @abstractmethod def factory_method ( self ): pass class ConcreteCreatorA ( Creator ): def factory_method ( self ): return ConcreteProductA () class ConcreteCreatorB ( Creator ): def factory_method ( self ): return ConcreteProductB ()","title":"2. Patr\u00f3n Factory Method"},{"location":"programming/design_pattern/#patrones-estructurales","text":"Los Patrones Estructurales se enfocan en c\u00f3mo se componen los objetos para formar estructuras m\u00e1s grandes.","title":"Patrones Estructurales"},{"location":"programming/design_pattern/#3-patron-adapter","text":"El Patr\u00f3n Adapter permite que las interfaces incompatibles trabajen juntas. Convierte la interfaz de una clase en otra interfaz que los clientes esperan. Ejemplo en Python : class OldSystem : def legacy_method ( self ): return \"Legacy method\" class NewSystem : def modern_method ( self ): return \"Modern method\" class Adapter ( NewSystem ): def legacy_method ( self ): return super () . modern_method ()","title":"3. Patr\u00f3n Adapter"},{"location":"programming/design_pattern/#4-patron-composite","text":"El Patr\u00f3n Composite permite que los objetos se compongan en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Esto permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme. Ejemplo en Python : from abc import ABC , abstractmethod class Component ( ABC ): @abstractmethod def operation ( self ): pass class Leaf ( Component ): def operation ( self ): return \"Leaf\" class Composite ( Component ): def __init__ ( self ): self . children = [] def operation ( self ): results = [] for child in self . children : results . append ( child . operation ()) return f \"Composite [ { ', ' . join ( results ) } ]\"","title":"4. Patr\u00f3n Composite"},{"location":"programming/design_pattern/#patrones-de-comportamiento","text":"Los Patrones de Comportamiento se enfocan en c\u00f3mo se comunican y colaboran los objetos.","title":"Patrones de Comportamiento"},{"location":"programming/design_pattern/#5-patron-observer","text":"El Patr\u00f3n Observer define una relaci\u00f3n uno-a-muchos entre objetos, de modo que cuando un objeto cambia su estado, todos los objetos dependientes son notificados y actualizados autom\u00e1ticamente. Ejemplo en Python : from abc import ABC , abstractmethod class Observer ( ABC ): @abstractmethod def update ( self , message ): pass class ConcreteObserver ( Observer ): def __init__ ( self , name ): self . name = name def update ( self , message ): print ( f \" { self . name } received message: { message } \" ) class Subject : def __init__ ( self ): self . observers = [] def add_observer ( self , observer ): self . observers . append ( observer ) def remove_observer ( self , observer ): self . observers . remove ( observer ) def notify_observers ( self , message ): for observer in self . observers : observer . update ( message )","title":"5. Patr\u00f3n Observer"},{"location":"programming/design_pattern/#6-patron-strategy","text":"El Patr\u00f3n Strategy define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables. Permite que el algoritmo var\u00ede independientemente de los clientes que lo utilizan. Ejemplo en Python : from abc import ABC , abstractmethod class Strategy ( ABC ): @abstractmethod def do_operation ( self ): pass class ConcreteStrategyA ( Strategy ): def do_operation ( self ): return \"Strategy A\" class ConcreteStrategyB ( Strategy ): def do_operation ( self ): return \"Strategy B\" class Context : def __init__ ( self , strategy ): self . strategy = strategy def execute_strategy ( self ): return self . strategy . do_operation () Estos son solo algunos ejemplos de patrones de dise\u00f1o en Python. Los patrones de creaci\u00f3n, estructurales y de comportamiento ofrecen soluciones probadas para desaf\u00edos comunes en el dise\u00f1o de software. Al comprender y aplicar estos patrones de manera efectiva, los desarrolladores pueden mejorar la calidad, la flexibilidad y la mantenibilidad de su c\u00f3digo. Si deseas explorar m\u00e1s patrones de dise\u00f1o o aprender c\u00f3mo aplicarlos en situaciones espec\u00edficas, hay muchas referencias y recursos disponibles para profundizar en este tema fundamental del desarrollo de software.","title":"6. Patr\u00f3n Strategy"},{"location":"programming/function/","text":"Funciones en Python Las funciones son un elemento fundamental en Python y en la mayor\u00eda de los lenguajes de programaci\u00f3n. En este art\u00edculo, vamos a sumergirnos en el mundo de las funciones en Python, explorando desde conceptos b\u00e1sicos hasta t\u00e9cnicas avanzadas y buenas pr\u00e1cticas de programaci\u00f3n. \u00bfQu\u00e9 es una Funci\u00f3n? En programaci\u00f3n, una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica. Las funciones permiten dividir un programa en partes m\u00e1s peque\u00f1as y manejables, lo que facilita la lectura, la depuraci\u00f3n y la reutilizaci\u00f3n del c\u00f3digo. Sintaxis B\u00e1sica La sintaxis b\u00e1sica de una funci\u00f3n en Python es la siguiente: def nombre_de_la_funcion ( parametro1 , parametro2 , ... ): # C\u00f3digo de la funci\u00f3n return resultado nombre_de_la_funcion : Es el nombre que identifica a la funci\u00f3n. parametro1 , parametro2 , ...: Son los par\u00e1metros que la funci\u00f3n acepta (pueden ser opcionales). return resultado : Es una declaraci\u00f3n opcional que indica el valor que la funci\u00f3n devuelve. Definici\u00f3n de Funciones Vamos a empezar viendo ejemplos de funciones simples en Python: Funci\u00f3n que Saluda def saludar ( nombre ): return f \"Hola, { nombre } !\" mensaje = saludar ( \"Alice\" ) print ( mensaje ) # Salida: Hola, Alice! Funci\u00f3n que Calcula el Cuadrado def cuadrado ( numero ): return numero ** 2 resultado = cuadrado ( 5 ) print ( resultado ) # Salida: 25 Par\u00e1metros y Argumentos En el contexto de las funciones, los par\u00e1metros son valores que una funci\u00f3n acepta como entrada, mientras que los argumentos son los valores reales que se pasan a la funci\u00f3n cuando se llama. Par\u00e1metros Posicionales def suma ( a , b ): return a + b resultado = suma ( 3 , 4 ) print ( resultado ) # Salida: 7 Par\u00e1metros con Valores por Defecto Puedes asignar valores por defecto a los par\u00e1metros de una funci\u00f3n, lo que permite que la funci\u00f3n sea m\u00e1s flexible al llamarla. def saludar ( nombre = \"Invitado\" ): return f \"Hola, { nombre } !\" mensaje = saludar () print ( mensaje ) # Salida: Hola, Invitado Par\u00e1metros de Palabras Clave Los par\u00e1metros de palabras clave te permiten pasar argumentos a una funci\u00f3n especificando el nombre del par\u00e1metro al que se asigna el valor, lo que hace que el orden no importe. def resta ( a , b ): return a - b resultado = resta ( b = 3 , a = 7 ) print ( resultado ) # Salida: 4 Funciones con M\u00faltiples Retornos Python permite que una funci\u00f3n devuelva m\u00faltiples valores como una tupla. def suma_y_resta ( a , b ): suma = a + b resta = a - b return suma , resta resultado = suma_y_resta ( 7 , 3 ) print ( resultado ) # Salida: (10, 4) Puedes desempaquetar los valores de retorno en variables individuales: suma , resta = suma_y_resta ( 7 , 3 ) print ( suma ) # Salida: 10 print ( resta ) # Salida: 4 Funciones como Objetos En Python, las funciones son objetos de primera clase, lo que significa que se pueden asignar a variables, pasar como argumentos y devolver desde otras funciones. Funciones como Argumentos Puedes pasar una funci\u00f3n como argumento a otra funci\u00f3n, lo que es \u00fatil para crear funciones de orden superior. def aplicar ( funcion , valor ): return funcion ( valor ) def cuadrado ( numero ): return numero ** 2 resultado = aplicar ( cuadrado , 5 ) print ( resultado ) # Salida: 25 Funciones An\u00f3nimas (Lambda) Las funciones lambda, tambi\u00e9n conocidas como funciones an\u00f3nimas, son funciones peque\u00f1as y sin nombre que se pueden definir de manera concisa en una l\u00ednea de c\u00f3digo. cuadrado = lambda x : x ** 2 resultado = cuadrado ( 5 ) print ( resultado ) # Salida: 25 Alcance de Variables (Scope) Python utiliza un alcance l\u00e9xico, lo que significa que una variable se busca primero dentro de la funci\u00f3n actual y, si no se encuentra, se busca en los alcances exteriores. Variables Locales y Globales x = 10 # Variable global def funcion (): x = 5 # Variable local dentro de la funci\u00f3n print ( x ) funcion () # Salida: 5 print ( x ) # Salida: 10 (la variable global no se modifica) Uso de la Palabra Clave global Puedes declarar una variable global dentro de una funci\u00f3n utilizando la palabra clave global . x = 10 def modificar_global (): global x x = 5 modificar_global () print ( x ) # Salida: 5 Documentaci\u00f3n de Funciones Es una buena pr\u00e1ctica documentar tus funciones para que otros desarrolladores (y t\u00fa mismo en el futuro) puedan entender su prop\u00f3sito y uso. def suma ( a , b ): \"\"\" Esta funci\u00f3n devuelve la suma de dos n\u00fameros. Args: a (int): El primer n\u00famero. b (int): El segundo n\u00famero. Returns: int: La suma de a y b. \"\"\" return a + b Conclusi\u00f3n Las funciones son una parte esencial de Python y de la programaci\u00f3n en general. Al comprender y dominar los conceptos y las t\u00e9cnicas relacionadas con las funciones, puedes escribir c\u00f3digo m\u00e1s modular, limpio y mantenible. Estos son los fundamentos, pero hay mucho m\u00e1s que explorar en el mundo de las funciones en Python.","title":"Funciones en Python"},{"location":"programming/function/#funciones-en-python","text":"Las funciones son un elemento fundamental en Python y en la mayor\u00eda de los lenguajes de programaci\u00f3n. En este art\u00edculo, vamos a sumergirnos en el mundo de las funciones en Python, explorando desde conceptos b\u00e1sicos hasta t\u00e9cnicas avanzadas y buenas pr\u00e1cticas de programaci\u00f3n.","title":"Funciones en Python"},{"location":"programming/function/#que-es-una-funcion","text":"En programaci\u00f3n, una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica. Las funciones permiten dividir un programa en partes m\u00e1s peque\u00f1as y manejables, lo que facilita la lectura, la depuraci\u00f3n y la reutilizaci\u00f3n del c\u00f3digo.","title":"\u00bfQu\u00e9 es una Funci\u00f3n?"},{"location":"programming/function/#sintaxis-basica","text":"La sintaxis b\u00e1sica de una funci\u00f3n en Python es la siguiente: def nombre_de_la_funcion ( parametro1 , parametro2 , ... ): # C\u00f3digo de la funci\u00f3n return resultado nombre_de_la_funcion : Es el nombre que identifica a la funci\u00f3n. parametro1 , parametro2 , ...: Son los par\u00e1metros que la funci\u00f3n acepta (pueden ser opcionales). return resultado : Es una declaraci\u00f3n opcional que indica el valor que la funci\u00f3n devuelve.","title":"Sintaxis B\u00e1sica"},{"location":"programming/function/#definicion-de-funciones","text":"Vamos a empezar viendo ejemplos de funciones simples en Python:","title":"Definici\u00f3n de Funciones"},{"location":"programming/function/#funcion-que-saluda","text":"def saludar ( nombre ): return f \"Hola, { nombre } !\" mensaje = saludar ( \"Alice\" ) print ( mensaje ) # Salida: Hola, Alice!","title":"Funci\u00f3n que Saluda"},{"location":"programming/function/#funcion-que-calcula-el-cuadrado","text":"def cuadrado ( numero ): return numero ** 2 resultado = cuadrado ( 5 ) print ( resultado ) # Salida: 25","title":"Funci\u00f3n que Calcula el Cuadrado"},{"location":"programming/function/#parametros-y-argumentos","text":"En el contexto de las funciones, los par\u00e1metros son valores que una funci\u00f3n acepta como entrada, mientras que los argumentos son los valores reales que se pasan a la funci\u00f3n cuando se llama.","title":"Par\u00e1metros y Argumentos"},{"location":"programming/function/#parametros-posicionales","text":"def suma ( a , b ): return a + b resultado = suma ( 3 , 4 ) print ( resultado ) # Salida: 7","title":"Par\u00e1metros Posicionales"},{"location":"programming/function/#parametros-con-valores-por-defecto","text":"Puedes asignar valores por defecto a los par\u00e1metros de una funci\u00f3n, lo que permite que la funci\u00f3n sea m\u00e1s flexible al llamarla. def saludar ( nombre = \"Invitado\" ): return f \"Hola, { nombre } !\" mensaje = saludar () print ( mensaje ) # Salida: Hola, Invitado","title":"Par\u00e1metros con Valores por Defecto"},{"location":"programming/function/#parametros-de-palabras-clave","text":"Los par\u00e1metros de palabras clave te permiten pasar argumentos a una funci\u00f3n especificando el nombre del par\u00e1metro al que se asigna el valor, lo que hace que el orden no importe. def resta ( a , b ): return a - b resultado = resta ( b = 3 , a = 7 ) print ( resultado ) # Salida: 4","title":"Par\u00e1metros de Palabras Clave"},{"location":"programming/function/#funciones-con-multiples-retornos","text":"Python permite que una funci\u00f3n devuelva m\u00faltiples valores como una tupla. def suma_y_resta ( a , b ): suma = a + b resta = a - b return suma , resta resultado = suma_y_resta ( 7 , 3 ) print ( resultado ) # Salida: (10, 4) Puedes desempaquetar los valores de retorno en variables individuales: suma , resta = suma_y_resta ( 7 , 3 ) print ( suma ) # Salida: 10 print ( resta ) # Salida: 4","title":"Funciones con M\u00faltiples Retornos"},{"location":"programming/function/#funciones-como-objetos","text":"En Python, las funciones son objetos de primera clase, lo que significa que se pueden asignar a variables, pasar como argumentos y devolver desde otras funciones.","title":"Funciones como Objetos"},{"location":"programming/function/#funciones-como-argumentos","text":"Puedes pasar una funci\u00f3n como argumento a otra funci\u00f3n, lo que es \u00fatil para crear funciones de orden superior. def aplicar ( funcion , valor ): return funcion ( valor ) def cuadrado ( numero ): return numero ** 2 resultado = aplicar ( cuadrado , 5 ) print ( resultado ) # Salida: 25","title":"Funciones como Argumentos"},{"location":"programming/function/#funciones-anonimas-lambda","text":"Las funciones lambda, tambi\u00e9n conocidas como funciones an\u00f3nimas, son funciones peque\u00f1as y sin nombre que se pueden definir de manera concisa en una l\u00ednea de c\u00f3digo. cuadrado = lambda x : x ** 2 resultado = cuadrado ( 5 ) print ( resultado ) # Salida: 25","title":"Funciones An\u00f3nimas (Lambda)"},{"location":"programming/function/#alcance-de-variables-scope","text":"Python utiliza un alcance l\u00e9xico, lo que significa que una variable se busca primero dentro de la funci\u00f3n actual y, si no se encuentra, se busca en los alcances exteriores.","title":"Alcance de Variables (Scope)"},{"location":"programming/function/#variables-locales-y-globales","text":"x = 10 # Variable global def funcion (): x = 5 # Variable local dentro de la funci\u00f3n print ( x ) funcion () # Salida: 5 print ( x ) # Salida: 10 (la variable global no se modifica)","title":"Variables Locales y Globales"},{"location":"programming/function/#uso-de-la-palabra-clave-global","text":"Puedes declarar una variable global dentro de una funci\u00f3n utilizando la palabra clave global . x = 10 def modificar_global (): global x x = 5 modificar_global () print ( x ) # Salida: 5","title":"Uso de la Palabra Clave global"},{"location":"programming/function/#documentacion-de-funciones","text":"Es una buena pr\u00e1ctica documentar tus funciones para que otros desarrolladores (y t\u00fa mismo en el futuro) puedan entender su prop\u00f3sito y uso. def suma ( a , b ): \"\"\" Esta funci\u00f3n devuelve la suma de dos n\u00fameros. Args: a (int): El primer n\u00famero. b (int): El segundo n\u00famero. Returns: int: La suma de a y b. \"\"\" return a + b","title":"Documentaci\u00f3n de Funciones"},{"location":"programming/function/#conclusion","text":"Las funciones son una parte esencial de Python y de la programaci\u00f3n en general. Al comprender y dominar los conceptos y las t\u00e9cnicas relacionadas con las funciones, puedes escribir c\u00f3digo m\u00e1s modular, limpio y mantenible. Estos son los fundamentos, pero hay mucho m\u00e1s que explorar en el mundo de las funciones en Python.","title":"Conclusi\u00f3n"},{"location":"programming/paradigm/","text":"Paradigmas de Programaci\u00f3n Los paradigmas de programaci\u00f3n son enfoques fundamentales y filosof\u00edas de desarrollo de software que gu\u00edan la forma en que los programadores resuelven problemas y organizan c\u00f3digo. Cada paradigma tiene sus propias caracter\u00edsticas, ventajas y desventajas. En este art\u00edculo, exploraremos los or\u00edgenes de los paradigmas de programaci\u00f3n, los lenguajes en los que se utilizan principalmente y c\u00f3mo Python se destaca como un lenguaje multiparadigma. Or\u00edgenes de los Paradigmas de Programaci\u00f3n Los paradigmas de programaci\u00f3n han evolucionado a lo largo del tiempo en respuesta a las necesidades cambiantes de la programaci\u00f3n. Algunos de los paradigmas m\u00e1s influyentes incluyen: 1. Programaci\u00f3n Imperativa/Procedural: Or\u00edgenes: Surgi\u00f3 en la d\u00e9cada de 1950 con lenguajes como Fortran y COBOL. Se centr\u00f3 en instrucciones secuenciales para resolver problemas. Ejemplos: C, Pascal. 2. Programaci\u00f3n Estructurada: Or\u00edgenes: Se desarroll\u00f3 en la d\u00e9cada de 1960 como respuesta a la complejidad creciente de los programas. Se enfoca en la organizaci\u00f3n l\u00f3gica de un programa en m\u00f3dulos y estructuras de control. Ejemplos: C, Pascal. 3. Programaci\u00f3n Orientada a Objetos (POO): Or\u00edgenes: A finales de la d\u00e9cada de 1960 y principios de la d\u00e9cada de 1970, se crearon los conceptos de objetos y clases para modelar sistemas complejos y facilitar la reutilizaci\u00f3n de c\u00f3digo. Ejemplos: Java, C++, Python. 4. Programaci\u00f3n Funcional: Or\u00edgenes: Tiene ra\u00edces en la d\u00e9cada de 1950, pero gan\u00f3 popularidad en la d\u00e9cada de 1980. Se basa en las funciones matem\u00e1ticas y evita los efectos secundarios. Ejemplos: Lisp, Haskell, JavaScript. 5. Programaci\u00f3n L\u00f3gica: Or\u00edgenes: Se desarroll\u00f3 en la d\u00e9cada de 1970. Se basa en la l\u00f3gica formal y la inferencia. Ejemplos: Prolog. 6. Programaci\u00f3n Basada en Reglas: Or\u00edgenes: Se basa en la aplicaci\u00f3n de reglas y se utiliza en sistemas expertos y sistemas de razonamiento. Ejemplos: CLIPS. Lenguajes Principales para Cada Paradigma Cada paradigma se asocia principalmente con ciertos lenguajes de programaci\u00f3n: Imperativa/Procedural: C, Pascal. Estructurada: C, Pascal. Orientada a Objetos (POO): Java, C++, Python. Funcional: Haskell, Lisp, JavaScript. L\u00f3gica: Prolog. Basada en Reglas: CLIPS. Python: Un Lenguaje Multiparadigma Python es conocido por ser un lenguaje multiparadigma, lo que significa que admite m\u00faltiples enfoques de programaci\u00f3n. Veamos c\u00f3mo Python abarca varios paradigmas: 1. Programaci\u00f3n Imperativa/Procedural: Python permite la programaci\u00f3n imperativa y procedural mediante la escritura de secuencias de comandos y la manipulaci\u00f3n directa de datos y variables. 2. Programaci\u00f3n Orientada a Objetos (POO): Python es un lenguaje orientado a objetos en su n\u00facleo. Permite la definici\u00f3n de clases y objetos, herencia, encapsulaci\u00f3n y polimorfismo. 3. Programaci\u00f3n Funcional: Python admite la programaci\u00f3n funcional con funciones de orden superior, funciones lambda y herramientas como map() , filter() , y reduce() . 4. Programaci\u00f3n Estructurada: Python enfatiza la programaci\u00f3n estructurada mediante el uso de bloques de c\u00f3digo con indentaci\u00f3n y estructuras de control como bucles y condicionales. 5. Programaci\u00f3n L\u00f3gica y Basada en Reglas: Aunque no es un lenguaje principal para estos paradigmas, Python tiene bibliotecas como Pyke que permiten la programaci\u00f3n l\u00f3gica y basada en reglas. Ventajas y Desventajas de la Versatilidad de Python Ventajas: Flexibilidad: Python es un lenguaje flexible que permite a los desarrolladores elegir el paradigma que mejor se adapte a sus necesidades. Aprendizaje Gradual: Los principiantes pueden comenzar con un enfoque procedural simple y luego explorar otros paradigmas a medida que adquieren experiencia. Amplio Ecosistema: Python tiene una amplia variedad de bibliotecas y marcos de trabajo que son compatibles con diferentes paradigmas. Desventajas: Potencial Confusi\u00f3n: La versatilidad de Python puede llevar a la confusi\u00f3n si los desarrolladores no tienen una comprensi\u00f3n clara de cu\u00e1ndo y c\u00f3mo aplicar diferentes paradigmas. Rendimiento Limitado: En ciertos casos, los enfoques multiparadigma pueden resultar en un rendimiento ligeramente inferior en comparaci\u00f3n con lenguajes altamente especializados para un paradigma espec\u00edfico. Conclusi\u00f3n Los paradigmas de programaci\u00f3n representan diferentes formas de pensar y resolver problemas de programaci\u00f3n. Python destaca como un lenguaje multiparadigma que permite a los desarrolladores aprovechar diferentes enfoques seg\u00fan sus necesidades. Esto lo convierte en una herramienta poderosa y vers\u00e1til en el mundo de la programaci\u00f3n y la resoluci\u00f3n de problemas computacionales. La comprensi\u00f3n de estos paradigmas y su aplicaci\u00f3n adecuada es esencial para convertirse en un programador efectivo y vers\u00e1til.","title":"Paradigmas de Programaci\u00f3n"},{"location":"programming/paradigm/#paradigmas-de-programacion","text":"Los paradigmas de programaci\u00f3n son enfoques fundamentales y filosof\u00edas de desarrollo de software que gu\u00edan la forma en que los programadores resuelven problemas y organizan c\u00f3digo. Cada paradigma tiene sus propias caracter\u00edsticas, ventajas y desventajas. En este art\u00edculo, exploraremos los or\u00edgenes de los paradigmas de programaci\u00f3n, los lenguajes en los que se utilizan principalmente y c\u00f3mo Python se destaca como un lenguaje multiparadigma.","title":"Paradigmas de Programaci\u00f3n"},{"location":"programming/paradigm/#origenes-de-los-paradigmas-de-programacion","text":"Los paradigmas de programaci\u00f3n han evolucionado a lo largo del tiempo en respuesta a las necesidades cambiantes de la programaci\u00f3n. Algunos de los paradigmas m\u00e1s influyentes incluyen:","title":"Or\u00edgenes de los Paradigmas de Programaci\u00f3n"},{"location":"programming/paradigm/#1-programacion-imperativaprocedural","text":"Or\u00edgenes: Surgi\u00f3 en la d\u00e9cada de 1950 con lenguajes como Fortran y COBOL. Se centr\u00f3 en instrucciones secuenciales para resolver problemas. Ejemplos: C, Pascal.","title":"1. Programaci\u00f3n Imperativa/Procedural:"},{"location":"programming/paradigm/#2-programacion-estructurada","text":"Or\u00edgenes: Se desarroll\u00f3 en la d\u00e9cada de 1960 como respuesta a la complejidad creciente de los programas. Se enfoca en la organizaci\u00f3n l\u00f3gica de un programa en m\u00f3dulos y estructuras de control. Ejemplos: C, Pascal.","title":"2. Programaci\u00f3n Estructurada:"},{"location":"programming/paradigm/#3-programacion-orientada-a-objetos-poo","text":"Or\u00edgenes: A finales de la d\u00e9cada de 1960 y principios de la d\u00e9cada de 1970, se crearon los conceptos de objetos y clases para modelar sistemas complejos y facilitar la reutilizaci\u00f3n de c\u00f3digo. Ejemplos: Java, C++, Python.","title":"3. Programaci\u00f3n Orientada a Objetos (POO):"},{"location":"programming/paradigm/#4-programacion-funcional","text":"Or\u00edgenes: Tiene ra\u00edces en la d\u00e9cada de 1950, pero gan\u00f3 popularidad en la d\u00e9cada de 1980. Se basa en las funciones matem\u00e1ticas y evita los efectos secundarios. Ejemplos: Lisp, Haskell, JavaScript.","title":"4. Programaci\u00f3n Funcional:"},{"location":"programming/paradigm/#5-programacion-logica","text":"Or\u00edgenes: Se desarroll\u00f3 en la d\u00e9cada de 1970. Se basa en la l\u00f3gica formal y la inferencia. Ejemplos: Prolog.","title":"5. Programaci\u00f3n L\u00f3gica:"},{"location":"programming/paradigm/#6-programacion-basada-en-reglas","text":"Or\u00edgenes: Se basa en la aplicaci\u00f3n de reglas y se utiliza en sistemas expertos y sistemas de razonamiento. Ejemplos: CLIPS.","title":"6. Programaci\u00f3n Basada en Reglas:"},{"location":"programming/paradigm/#lenguajes-principales-para-cada-paradigma","text":"Cada paradigma se asocia principalmente con ciertos lenguajes de programaci\u00f3n: Imperativa/Procedural: C, Pascal. Estructurada: C, Pascal. Orientada a Objetos (POO): Java, C++, Python. Funcional: Haskell, Lisp, JavaScript. L\u00f3gica: Prolog. Basada en Reglas: CLIPS.","title":"Lenguajes Principales para Cada Paradigma"},{"location":"programming/paradigm/#python-un-lenguaje-multiparadigma","text":"Python es conocido por ser un lenguaje multiparadigma, lo que significa que admite m\u00faltiples enfoques de programaci\u00f3n. Veamos c\u00f3mo Python abarca varios paradigmas:","title":"Python: Un Lenguaje Multiparadigma"},{"location":"programming/paradigm/#1-programacion-imperativaprocedural_1","text":"Python permite la programaci\u00f3n imperativa y procedural mediante la escritura de secuencias de comandos y la manipulaci\u00f3n directa de datos y variables.","title":"1. Programaci\u00f3n Imperativa/Procedural:"},{"location":"programming/paradigm/#2-programacion-orientada-a-objetos-poo","text":"Python es un lenguaje orientado a objetos en su n\u00facleo. Permite la definici\u00f3n de clases y objetos, herencia, encapsulaci\u00f3n y polimorfismo.","title":"2. Programaci\u00f3n Orientada a Objetos (POO):"},{"location":"programming/paradigm/#3-programacion-funcional","text":"Python admite la programaci\u00f3n funcional con funciones de orden superior, funciones lambda y herramientas como map() , filter() , y reduce() .","title":"3. Programaci\u00f3n Funcional:"},{"location":"programming/paradigm/#4-programacion-estructurada","text":"Python enfatiza la programaci\u00f3n estructurada mediante el uso de bloques de c\u00f3digo con indentaci\u00f3n y estructuras de control como bucles y condicionales.","title":"4. Programaci\u00f3n Estructurada:"},{"location":"programming/paradigm/#5-programacion-logica-y-basada-en-reglas","text":"Aunque no es un lenguaje principal para estos paradigmas, Python tiene bibliotecas como Pyke que permiten la programaci\u00f3n l\u00f3gica y basada en reglas.","title":"5. Programaci\u00f3n L\u00f3gica y Basada en Reglas:"},{"location":"programming/paradigm/#ventajas-y-desventajas-de-la-versatilidad-de-python","text":"Ventajas: Flexibilidad: Python es un lenguaje flexible que permite a los desarrolladores elegir el paradigma que mejor se adapte a sus necesidades. Aprendizaje Gradual: Los principiantes pueden comenzar con un enfoque procedural simple y luego explorar otros paradigmas a medida que adquieren experiencia. Amplio Ecosistema: Python tiene una amplia variedad de bibliotecas y marcos de trabajo que son compatibles con diferentes paradigmas. Desventajas: Potencial Confusi\u00f3n: La versatilidad de Python puede llevar a la confusi\u00f3n si los desarrolladores no tienen una comprensi\u00f3n clara de cu\u00e1ndo y c\u00f3mo aplicar diferentes paradigmas. Rendimiento Limitado: En ciertos casos, los enfoques multiparadigma pueden resultar en un rendimiento ligeramente inferior en comparaci\u00f3n con lenguajes altamente especializados para un paradigma espec\u00edfico.","title":"Ventajas y Desventajas de la Versatilidad de Python"},{"location":"programming/paradigm/#conclusion","text":"Los paradigmas de programaci\u00f3n representan diferentes formas de pensar y resolver problemas de programaci\u00f3n. Python destaca como un lenguaje multiparadigma que permite a los desarrolladores aprovechar diferentes enfoques seg\u00fan sus necesidades. Esto lo convierte en una herramienta poderosa y vers\u00e1til en el mundo de la programaci\u00f3n y la resoluci\u00f3n de problemas computacionales. La comprensi\u00f3n de estos paradigmas y su aplicaci\u00f3n adecuada es esencial para convertirse en un programador efectivo y vers\u00e1til.","title":"Conclusi\u00f3n"},{"location":"programming/pep/","text":"Python Enhancement Proposals (P.E.P.) Introducci\u00f3n Los PEP (Python Enhancement Proposals) son documentos que describen propuestas para mejorar el lenguaje de programaci\u00f3n Python. Los PEP son una parte fundamental del proceso de toma de decisiones en Python y permiten a la comunidad de desarrolladores colaborar en la evoluci\u00f3n del lenguaje. En este art\u00edculo, exploraremos los PEP m\u00e1s relevantes de Python, aquellos que han tenido un impacto significativo en la forma en que programamos en Python. Aprenderemos sobre la historia detr\u00e1s de cada PEP, su prop\u00f3sito y veremos ejemplos pr\u00e1cticos de c\u00f3mo se aplican en el c\u00f3digo. PEP 8: Gu\u00eda de Estilo para Programadores Python Introducci\u00f3n El PEP 8, titulado \"Style Guide for Python Code\", es uno de los PEP m\u00e1s influyentes en la comunidad de Python. Fue escrito por Guido van Rossum, el creador de Python, y establece las pautas para escribir c\u00f3digo Python legible y consistente. Ejemplo Pr\u00e1ctico A continuaci\u00f3n, se presenta un ejemplo de c\u00f3digo que sigue las pautas de PEP 8: # PEP 8: Imports should usually be on separate lines and should be grouped in the following order: # Standard library imports. # Related third-party imports. # Local application/library specific imports. import os import sys from math import sqrt from my_module import my_function Referencias y Recursos PEP 8 -- Style Guide for Python Code Gu\u00eda de Estilo de Python (PEP 8) en espa\u00f1ol PEP 20: El Zen de Python Introducci\u00f3n El PEP 20, titulado \"The Zen of Python\", es una colecci\u00f3n de principios filos\u00f3ficos que gu\u00edan el dise\u00f1o del lenguaje Python. Fue escrito por Tim Peters y refleja la cultura y la filosof\u00eda de la comunidad Python. Ejemplo Pr\u00e1ctico El Zen de Python se puede ver directamente desde un int\u00e9rprete Python utilizando el siguiente c\u00f3digo: import this Esto mostrar\u00e1 los principios del Zen de Python en la consola. Referencias y Recursos PEP 20 -- The Zen of Python El Zen de Python en espa\u00f1ol PEP 257: Docstrings Introducci\u00f3n El PEP 257, titulado \"Docstring Conventions\", se centra en la documentaci\u00f3n de funciones, clases y m\u00f3dulos en Python. Establece pautas para escribir docstrings, que son cadenas de documentaci\u00f3n que explican el prop\u00f3sito y el comportamiento del c\u00f3digo. Ejemplo Pr\u00e1ctico A continuaci\u00f3n, se muestra un ejemplo de una docstring seg\u00fan las pautas de PEP 257: def my_function ( param1 , param2 ): \"\"\" Esta funci\u00f3n toma dos par\u00e1metros y realiza una operaci\u00f3n. :param param1: Descripci\u00f3n del primer par\u00e1metro. :type param1: Tipo del primer par\u00e1metro. :param param2: Descripci\u00f3n del segundo par\u00e1metro. :type param2: Tipo del segundo par\u00e1metro. :return: Valor de retorno de la funci\u00f3n. :rtype: Tipo del valor de retorno. \"\"\" # C\u00f3digo de la funci\u00f3n aqu\u00ed Referencias y Recursos PEP 257 -- Docstring Conventions PEP 333: Interfaz de Puerta de Enlace de Aplicaci\u00f3n (WSGI) Introducci\u00f3n El PEP 333, titulado \"Python Web Server Gateway Interface (WSGI)\", define una interfaz est\u00e1ndar entre servidores web y aplicaciones web Python o frameworks. Esta interfaz ha sido fundamental para la creaci\u00f3n de servidores web y frameworks compatibles con Python. Ejemplo Pr\u00e1ctico El uso directo de WSGI puede ser complejo, pero muchos frameworks web, como Flask y Django, se basan en \u00e9l. Aqu\u00ed hay un ejemplo de una aplicaci\u00f3n Flask que utiliza WSGI: from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def hello_world (): return 'Hello, World!' Referencias y Recursos PEP 333 -- Python Web Server Gateway Interface (WSGI) Documentaci\u00f3n de WSGI PEP 484: Comentarios de Tipo Introducci\u00f3n El PEP 484, titulado \"Type Hints\", introdujo el sistema de comentarios de tipo en Python. Esto permite a los desarrolladores especificar tipos de variables y argumentos en el c\u00f3digo, lo que facilita la verificaci\u00f3n est\u00e1tica de tipos y mejora la legibilidad del c\u00f3digo. Ejemplo Pr\u00e1ctico Aqu\u00ed hay un ejemplo de c\u00f3digo Python que utiliza comentarios de tipo seg\u00fan PEP 484: def greet ( name : str ) -> str : return \"Hello, \" + name Referencias y Recursos PEP 484 -- Type Hints Documentaci\u00f3n de Type Hints en Python PEP 572: Asignaci\u00f3n de Expresiones (Walrus Operator) Introducci\u00f3n El PEP 572 introdujo el operador \"walrus\" ( := ), que permite asignar valores a variables como parte de una expresi\u00f3n. Esto simplifica el c\u00f3digo y mejora la legibilidad. Ejemplo Pr\u00e1ctico Aqu\u00ed hay un ejemplo de c\u00f3mo se puede utilizar el operador \"walrus\" para simplificar el c\u00f3digo: # Sin el operador walrus data = get_data () if data is not None : process_data ( data ) # Con el operador walrus if ( data := get_data ()) is not None : process_data ( data ) Referencias y Recursos PEP 572 -- Assignment Expressions Gu\u00eda de uso del operador \"walrus\" en Python PEP 8000: Proceso de PEP Introducci\u00f3n El PEP 8000 no es una propuesta de mejora en s\u00ed, sino que describe el proceso y las pautas para la creaci\u00f3n y gesti\u00f3n de PEP. Es esencial para comprender c\u00f3mo funciona el proceso de toma de decisiones en Python y c\u00f3mo los PEP son revisados y aceptados. Ejemplo Pr\u00e1ctico No hay un ejemplo de c\u00f3digo pr\u00e1ctico para el PEP 8000, ya que es un documento que describe el proceso de creaci\u00f3n de PEP. Referencias y Recursos PEP 8000 -- Python Language Governance Proposal Overview Conclusi\u00f3n En este art\u00edculo, hemos explorado algunos de los PEP m\u00e1s relevantes de Python y hemos aprendido sobre su importancia en la evoluci\u00f3n del lenguaje. Hemos visto ejemplos pr\u00e1cticos de c\u00f3mo se aplican estos PEP en el c\u00f3digo y se han proporcionado referencias adicionales para aquellos que deseen profundizar en cada tema. Los PEP son una parte fundamental de la comunidad Python y permiten que los desarrolladores colaboren en la mejora continua del lenguaje. Al comprender estos PEP, estar\u00e1s mejor equipado para escribir c\u00f3digo Python de alta calidad y seguir las mejores pr\u00e1cticas de la comunidad. Recuerda que Python es un lenguaje en constante evoluci\u00f3n, y nuevos PEP se est\u00e1n desarrollando todo el tiempo. Mantente actualizado con las \u00faltimas propuestas y contribuye a la comunidad Python participando en la discusi\u00f3n y revisi\u00f3n de PEP relevantes. Referencias Adicionales Python Enhancement Proposals (PEP) Python.org - PEP Index PEP 8 -- Style Guide for Python Code PEP 20 -- The Zen of Python PEP 257 -- Docstring Conventions PEP 333 -- Python Web Server Gateway Interface (WSGI) PEP 484 -- Type Hints PEP 572 -- Assignment Expressions PEP 8000 -- Python Language Governance Proposal Overview","title":"Python Enhancement Proposals (P.E.P.)"},{"location":"programming/pep/#python-enhancement-proposals-pep","text":"","title":"Python Enhancement Proposals (P.E.P.)"},{"location":"programming/pep/#introduccion","text":"Los PEP (Python Enhancement Proposals) son documentos que describen propuestas para mejorar el lenguaje de programaci\u00f3n Python. Los PEP son una parte fundamental del proceso de toma de decisiones en Python y permiten a la comunidad de desarrolladores colaborar en la evoluci\u00f3n del lenguaje. En este art\u00edculo, exploraremos los PEP m\u00e1s relevantes de Python, aquellos que han tenido un impacto significativo en la forma en que programamos en Python. Aprenderemos sobre la historia detr\u00e1s de cada PEP, su prop\u00f3sito y veremos ejemplos pr\u00e1cticos de c\u00f3mo se aplican en el c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"programming/pep/#pep-8-guia-de-estilo-para-programadores-python","text":"","title":"PEP 8: Gu\u00eda de Estilo para Programadores Python"},{"location":"programming/pep/#introduccion_1","text":"El PEP 8, titulado \"Style Guide for Python Code\", es uno de los PEP m\u00e1s influyentes en la comunidad de Python. Fue escrito por Guido van Rossum, el creador de Python, y establece las pautas para escribir c\u00f3digo Python legible y consistente.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico","text":"A continuaci\u00f3n, se presenta un ejemplo de c\u00f3digo que sigue las pautas de PEP 8: # PEP 8: Imports should usually be on separate lines and should be grouped in the following order: # Standard library imports. # Related third-party imports. # Local application/library specific imports. import os import sys from math import sqrt from my_module import my_function","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos","text":"PEP 8 -- Style Guide for Python Code Gu\u00eda de Estilo de Python (PEP 8) en espa\u00f1ol","title":"Referencias y Recursos"},{"location":"programming/pep/#pep-20-el-zen-de-python","text":"","title":"PEP 20: El Zen de Python"},{"location":"programming/pep/#introduccion_2","text":"El PEP 20, titulado \"The Zen of Python\", es una colecci\u00f3n de principios filos\u00f3ficos que gu\u00edan el dise\u00f1o del lenguaje Python. Fue escrito por Tim Peters y refleja la cultura y la filosof\u00eda de la comunidad Python.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_1","text":"El Zen de Python se puede ver directamente desde un int\u00e9rprete Python utilizando el siguiente c\u00f3digo: import this Esto mostrar\u00e1 los principios del Zen de Python en la consola.","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos_1","text":"PEP 20 -- The Zen of Python El Zen de Python en espa\u00f1ol","title":"Referencias y Recursos"},{"location":"programming/pep/#pep-257-docstrings","text":"","title":"PEP 257: Docstrings"},{"location":"programming/pep/#introduccion_3","text":"El PEP 257, titulado \"Docstring Conventions\", se centra en la documentaci\u00f3n de funciones, clases y m\u00f3dulos en Python. Establece pautas para escribir docstrings, que son cadenas de documentaci\u00f3n que explican el prop\u00f3sito y el comportamiento del c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_2","text":"A continuaci\u00f3n, se muestra un ejemplo de una docstring seg\u00fan las pautas de PEP 257: def my_function ( param1 , param2 ): \"\"\" Esta funci\u00f3n toma dos par\u00e1metros y realiza una operaci\u00f3n. :param param1: Descripci\u00f3n del primer par\u00e1metro. :type param1: Tipo del primer par\u00e1metro. :param param2: Descripci\u00f3n del segundo par\u00e1metro. :type param2: Tipo del segundo par\u00e1metro. :return: Valor de retorno de la funci\u00f3n. :rtype: Tipo del valor de retorno. \"\"\" # C\u00f3digo de la funci\u00f3n aqu\u00ed","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos_2","text":"PEP 257 -- Docstring Conventions","title":"Referencias y Recursos"},{"location":"programming/pep/#pep-333-interfaz-de-puerta-de-enlace-de-aplicacion-wsgi","text":"","title":"PEP 333: Interfaz de Puerta de Enlace de Aplicaci\u00f3n (WSGI)"},{"location":"programming/pep/#introduccion_4","text":"El PEP 333, titulado \"Python Web Server Gateway Interface (WSGI)\", define una interfaz est\u00e1ndar entre servidores web y aplicaciones web Python o frameworks. Esta interfaz ha sido fundamental para la creaci\u00f3n de servidores web y frameworks compatibles con Python.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_3","text":"El uso directo de WSGI puede ser complejo, pero muchos frameworks web, como Flask y Django, se basan en \u00e9l. Aqu\u00ed hay un ejemplo de una aplicaci\u00f3n Flask que utiliza WSGI: from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def hello_world (): return 'Hello, World!'","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos_3","text":"PEP 333 -- Python Web Server Gateway Interface (WSGI) Documentaci\u00f3n de WSGI","title":"Referencias y Recursos"},{"location":"programming/pep/#pep-484-comentarios-de-tipo","text":"","title":"PEP 484: Comentarios de Tipo"},{"location":"programming/pep/#introduccion_5","text":"El PEP 484, titulado \"Type Hints\", introdujo el sistema de comentarios de tipo en Python. Esto permite a los desarrolladores especificar tipos de variables y argumentos en el c\u00f3digo, lo que facilita la verificaci\u00f3n est\u00e1tica de tipos y mejora la legibilidad del c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_4","text":"Aqu\u00ed hay un ejemplo de c\u00f3digo Python que utiliza comentarios de tipo seg\u00fan PEP 484: def greet ( name : str ) -> str : return \"Hello, \" + name","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos_4","text":"PEP 484 -- Type Hints Documentaci\u00f3n de Type Hints en Python","title":"Referencias y Recursos"},{"location":"programming/pep/#pep-572-asignacion-de-expresiones-walrus-operator","text":"","title":"PEP 572: Asignaci\u00f3n de Expresiones (Walrus Operator)"},{"location":"programming/pep/#introduccion_6","text":"El PEP 572 introdujo el operador \"walrus\" ( := ), que permite asignar valores a variables como parte de una expresi\u00f3n. Esto simplifica el c\u00f3digo y mejora la legibilidad.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_5","text":"Aqu\u00ed hay un ejemplo de c\u00f3mo se puede utilizar el operador \"walrus\" para simplificar el c\u00f3digo: # Sin el operador walrus data = get_data () if data is not None : process_data ( data ) # Con el operador walrus if ( data := get_data ()) is not None : process_data ( data )","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias","text":"y Recursos PEP 572 -- Assignment Expressions Gu\u00eda de uso del operador \"walrus\" en Python","title":"Referencias"},{"location":"programming/pep/#pep-8000-proceso-de-pep","text":"","title":"PEP 8000: Proceso de PEP"},{"location":"programming/pep/#introduccion_7","text":"El PEP 8000 no es una propuesta de mejora en s\u00ed, sino que describe el proceso y las pautas para la creaci\u00f3n y gesti\u00f3n de PEP. Es esencial para comprender c\u00f3mo funciona el proceso de toma de decisiones en Python y c\u00f3mo los PEP son revisados y aceptados.","title":"Introducci\u00f3n"},{"location":"programming/pep/#ejemplo-practico_6","text":"No hay un ejemplo de c\u00f3digo pr\u00e1ctico para el PEP 8000, ya que es un documento que describe el proceso de creaci\u00f3n de PEP.","title":"Ejemplo Pr\u00e1ctico"},{"location":"programming/pep/#referencias-y-recursos_5","text":"PEP 8000 -- Python Language Governance Proposal Overview","title":"Referencias y Recursos"},{"location":"programming/pep/#conclusion","text":"En este art\u00edculo, hemos explorado algunos de los PEP m\u00e1s relevantes de Python y hemos aprendido sobre su importancia en la evoluci\u00f3n del lenguaje. Hemos visto ejemplos pr\u00e1cticos de c\u00f3mo se aplican estos PEP en el c\u00f3digo y se han proporcionado referencias adicionales para aquellos que deseen profundizar en cada tema. Los PEP son una parte fundamental de la comunidad Python y permiten que los desarrolladores colaboren en la mejora continua del lenguaje. Al comprender estos PEP, estar\u00e1s mejor equipado para escribir c\u00f3digo Python de alta calidad y seguir las mejores pr\u00e1cticas de la comunidad. Recuerda que Python es un lenguaje en constante evoluci\u00f3n, y nuevos PEP se est\u00e1n desarrollando todo el tiempo. Mantente actualizado con las \u00faltimas propuestas y contribuye a la comunidad Python participando en la discusi\u00f3n y revisi\u00f3n de PEP relevantes.","title":"Conclusi\u00f3n"},{"location":"programming/pep/#referencias-adicionales","text":"Python Enhancement Proposals (PEP) Python.org - PEP Index PEP 8 -- Style Guide for Python Code PEP 20 -- The Zen of Python PEP 257 -- Docstring Conventions PEP 333 -- Python Web Server Gateway Interface (WSGI) PEP 484 -- Type Hints PEP 572 -- Assignment Expressions PEP 8000 -- Python Language Governance Proposal Overview","title":"Referencias Adicionales"},{"location":"programming/refactoring/","text":"Refactoring Introducci\u00f3n La refactorizaci\u00f3n de c\u00f3digo es un proceso fundamental en el desarrollo de software que implica reescribir o reorganizar el c\u00f3digo existente sin cambiar su funcionalidad externa. El objetivo de la refactorizaci\u00f3n es mejorar la estructura interna del c\u00f3digo, haci\u00e9ndolo m\u00e1s legible, mantenible y eficiente, sin alterar su comportamiento. En este art\u00edculo, exploraremos en detalle la refactorizaci\u00f3n de c\u00f3digo en Python. Comenzaremos por comprender su origen y por qu\u00e9 es necesario. Luego, analizaremos varios casos de uso comunes de refactorizaci\u00f3n en Python, junto con ejemplos pr\u00e1cticos. A lo largo del art\u00edculo, se proporcionar\u00e1n referencias y recursos adicionales para ayudarte a convertirte en un experto en refactorizaci\u00f3n de c\u00f3digo en Python. Origen de la Refactorizaci\u00f3n de C\u00f3digo La refactorizaci\u00f3n de c\u00f3digo no es una pr\u00e1ctica nueva. Su origen se remonta a los primeros d\u00edas de la programaci\u00f3n inform\u00e1tica. Sin embargo, el t\u00e9rmino \"refactorizaci\u00f3n\" fue popularizado por Martin Fowler en su libro \"Refactoring: Improving the Design of Existing Code\" publicado en 1999. El concepto b\u00e1sico de refactorizaci\u00f3n es simple: a medida que desarrollamos software, inevitablemente escribimos c\u00f3digo que funciona pero que puede no ser eficiente, claro o f\u00e1cil de mantener. La refactorizaci\u00f3n aborda este problema permiti\u00e9ndonos reorganizar y mejorar continuamente el c\u00f3digo existente sin cambiar su comportamiento externo. Esto ayuda a mantener el c\u00f3digo limpio y facilita el trabajo en equipo, la detecci\u00f3n temprana de errores y la evoluci\u00f3n del software a medida que cambian los requisitos. Por qu\u00e9 es Necesaria la Refactorizaci\u00f3n La refactorizaci\u00f3n de c\u00f3digo es esencial por varias razones: Mejora la Legibilidad: Un c\u00f3digo limpio y bien estructurado es m\u00e1s f\u00e1cil de leer y entender. Esto facilita la colaboraci\u00f3n entre equipos de desarrollo y permite a los desarrolladores comprender r\u00e1pidamente lo que hace cada parte del c\u00f3digo. Facilita el Mantenimiento: Un c\u00f3digo desorganizado es propenso a errores y dif\u00edcil de mantener. La refactorizaci\u00f3n ayuda a eliminar duplicaciones, simplificar l\u00f3gica compleja y mejorar la cohesi\u00f3n del c\u00f3digo, lo que facilita el mantenimiento a largo plazo. Aumenta la Eficiencia: La refactorizaci\u00f3n puede conducir a mejoras en el rendimiento y la eficiencia del c\u00f3digo. La eliminaci\u00f3n de c\u00f3digo duplicado y la optimizaci\u00f3n de algoritmos pueden acelerar las aplicaciones. Facilita la Escalabilidad: Un c\u00f3digo bien refactorizado es m\u00e1s f\u00e1cil de ampliar y extender para satisfacer nuevos requisitos. Esto es especialmente importante en proyectos en constante evoluci\u00f3n. Reduce el Riesgo de Errores: Al refactorizar el c\u00f3digo, los desarrolladores tienen la oportunidad de identificar y corregir errores potenciales antes de que se conviertan en problemas reales. Mejora la Calidad del Software: La refactorizaci\u00f3n es una pr\u00e1ctica clave para mantener la calidad del software a lo largo del tiempo. Ayuda a reducir la acumulaci\u00f3n de deuda t\u00e9cnica y a mantener el c\u00f3digo limpio y ordenado. Casos de Uso de la Refactorizaci\u00f3n en Python A continuaci\u00f3n, exploraremos algunos casos de uso comunes de refactorizaci\u00f3n en Python junto con ejemplos pr\u00e1cticos. 1. Eliminaci\u00f3n de C\u00f3digo Duplicado Uno de los problemas m\u00e1s comunes en el desarrollo de software es la duplicaci\u00f3n de c\u00f3digo. Esto no solo aumenta la longitud del c\u00f3digo, sino que tambi\u00e9n hace que el mantenimiento sea m\u00e1s dif\u00edcil, ya que cualquier cambio debe realizarse en varios lugares. La refactorizaci\u00f3n puede ayudar a eliminar c\u00f3digo duplicado y mantener el c\u00f3digo base m\u00e1s limpio. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una funci\u00f3n que calcula el \u00e1rea de un rect\u00e1ngulo y otra que calcula el \u00e1rea de un cuadrado. Ambas funciones son muy similares, pero el cuadrado es solo un caso especial de un rect\u00e1ngulo. Podemos refactorizar el c\u00f3digo de la siguiente manera: # Versi\u00f3n original def area_rectangulo ( base , altura ): return base * altura def area_cuadrado ( lado ): return lado * lado # Refactorizaci\u00f3n def area_rectangulo ( base , altura ): return base * altura def area_cuadrado ( lado ): return area_rectangulo ( lado , lado ) 2. Simplificaci\u00f3n de Expresiones Condicionales Las expresiones condicionales complejas pueden dificultar la comprensi\u00f3n del c\u00f3digo. La refactorizaci\u00f3n puede ayudar a simplificar estas expresiones y hacer que el c\u00f3digo sea m\u00e1s legible. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una expresi\u00f3n condicional compleja para determinar si una persona es elegible para un descuento. La refactorizaci\u00f3n puede simplificar la expresi\u00f3n de la siguiente manera: # Versi\u00f3n original if edad >= 18 and edad <= 65 and ingresos_anuales >= 20000 : es_elegible = True else : es_elegible = False # Refactorizaci\u00f3n es_elegible = 18 <= edad <= 65 and ingresos_anuales >= 20000 3. Extracci\u00f3n de Funciones Cuando una funci\u00f3n realiza m\u00faltiples tareas o es demasiado larga, puede ser \u00fatil dividirla en funciones m\u00e1s peque\u00f1as y espec\u00edficas. Esto mejora la cohesi\u00f3n del c\u00f3digo y facilita su comprensi\u00f3n. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una funci\u00f3n que valida un formulario web, realiza c\u00e1lculos y env\u00eda un correo electr\u00f3nico. Podemos refactorizarla de la siguiente manera: # Versi\u00f3n original def procesar_formulario ( formulario ): if validar_formulario ( formulario ): datos = extraer_datos ( formulario ) calcular_resultados ( datos ) enviar_correo_electronico ( datos ) # Refactorizaci\u00f3n def procesar_formulario ( formulario ): if validar_formulario ( formulario ): datos = extraer_datos ( formulario ) realizar_calculos ( datos ) enviar_correo_electronico ( datos ) def realizar_calculos ( datos ): calcular_resultados ( datos ) 4. Uso de List Comprehensions Las list comprehensions son una caracter\u00edstica poderosa de Python que permite crear listas de manera concisa. Refactorizar bucles tradicionales en list comprehensions puede hacer que el c\u00f3digo sea m\u00e1s legible y eficiente. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una lista de n\u00fameros y queremos crear una nueva lista que contenga el cuadrado de cada n\u00famero. Podemos refactorizar un bucle for de la siguiente manera: # Versi\u00f3n original numeros = [ 1 , 2 , 3 , 4 , 5 ] cuadrados = [] for numero in numeros : cuadrados . append ( numero ** 2 ) # Refactorizaci\u00f3n numeros = [ 1 , 2 , 3 , 4 , 5 ] cuadrados = [ numero ** 2 for numero in numeros ] 5. Nombres de Variables Significativos Utilizar nombres de variables descriptivos es fundamental para la legibilidad del c\u00f3digo. La refactorizaci\u00f3n puede implicar cambiar nombres de variables a versiones m\u00e1s significativas. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una variable llamada x que representa el tiempo en segundos. Podemos refactorizarla para que el c\u00f3digo sea m\u00e1s claro: # Versi\u00f3n original x = 3600 # Representa el n\u00famero de segundos en una hora # Refactorizaci\u00f3n segundos_en_una_hora = 3600 Referencias y Recursos A medida que exploras y practicas la refactorizaci\u00f3n de c\u00f3digo en Python, aqu\u00ed tienes algunas referencias y recursos adicionales que te ser\u00e1n \u00fatiles: Refactoring: Improving the Design of Existing Code : El libro cl\u00e1sico de Martin Fowler sobre refactorizaci\u00f3n. The Pragmatic Programmer's Guide to Refactoring : Un libro pr\u00e1ctico sobre refactorizaci\u00f3n. PEP 8 -- Style Guide for Python Code : El PEP que define las convenciones de estilo de c\u00f3digo en Python. Refactoring.Guru : Un recurso en l\u00ednea que ofrece ejemplos y explicaciones detalladas de patrones de refactorizaci\u00f3n. pyrefactor : Una herramienta de refactorizaci\u00f3n para Python. Conclusi\u00f3n La refactorizaci\u00f3n de c\u00f3digo es una habilidad esencial para cualquier desarrollador de Python. Permite mejorar la calidad del c\u00f3digo, facilita su mantenimiento y contribuye a un desarrollo m\u00e1s eficiente y escalable. Al comprender los casos de uso comunes de refactorizaci\u00f3n y practicar con ejemplos reales, estar\u00e1s mejor preparado para escribir c\u00f3digo Python de alta calidad. Recuerda que la refactorizaci\u00f3n es un proceso continuo a lo largo del ciclo de vida del software. A medida que evolucionan los requisitos y se descubren nuevas formas de optimizar el c\u00f3digo, la refactorizaci\u00f3n seguir\u00e1 siendo una parte fundamental del desarrollo de software de calidad.","title":"Refactoring"},{"location":"programming/refactoring/#refactoring","text":"","title":"Refactoring"},{"location":"programming/refactoring/#introduccion","text":"La refactorizaci\u00f3n de c\u00f3digo es un proceso fundamental en el desarrollo de software que implica reescribir o reorganizar el c\u00f3digo existente sin cambiar su funcionalidad externa. El objetivo de la refactorizaci\u00f3n es mejorar la estructura interna del c\u00f3digo, haci\u00e9ndolo m\u00e1s legible, mantenible y eficiente, sin alterar su comportamiento. En este art\u00edculo, exploraremos en detalle la refactorizaci\u00f3n de c\u00f3digo en Python. Comenzaremos por comprender su origen y por qu\u00e9 es necesario. Luego, analizaremos varios casos de uso comunes de refactorizaci\u00f3n en Python, junto con ejemplos pr\u00e1cticos. A lo largo del art\u00edculo, se proporcionar\u00e1n referencias y recursos adicionales para ayudarte a convertirte en un experto en refactorizaci\u00f3n de c\u00f3digo en Python.","title":"Introducci\u00f3n"},{"location":"programming/refactoring/#origen-de-la-refactorizacion-de-codigo","text":"La refactorizaci\u00f3n de c\u00f3digo no es una pr\u00e1ctica nueva. Su origen se remonta a los primeros d\u00edas de la programaci\u00f3n inform\u00e1tica. Sin embargo, el t\u00e9rmino \"refactorizaci\u00f3n\" fue popularizado por Martin Fowler en su libro \"Refactoring: Improving the Design of Existing Code\" publicado en 1999. El concepto b\u00e1sico de refactorizaci\u00f3n es simple: a medida que desarrollamos software, inevitablemente escribimos c\u00f3digo que funciona pero que puede no ser eficiente, claro o f\u00e1cil de mantener. La refactorizaci\u00f3n aborda este problema permiti\u00e9ndonos reorganizar y mejorar continuamente el c\u00f3digo existente sin cambiar su comportamiento externo. Esto ayuda a mantener el c\u00f3digo limpio y facilita el trabajo en equipo, la detecci\u00f3n temprana de errores y la evoluci\u00f3n del software a medida que cambian los requisitos.","title":"Origen de la Refactorizaci\u00f3n de C\u00f3digo"},{"location":"programming/refactoring/#por-que-es-necesaria-la-refactorizacion","text":"La refactorizaci\u00f3n de c\u00f3digo es esencial por varias razones: Mejora la Legibilidad: Un c\u00f3digo limpio y bien estructurado es m\u00e1s f\u00e1cil de leer y entender. Esto facilita la colaboraci\u00f3n entre equipos de desarrollo y permite a los desarrolladores comprender r\u00e1pidamente lo que hace cada parte del c\u00f3digo. Facilita el Mantenimiento: Un c\u00f3digo desorganizado es propenso a errores y dif\u00edcil de mantener. La refactorizaci\u00f3n ayuda a eliminar duplicaciones, simplificar l\u00f3gica compleja y mejorar la cohesi\u00f3n del c\u00f3digo, lo que facilita el mantenimiento a largo plazo. Aumenta la Eficiencia: La refactorizaci\u00f3n puede conducir a mejoras en el rendimiento y la eficiencia del c\u00f3digo. La eliminaci\u00f3n de c\u00f3digo duplicado y la optimizaci\u00f3n de algoritmos pueden acelerar las aplicaciones. Facilita la Escalabilidad: Un c\u00f3digo bien refactorizado es m\u00e1s f\u00e1cil de ampliar y extender para satisfacer nuevos requisitos. Esto es especialmente importante en proyectos en constante evoluci\u00f3n. Reduce el Riesgo de Errores: Al refactorizar el c\u00f3digo, los desarrolladores tienen la oportunidad de identificar y corregir errores potenciales antes de que se conviertan en problemas reales. Mejora la Calidad del Software: La refactorizaci\u00f3n es una pr\u00e1ctica clave para mantener la calidad del software a lo largo del tiempo. Ayuda a reducir la acumulaci\u00f3n de deuda t\u00e9cnica y a mantener el c\u00f3digo limpio y ordenado.","title":"Por qu\u00e9 es Necesaria la Refactorizaci\u00f3n"},{"location":"programming/refactoring/#casos-de-uso-de-la-refactorizacion-en-python","text":"A continuaci\u00f3n, exploraremos algunos casos de uso comunes de refactorizaci\u00f3n en Python junto con ejemplos pr\u00e1cticos.","title":"Casos de Uso de la Refactorizaci\u00f3n en Python"},{"location":"programming/refactoring/#1-eliminacion-de-codigo-duplicado","text":"Uno de los problemas m\u00e1s comunes en el desarrollo de software es la duplicaci\u00f3n de c\u00f3digo. Esto no solo aumenta la longitud del c\u00f3digo, sino que tambi\u00e9n hace que el mantenimiento sea m\u00e1s dif\u00edcil, ya que cualquier cambio debe realizarse en varios lugares. La refactorizaci\u00f3n puede ayudar a eliminar c\u00f3digo duplicado y mantener el c\u00f3digo base m\u00e1s limpio. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una funci\u00f3n que calcula el \u00e1rea de un rect\u00e1ngulo y otra que calcula el \u00e1rea de un cuadrado. Ambas funciones son muy similares, pero el cuadrado es solo un caso especial de un rect\u00e1ngulo. Podemos refactorizar el c\u00f3digo de la siguiente manera: # Versi\u00f3n original def area_rectangulo ( base , altura ): return base * altura def area_cuadrado ( lado ): return lado * lado # Refactorizaci\u00f3n def area_rectangulo ( base , altura ): return base * altura def area_cuadrado ( lado ): return area_rectangulo ( lado , lado )","title":"1. Eliminaci\u00f3n de C\u00f3digo Duplicado"},{"location":"programming/refactoring/#2-simplificacion-de-expresiones-condicionales","text":"Las expresiones condicionales complejas pueden dificultar la comprensi\u00f3n del c\u00f3digo. La refactorizaci\u00f3n puede ayudar a simplificar estas expresiones y hacer que el c\u00f3digo sea m\u00e1s legible. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una expresi\u00f3n condicional compleja para determinar si una persona es elegible para un descuento. La refactorizaci\u00f3n puede simplificar la expresi\u00f3n de la siguiente manera: # Versi\u00f3n original if edad >= 18 and edad <= 65 and ingresos_anuales >= 20000 : es_elegible = True else : es_elegible = False # Refactorizaci\u00f3n es_elegible = 18 <= edad <= 65 and ingresos_anuales >= 20000","title":"2. Simplificaci\u00f3n de Expresiones Condicionales"},{"location":"programming/refactoring/#3-extraccion-de-funciones","text":"Cuando una funci\u00f3n realiza m\u00faltiples tareas o es demasiado larga, puede ser \u00fatil dividirla en funciones m\u00e1s peque\u00f1as y espec\u00edficas. Esto mejora la cohesi\u00f3n del c\u00f3digo y facilita su comprensi\u00f3n. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una funci\u00f3n que valida un formulario web, realiza c\u00e1lculos y env\u00eda un correo electr\u00f3nico. Podemos refactorizarla de la siguiente manera: # Versi\u00f3n original def procesar_formulario ( formulario ): if validar_formulario ( formulario ): datos = extraer_datos ( formulario ) calcular_resultados ( datos ) enviar_correo_electronico ( datos ) # Refactorizaci\u00f3n def procesar_formulario ( formulario ): if validar_formulario ( formulario ): datos = extraer_datos ( formulario ) realizar_calculos ( datos ) enviar_correo_electronico ( datos ) def realizar_calculos ( datos ): calcular_resultados ( datos )","title":"3. Extracci\u00f3n de Funciones"},{"location":"programming/refactoring/#4-uso-de-list-comprehensions","text":"Las list comprehensions son una caracter\u00edstica poderosa de Python que permite crear listas de manera concisa. Refactorizar bucles tradicionales en list comprehensions puede hacer que el c\u00f3digo sea m\u00e1s legible y eficiente. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una lista de n\u00fameros y queremos crear una nueva lista que contenga el cuadrado de cada n\u00famero. Podemos refactorizar un bucle for de la siguiente manera: # Versi\u00f3n original numeros = [ 1 , 2 , 3 , 4 , 5 ] cuadrados = [] for numero in numeros : cuadrados . append ( numero ** 2 ) # Refactorizaci\u00f3n numeros = [ 1 , 2 , 3 , 4 , 5 ] cuadrados = [ numero ** 2 for numero in numeros ]","title":"4. Uso de List Comprehensions"},{"location":"programming/refactoring/#5-nombres-de-variables-significativos","text":"Utilizar nombres de variables descriptivos es fundamental para la legibilidad del c\u00f3digo. La refactorizaci\u00f3n puede implicar cambiar nombres de variables a versiones m\u00e1s significativas. Ejemplo Pr\u00e1ctico: Supongamos que tenemos una variable llamada x que representa el tiempo en segundos. Podemos refactorizarla para que el c\u00f3digo sea m\u00e1s claro: # Versi\u00f3n original x = 3600 # Representa el n\u00famero de segundos en una hora # Refactorizaci\u00f3n segundos_en_una_hora = 3600","title":"5. Nombres de Variables Significativos"},{"location":"programming/refactoring/#referencias-y-recursos","text":"A medida que exploras y practicas la refactorizaci\u00f3n de c\u00f3digo en Python, aqu\u00ed tienes algunas referencias y recursos adicionales que te ser\u00e1n \u00fatiles: Refactoring: Improving the Design of Existing Code : El libro cl\u00e1sico de Martin Fowler sobre refactorizaci\u00f3n. The Pragmatic Programmer's Guide to Refactoring : Un libro pr\u00e1ctico sobre refactorizaci\u00f3n. PEP 8 -- Style Guide for Python Code : El PEP que define las convenciones de estilo de c\u00f3digo en Python. Refactoring.Guru : Un recurso en l\u00ednea que ofrece ejemplos y explicaciones detalladas de patrones de refactorizaci\u00f3n. pyrefactor : Una herramienta de refactorizaci\u00f3n para Python.","title":"Referencias y Recursos"},{"location":"programming/refactoring/#conclusion","text":"La refactorizaci\u00f3n de c\u00f3digo es una habilidad esencial para cualquier desarrollador de Python. Permite mejorar la calidad del c\u00f3digo, facilita su mantenimiento y contribuye a un desarrollo m\u00e1s eficiente y escalable. Al comprender los casos de uso comunes de refactorizaci\u00f3n y practicar con ejemplos reales, estar\u00e1s mejor preparado para escribir c\u00f3digo Python de alta calidad. Recuerda que la refactorizaci\u00f3n es un proceso continuo a lo largo del ciclo de vida del software. A medida que evolucionan los requisitos y se descubren nuevas formas de optimizar el c\u00f3digo, la refactorizaci\u00f3n seguir\u00e1 siendo una parte fundamental del desarrollo de software de calidad.","title":"Conclusi\u00f3n"},{"location":"programming/solid/","text":"S.O.L.I.D. Los Principios SOLID son un conjunto de cinco principios de dise\u00f1o de software que fueron introducidos por Robert C. Martin (tambi\u00e9n conocido como Uncle Bob) en la d\u00e9cada de 1990. Estos principios se han convertido en una gu\u00eda fundamental para escribir c\u00f3digo limpio, mantenible y flexible en la programaci\u00f3n orientada a objetos (POO). A continuaci\u00f3n, exploraremos en detalle cada uno de los principios SOLID, su origen y c\u00f3mo se adaptan a diferentes lenguajes de programaci\u00f3n, incluido Python. 1. Principio de Responsabilidad \u00danica (Single Responsibility Principle - SRP) Origen : El SRP fue propuesto por primera vez por Robert C. Martin en su libro \"Agile Software Development, Principles, Patterns, and Practices\" en 2003. Este principio se basa en la idea de que una clase debe tener una \u00fanica raz\u00f3n para cambiar, es decir, una sola responsabilidad. La motivaci\u00f3n detr\u00e1s de este principio es reducir la complejidad y aumentar la cohesi\u00f3n en el dise\u00f1o del software. Adaptaci\u00f3n en Python : En Python, el SRP se aplica de manera similar a otros lenguajes. Se busca identificar las responsabilidades de una clase y, si tiene m\u00e1s de una, dividirlas en clases separadas. Python permite lograr esto f\u00e1cilmente gracias a su flexibilidad en la definici\u00f3n de clases y la capacidad de componer clases peque\u00f1as y espec\u00edficas. Ejemplo SRP en Python Supongamos que tenemos una clase Empleado que maneja tanto la informaci\u00f3n del empleado como la generaci\u00f3n de informes. Esto violar\u00eda el SRP. En su lugar, podr\u00edamos dividirlo en dos clases: class Empleado : def __init__ ( self , nombre , salario ): self . nombre = nombre self . salario = salario class GeneradorInforme : @staticmethod def generar_informe ( empleado ): # L\u00f3gica para generar el informe pass Al dividir las responsabilidades, facilitamos la modificaci\u00f3n y el mantenimiento de cada clase por separado. 2. Principio Abierto/Cerrado (Open/Closed Principle - OCP) Origen : El OCP fue formulado por Bertrand Meyer en su libro \"Object-Oriented Software Construction\" en 1988 y posteriormente adoptado en los principios SOLID por Uncle Bob. Este principio establece que las entidades de software (clases, m\u00f3dulos, etc.) deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n. En otras palabras, se debe poder agregar nueva funcionalidad sin cambiar el c\u00f3digo existente. Adaptaci\u00f3n en Python : Python permite aplicar el OCP mediante t\u00e9cnicas de herencia y polimorfismo. Al dise\u00f1ar clases y m\u00f3dulos de manera que sean f\u00e1ciles de extender, los desarrolladores pueden agregar nuevas caracter\u00edsticas sin alterar el c\u00f3digo existente. Adem\u00e1s, Python fomenta la creaci\u00f3n de interfaces y abstracciones, lo que facilita la extensi\u00f3n. Ejemplo OCP en Python Supongamos que tenemos una clase Calculadora que realiza operaciones matem\u00e1ticas b\u00e1sicas. En lugar de modificar la clase cada vez que necesitemos agregar una nueva operaci\u00f3n, podemos extenderla: class Calculadora : def calcular ( self , operacion , a , b ): if operacion == 'suma' : return a + b elif operacion == 'resta' : return a - b # M\u00e1s operaciones... # Extender la clase para agregar una nueva operaci\u00f3n class CalculadoraAvanzada ( Calculadora ): def calcular ( self , operacion , a , b ): if operacion == 'multiplicacion' : return a * b # Otras operaciones avanzadas... Al extender la clase en lugar de modificarla, mantenemos la clase original cerrada para modificaciones y abierta para extensiones. 3. Principio de Sustituci\u00f3n de Liskov (Liskov Substitution Principle - LSP) Origen : El LSP lleva el nombre de Barbara Liskov, quien formul\u00f3 este principio en 1987. El LSP establece que los objetos de una subclase deben poder reemplazar sin problemas a los objetos de la clase base sin afectar la integridad del programa. Este principio garantiza la coherencia en la jerarqu\u00eda de clases. Adaptaci\u00f3n en Python : En Python, el LSP se aplica respetando las interfaces y asegurando que las subclases cumplan con las expectativas de las clases base. Aunque Python no tiene tipado est\u00e1tico, sigue siendo importante dise\u00f1ar clases y m\u00e9todos de manera que las subclases puedan ser usadas sin problemas donde se esperan objetos de la clase base. Ejemplo LSP en Python Supongamos que tenemos una clase base Ave y una subclase Avestruz . Seg\u00fan el LSP, deber\u00edamos poder tratar una avestruz como un ave sin problemas: class Ave : def volar ( self ): pass class Avestruz ( Ave ): def volar ( self ): raise Exception ( \"Las avestruces no pueden volar\" ) Aunque las avestruces no pueden volar, la subclase Avestruz a\u00fan cumple con la interfaz definida por la clase base Ave , evitando problemas inesperados en el c\u00f3digo que usa objetos de tipo Ave . 4. Principio de Segregaci\u00f3n de Interfaces (Interface Segregation Principle - ISP) Origen : El ISP tambi\u00e9n fue introducido por Uncle Bob como parte de los principios SOLID. Este principio se basa en la idea de que las interfaces deben ser peque\u00f1as y espec\u00edficas. En lugar de tener interfaces grandes y complejas, se deben crear m\u00faltiples interfaces espec\u00edficas para cada cliente. Adaptaci\u00f3n en Python : Aunque Python no tiene interfaces formales como algunos lenguajes est\u00e1ticos, se puede aplicar el ISP dividiendo las responsabilidades en clases o mixins espec\u00edficos. Python permite componer objetos de manera flexible, lo que facilita la implementaci\u00f3n de interfaces segregadas. Ejemplo ISP en Python Supongamos que tenemos una interfaz Trabajador que define m\u00e9todos para trabajar en diferentes tareas. En lugar de tener una sola interfaz grande, podemos dividirla en interfaces m\u00e1s peque\u00f1as y espec\u00edficas: class Trabajador : def trabajar ( self ): pass class TrabajadorManual ( Trabajador ): def trabajar ( self ): # Realizar trabajo manual pass class TrabajadorOficina ( Trabajador ): def trabajar ( self ): # Realizar trabajo de oficina pass De esta manera, las clases que implementan TrabajadorManual no est\u00e1n obligadas a implementar m\u00e9todos relacionados con el trabajo de oficina. 5. Principio de Inversi\u00f3n de Dependencia (Dependency Inversion Principle - DIP) Origen : El DIP es otro principio propuesto por Uncle Bob. Este principio establece que los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel, sino que ambos deben depender de abstracciones. Adem\u00e1s, las abstracciones no deben depender de detalles, sino que los detalles deben depender de abstracciones. Adaptaci\u00f3n en Python : Python facilita la inversi\u00f3n de dependencias mediante la inyecci\u00f3n de dependencias y la programaci\u00f3n orientada a objetos. Los desarrolladores pueden dise\u00f1ar sus clases de manera que dependan de abstracciones en lugar de implementaciones concretas, lo que facilita la sustituci\u00f3n y la prueba de componentes. Ejemplo DIP en Python Supongamos que tenemos una clase Luz que depende de una clase Interruptor . Siguiendo el DIP, podemos invertir la dependencia mediante el uso de abstracciones: from abc import ABC , abstractmethod class Interruptor ( ABC ): @abstractmethod def encender ( self ): pass @abstractmethod def apagar ( self ): pass class Luz : def __init__ ( self , interruptor : Interruptor ): self . interruptor = interruptor def encender ( self ): self . interruptor . encender () def apagar ( self ): self . interruptor . apagar () class InterruptorPared ( Interruptor ): def encender ( self ): # L\u00f3gica para encender el interruptor de pared pass def apagar ( self ): # L\u00f3gica para apagar el interruptor de pared pass Ahora, la clase Luz depende de la abstracci\u00f3n Interruptor , y diferentes tipos de interruptores pueden implementar esa abstracci\u00f3n sin afectar la clase Luz . Supongamos que tenemos una clase Luz que depende de una clase Interruptor . Siguiendo el DIP, podemos invertir la dependencia mediante el uso de abstracciones: from abc import ABC , abstractmethod class Interruptor ( ABC ): @abstractmethod def encender ( self ): pass @abstractmethod def apagar ( self ): pass class Luz : def __init__ ( self , interruptor : Interruptor ): self . interruptor = interruptor def encender ( self ): self . interruptor . encender () def apagar ( self ): self . interruptor . apagar () class InterruptorPared ( Interruptor ): def encender ( self ): # L\u00f3gica para encender el interruptor de pared pass def apagar ( self ): # L\u00f3gica para apagar el interruptor de pared pass Ahora, la clase Luz depende de la abstracci\u00f3n Interruptor , y diferentes tipos de interruptores pueden implementar esa abstracci\u00f3n sin afectar la clase Luz . Conclusiones En resumen, los principios SOLID son fundamentales para el dise\u00f1o de software robusto y se pueden aplicar de manera efectiva en Python y otros lenguajes de programaci\u00f3n. Estos principios promueven la modularidad, la flexibilidad y la mantenibilidad del c\u00f3digo, lo que es esencial para desarrollar aplicaciones de alta calidad en cualquier lenguaje. Al comprender y aplicar estos principios, los desarrolladores pueden escribir software m\u00e1s limpio y menos propenso a errores.","title":"S.O.L.I.D."},{"location":"programming/solid/#solid","text":"Los Principios SOLID son un conjunto de cinco principios de dise\u00f1o de software que fueron introducidos por Robert C. Martin (tambi\u00e9n conocido como Uncle Bob) en la d\u00e9cada de 1990. Estos principios se han convertido en una gu\u00eda fundamental para escribir c\u00f3digo limpio, mantenible y flexible en la programaci\u00f3n orientada a objetos (POO). A continuaci\u00f3n, exploraremos en detalle cada uno de los principios SOLID, su origen y c\u00f3mo se adaptan a diferentes lenguajes de programaci\u00f3n, incluido Python.","title":"S.O.L.I.D."},{"location":"programming/solid/#1-principio-de-responsabilidad-unica-single-responsibility-principle-srp","text":"Origen : El SRP fue propuesto por primera vez por Robert C. Martin en su libro \"Agile Software Development, Principles, Patterns, and Practices\" en 2003. Este principio se basa en la idea de que una clase debe tener una \u00fanica raz\u00f3n para cambiar, es decir, una sola responsabilidad. La motivaci\u00f3n detr\u00e1s de este principio es reducir la complejidad y aumentar la cohesi\u00f3n en el dise\u00f1o del software. Adaptaci\u00f3n en Python : En Python, el SRP se aplica de manera similar a otros lenguajes. Se busca identificar las responsabilidades de una clase y, si tiene m\u00e1s de una, dividirlas en clases separadas. Python permite lograr esto f\u00e1cilmente gracias a su flexibilidad en la definici\u00f3n de clases y la capacidad de componer clases peque\u00f1as y espec\u00edficas. Ejemplo SRP en Python Supongamos que tenemos una clase Empleado que maneja tanto la informaci\u00f3n del empleado como la generaci\u00f3n de informes. Esto violar\u00eda el SRP. En su lugar, podr\u00edamos dividirlo en dos clases: class Empleado : def __init__ ( self , nombre , salario ): self . nombre = nombre self . salario = salario class GeneradorInforme : @staticmethod def generar_informe ( empleado ): # L\u00f3gica para generar el informe pass Al dividir las responsabilidades, facilitamos la modificaci\u00f3n y el mantenimiento de cada clase por separado.","title":"1. Principio de Responsabilidad \u00danica (Single Responsibility Principle - SRP)"},{"location":"programming/solid/#2-principio-abiertocerrado-openclosed-principle-ocp","text":"Origen : El OCP fue formulado por Bertrand Meyer en su libro \"Object-Oriented Software Construction\" en 1988 y posteriormente adoptado en los principios SOLID por Uncle Bob. Este principio establece que las entidades de software (clases, m\u00f3dulos, etc.) deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n. En otras palabras, se debe poder agregar nueva funcionalidad sin cambiar el c\u00f3digo existente. Adaptaci\u00f3n en Python : Python permite aplicar el OCP mediante t\u00e9cnicas de herencia y polimorfismo. Al dise\u00f1ar clases y m\u00f3dulos de manera que sean f\u00e1ciles de extender, los desarrolladores pueden agregar nuevas caracter\u00edsticas sin alterar el c\u00f3digo existente. Adem\u00e1s, Python fomenta la creaci\u00f3n de interfaces y abstracciones, lo que facilita la extensi\u00f3n. Ejemplo OCP en Python Supongamos que tenemos una clase Calculadora que realiza operaciones matem\u00e1ticas b\u00e1sicas. En lugar de modificar la clase cada vez que necesitemos agregar una nueva operaci\u00f3n, podemos extenderla: class Calculadora : def calcular ( self , operacion , a , b ): if operacion == 'suma' : return a + b elif operacion == 'resta' : return a - b # M\u00e1s operaciones... # Extender la clase para agregar una nueva operaci\u00f3n class CalculadoraAvanzada ( Calculadora ): def calcular ( self , operacion , a , b ): if operacion == 'multiplicacion' : return a * b # Otras operaciones avanzadas... Al extender la clase en lugar de modificarla, mantenemos la clase original cerrada para modificaciones y abierta para extensiones.","title":"2. Principio Abierto/Cerrado (Open/Closed Principle - OCP)"},{"location":"programming/solid/#3-principio-de-sustitucion-de-liskov-liskov-substitution-principle-lsp","text":"Origen : El LSP lleva el nombre de Barbara Liskov, quien formul\u00f3 este principio en 1987. El LSP establece que los objetos de una subclase deben poder reemplazar sin problemas a los objetos de la clase base sin afectar la integridad del programa. Este principio garantiza la coherencia en la jerarqu\u00eda de clases. Adaptaci\u00f3n en Python : En Python, el LSP se aplica respetando las interfaces y asegurando que las subclases cumplan con las expectativas de las clases base. Aunque Python no tiene tipado est\u00e1tico, sigue siendo importante dise\u00f1ar clases y m\u00e9todos de manera que las subclases puedan ser usadas sin problemas donde se esperan objetos de la clase base. Ejemplo LSP en Python Supongamos que tenemos una clase base Ave y una subclase Avestruz . Seg\u00fan el LSP, deber\u00edamos poder tratar una avestruz como un ave sin problemas: class Ave : def volar ( self ): pass class Avestruz ( Ave ): def volar ( self ): raise Exception ( \"Las avestruces no pueden volar\" ) Aunque las avestruces no pueden volar, la subclase Avestruz a\u00fan cumple con la interfaz definida por la clase base Ave , evitando problemas inesperados en el c\u00f3digo que usa objetos de tipo Ave .","title":"3. Principio de Sustituci\u00f3n de Liskov (Liskov Substitution Principle - LSP)"},{"location":"programming/solid/#4-principio-de-segregacion-de-interfaces-interface-segregation-principle-isp","text":"Origen : El ISP tambi\u00e9n fue introducido por Uncle Bob como parte de los principios SOLID. Este principio se basa en la idea de que las interfaces deben ser peque\u00f1as y espec\u00edficas. En lugar de tener interfaces grandes y complejas, se deben crear m\u00faltiples interfaces espec\u00edficas para cada cliente. Adaptaci\u00f3n en Python : Aunque Python no tiene interfaces formales como algunos lenguajes est\u00e1ticos, se puede aplicar el ISP dividiendo las responsabilidades en clases o mixins espec\u00edficos. Python permite componer objetos de manera flexible, lo que facilita la implementaci\u00f3n de interfaces segregadas. Ejemplo ISP en Python Supongamos que tenemos una interfaz Trabajador que define m\u00e9todos para trabajar en diferentes tareas. En lugar de tener una sola interfaz grande, podemos dividirla en interfaces m\u00e1s peque\u00f1as y espec\u00edficas: class Trabajador : def trabajar ( self ): pass class TrabajadorManual ( Trabajador ): def trabajar ( self ): # Realizar trabajo manual pass class TrabajadorOficina ( Trabajador ): def trabajar ( self ): # Realizar trabajo de oficina pass De esta manera, las clases que implementan TrabajadorManual no est\u00e1n obligadas a implementar m\u00e9todos relacionados con el trabajo de oficina.","title":"4. Principio de Segregaci\u00f3n de Interfaces (Interface Segregation Principle - ISP)"},{"location":"programming/solid/#5-principio-de-inversion-de-dependencia-dependency-inversion-principle-dip","text":"Origen : El DIP es otro principio propuesto por Uncle Bob. Este principio establece que los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel, sino que ambos deben depender de abstracciones. Adem\u00e1s, las abstracciones no deben depender de detalles, sino que los detalles deben depender de abstracciones. Adaptaci\u00f3n en Python : Python facilita la inversi\u00f3n de dependencias mediante la inyecci\u00f3n de dependencias y la programaci\u00f3n orientada a objetos. Los desarrolladores pueden dise\u00f1ar sus clases de manera que dependan de abstracciones en lugar de implementaciones concretas, lo que facilita la sustituci\u00f3n y la prueba de componentes. Ejemplo DIP en Python Supongamos que tenemos una clase Luz que depende de una clase Interruptor . Siguiendo el DIP, podemos invertir la dependencia mediante el uso de abstracciones: from abc import ABC , abstractmethod class Interruptor ( ABC ): @abstractmethod def encender ( self ): pass @abstractmethod def apagar ( self ): pass class Luz : def __init__ ( self , interruptor : Interruptor ): self . interruptor = interruptor def encender ( self ): self . interruptor . encender () def apagar ( self ): self . interruptor . apagar () class InterruptorPared ( Interruptor ): def encender ( self ): # L\u00f3gica para encender el interruptor de pared pass def apagar ( self ): # L\u00f3gica para apagar el interruptor de pared pass Ahora, la clase Luz depende de la abstracci\u00f3n Interruptor , y diferentes tipos de interruptores pueden implementar esa abstracci\u00f3n sin afectar la clase Luz . Supongamos que tenemos una clase Luz que depende de una clase Interruptor . Siguiendo el DIP, podemos invertir la dependencia mediante el uso de abstracciones: from abc import ABC , abstractmethod class Interruptor ( ABC ): @abstractmethod def encender ( self ): pass @abstractmethod def apagar ( self ): pass class Luz : def __init__ ( self , interruptor : Interruptor ): self . interruptor = interruptor def encender ( self ): self . interruptor . encender () def apagar ( self ): self . interruptor . apagar () class InterruptorPared ( Interruptor ): def encender ( self ): # L\u00f3gica para encender el interruptor de pared pass def apagar ( self ): # L\u00f3gica para apagar el interruptor de pared pass Ahora, la clase Luz depende de la abstracci\u00f3n Interruptor , y diferentes tipos de interruptores pueden implementar esa abstracci\u00f3n sin afectar la clase Luz .","title":"5. Principio de Inversi\u00f3n de Dependencia (Dependency Inversion Principle - DIP)"},{"location":"programming/solid/#conclusiones","text":"En resumen, los principios SOLID son fundamentales para el dise\u00f1o de software robusto y se pueden aplicar de manera efectiva en Python y otros lenguajes de programaci\u00f3n. Estos principios promueven la modularidad, la flexibilidad y la mantenibilidad del c\u00f3digo, lo que es esencial para desarrollar aplicaciones de alta calidad en cualquier lenguaje. Al comprender y aplicar estos principios, los desarrolladores pueden escribir software m\u00e1s limpio y menos propenso a errores.","title":"Conclusiones"},{"location":"setup/poetry/","text":"Poetry: Gesti\u00f3n de Dependencias Poetry es una herramienta revolucionaria para la gesti\u00f3n de dependencias y el empaquetado en Python. Con Poetry, declarar las bibliotecas en las que tu proyecto depende es sencillo, y Poetry se encargar\u00e1 de administrar la instalaci\u00f3n y actualizaci\u00f3n de esas dependencias por ti. Instalaci\u00f3n de Poetry Para instalar Poetry de forma aislada y segura en tu sistema, sigue estos pasos: macOS / Linux / bash en Windows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python - Windows PowerShell ( Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing ) .Content | python - Creaci\u00f3n de un Proyecto con Poetry Poetry no solo facilita la gesti\u00f3n de dependencias, sino que tambi\u00e9n agiliza la estructuraci\u00f3n de proyectos Python. Puedes crear un nuevo proyecto desde cero de la siguiente manera: poetry new poetry-tutorial-project Esta simple l\u00ednea de comandos generar\u00e1 una estructura de carpetas est\u00e1ndar para tu proyecto, incluyendo un archivo pyproject.toml , que es fundamental en la configuraci\u00f3n de tu proyecto. Configuraci\u00f3n Centralizada El archivo pyproject.toml es el n\u00facleo de la configuraci\u00f3n de tu proyecto con Poetry. Puedes definir metadatos, dependencias, scripts y m\u00e1s en este archivo. A continuaci\u00f3n, mostramos un ejemplo completo: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Esta configuraci\u00f3n incluye metadatos, dependencias, scripts y enlaces \u00fatiles para tu proyecto. Referencia: Documentaci\u00f3n oficial de Poetry - pyproject.toml Uso de la CLI de Poetry La interfaz de l\u00ednea de comandos (CLI) de Poetry simplifica la gesti\u00f3n de dependencias y la administraci\u00f3n de proyectos. Aqu\u00ed tienes algunas tareas comunes: poetry shell : Crea y activa un entorno virtual para tu proyecto. Esto a\u00edsla las dependencias de tu proyecto del sistema y otros proyectos. poetry install : Instala las dependencias especificadas en el archivo pyproject.toml . Las versiones reales se registran en el archivo poetry.lock . poetry update : Actualiza las dependencias de acuerdo con las versiones especificadas en pyproject.toml . El archivo poetry.lock se actualiza. poetry add [nombre-del-paquete] : Agrega una nueva dependencia a tu proyecto y la instala autom\u00e1ticamente. poetry remove [nombre-del-paquete] : Elimina una dependencia de tu proyecto. poetry export -f requirements.txt > requirements.txt : Exporta las dependencias y versiones de tu proyecto en formato requirements.txt para casos de uso espec\u00edficos. Poetry simplifica significativamente la gesti\u00f3n de dependencias y la administraci\u00f3n de proyectos Python, lo que permite una experiencia de desarrollo m\u00e1s eficiente y organizada. Referencia: Documentaci\u00f3n oficial de Poetry - Comandos En resumen, Poetry es una herramienta imprescindible para el desarrollo de proyectos Python. Facilita la gesti\u00f3n de dependencias, la organizaci\u00f3n de proyectos y el empaquetado, simplificando muchas tareas comunes. \u00a1Explora m\u00e1s sobre Poetry y \u00fasalo para mejorar tu flujo de trabajo de desarrollo en Python!","title":"Poetry"},{"location":"setup/poetry/#poetry-gestion-de-dependencias","text":"Poetry es una herramienta revolucionaria para la gesti\u00f3n de dependencias y el empaquetado en Python. Con Poetry, declarar las bibliotecas en las que tu proyecto depende es sencillo, y Poetry se encargar\u00e1 de administrar la instalaci\u00f3n y actualizaci\u00f3n de esas dependencias por ti.","title":"Poetry: Gesti\u00f3n de Dependencias"},{"location":"setup/poetry/#instalacion-de-poetry","text":"Para instalar Poetry de forma aislada y segura en tu sistema, sigue estos pasos:","title":"Instalaci\u00f3n de Poetry"},{"location":"setup/poetry/#macos-linux-bash-en-windows","text":"curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -","title":"macOS / Linux / bash en Windows"},{"location":"setup/poetry/#windows-powershell","text":"( Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing ) .Content | python -","title":"Windows PowerShell"},{"location":"setup/poetry/#creacion-de-un-proyecto-con-poetry","text":"Poetry no solo facilita la gesti\u00f3n de dependencias, sino que tambi\u00e9n agiliza la estructuraci\u00f3n de proyectos Python. Puedes crear un nuevo proyecto desde cero de la siguiente manera: poetry new poetry-tutorial-project Esta simple l\u00ednea de comandos generar\u00e1 una estructura de carpetas est\u00e1ndar para tu proyecto, incluyendo un archivo pyproject.toml , que es fundamental en la configuraci\u00f3n de tu proyecto.","title":"Creaci\u00f3n de un Proyecto con Poetry"},{"location":"setup/poetry/#configuracion-centralizada","text":"El archivo pyproject.toml es el n\u00facleo de la configuraci\u00f3n de tu proyecto con Poetry. Puedes definir metadatos, dependencias, scripts y m\u00e1s en este archivo. A continuaci\u00f3n, mostramos un ejemplo completo: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Esta configuraci\u00f3n incluye metadatos, dependencias, scripts y enlaces \u00fatiles para tu proyecto. Referencia: Documentaci\u00f3n oficial de Poetry - pyproject.toml","title":"Configuraci\u00f3n Centralizada"},{"location":"setup/poetry/#uso-de-la-cli-de-poetry","text":"La interfaz de l\u00ednea de comandos (CLI) de Poetry simplifica la gesti\u00f3n de dependencias y la administraci\u00f3n de proyectos. Aqu\u00ed tienes algunas tareas comunes: poetry shell : Crea y activa un entorno virtual para tu proyecto. Esto a\u00edsla las dependencias de tu proyecto del sistema y otros proyectos. poetry install : Instala las dependencias especificadas en el archivo pyproject.toml . Las versiones reales se registran en el archivo poetry.lock . poetry update : Actualiza las dependencias de acuerdo con las versiones especificadas en pyproject.toml . El archivo poetry.lock se actualiza. poetry add [nombre-del-paquete] : Agrega una nueva dependencia a tu proyecto y la instala autom\u00e1ticamente. poetry remove [nombre-del-paquete] : Elimina una dependencia de tu proyecto. poetry export -f requirements.txt > requirements.txt : Exporta las dependencias y versiones de tu proyecto en formato requirements.txt para casos de uso espec\u00edficos. Poetry simplifica significativamente la gesti\u00f3n de dependencias y la administraci\u00f3n de proyectos Python, lo que permite una experiencia de desarrollo m\u00e1s eficiente y organizada. Referencia: Documentaci\u00f3n oficial de Poetry - Comandos En resumen, Poetry es una herramienta imprescindible para el desarrollo de proyectos Python. Facilita la gesti\u00f3n de dependencias, la organizaci\u00f3n de proyectos y el empaquetado, simplificando muchas tareas comunes. \u00a1Explora m\u00e1s sobre Poetry y \u00fasalo para mejorar tu flujo de trabajo de desarrollo en Python!","title":"Uso de la CLI de Poetry"},{"location":"setup/pyenv/","text":"Pyenv: Gesti\u00f3n de Versiones Introducci\u00f3n El entorno de desarrollo en Python es diverso y vers\u00e1til, pero tambi\u00e9n presenta desaf\u00edos, especialmente cuando se trata de la gesti\u00f3n de las versiones de Python y las dependencias. Al instalar un sistema operativo, es com\u00fan encontrarse con una versi\u00f3n de Python preexistente, a menudo denominada \"System Python\", que es fundamental para el funcionamiento del sistema operativo. Modificar esta instalaci\u00f3n puede ser riesgoso y desaconsejable, ya que podr\u00eda afectar el funcionamiento del sistema en su conjunto. Adem\u00e1s, en el desarrollo de software en Python, es probable que necesitemos trabajar con versiones espec\u00edficas de Python que no coincidan con la preinstalada en el sistema operativo. Esto es esencial cuando se desarrollan proyectos que deben ser compatibles con m\u00faltiples versiones de Python. Es aqu\u00ed donde entra en juego Pyenv , una herramienta esencial para cualquier desarrollador de Python. \u00bfQu\u00e9 es Pyenv y por qu\u00e9 es importante? Pyenv es una poderosa herramienta que resuelve ambos problemas mencionados. Permite instalar y gestionar m\u00faltiples versiones de Python de forma segura y aislada en su propio entorno. Esto significa que puedes utilizar la versi\u00f3n espec\u00edfica de Python que necesitas para cada proyecto sin preocuparte por afectar el \"System Python\". Pyenv tambi\u00e9n es \u00fatil para probar tu c\u00f3digo en diferentes versiones de Python de manera simult\u00e1nea. Instalaci\u00f3n La instalaci\u00f3n de Pyenv es sencilla y altamente recomendada para cualquier desarrollador de Python. Para usuarios de Linux y Mac, se proporciona una gu\u00eda detallada que te ayudar\u00e1 a configurar los pre-requisitos necesarios antes de usar pyenv-installer para instalar Pyenv en tu sistema. Uso Una vez que tienes Pyenv instalado, puedes aprovechar sus funcionalidades de la siguiente manera: Instalaci\u00f3n de Versiones de Python : Utiliza el comando pyenv install <VERSION> para instalar la versi\u00f3n espec\u00edfica de Python que necesitas para tu proyecto. Exploraci\u00f3n de Versiones Disponibles : Puedes ver la lista de versiones de Python disponibles para instalaci\u00f3n utilizando pyenv install -l . La variedad es amplia, desde Miniconda y Anaconda hasta Cython, Pypy y Jython. Recomendaciones Configura Pyenv como tu versi\u00f3n de Python por defecto ejecutando pyenv global <VERSION> . Esto asegurar\u00e1 que siempre utilices la versi\u00f3n deseada, a menos que especifiques lo contrario. Para la gesti\u00f3n de entornos virtuales, considera herramientas como Poetry o Pipenv, que funcionan de manera excelente junto a Pyenv. En resumen, Pyenv es una herramienta imprescindible para cualquier desarrollador de Python que desee mantener su entorno de desarrollo limpio y seguro, gestionar m\u00faltiples versiones de Python de manera efectiva y asegurarse de que sus proyectos funcionen de manera consistente en diferentes entornos. Simplifica tu experiencia de desarrollo con Pyenv y desbloquea todo el potencial de Python en tu trayectoria como desarrollador.","title":"Pyenv"},{"location":"setup/pyenv/#pyenv-gestion-de-versiones","text":"","title":"Pyenv: Gesti\u00f3n de Versiones"},{"location":"setup/pyenv/#introduccion","text":"El entorno de desarrollo en Python es diverso y vers\u00e1til, pero tambi\u00e9n presenta desaf\u00edos, especialmente cuando se trata de la gesti\u00f3n de las versiones de Python y las dependencias. Al instalar un sistema operativo, es com\u00fan encontrarse con una versi\u00f3n de Python preexistente, a menudo denominada \"System Python\", que es fundamental para el funcionamiento del sistema operativo. Modificar esta instalaci\u00f3n puede ser riesgoso y desaconsejable, ya que podr\u00eda afectar el funcionamiento del sistema en su conjunto. Adem\u00e1s, en el desarrollo de software en Python, es probable que necesitemos trabajar con versiones espec\u00edficas de Python que no coincidan con la preinstalada en el sistema operativo. Esto es esencial cuando se desarrollan proyectos que deben ser compatibles con m\u00faltiples versiones de Python. Es aqu\u00ed donde entra en juego Pyenv , una herramienta esencial para cualquier desarrollador de Python.","title":"Introducci\u00f3n"},{"location":"setup/pyenv/#que-es-pyenv-y-por-que-es-importante","text":"Pyenv es una poderosa herramienta que resuelve ambos problemas mencionados. Permite instalar y gestionar m\u00faltiples versiones de Python de forma segura y aislada en su propio entorno. Esto significa que puedes utilizar la versi\u00f3n espec\u00edfica de Python que necesitas para cada proyecto sin preocuparte por afectar el \"System Python\". Pyenv tambi\u00e9n es \u00fatil para probar tu c\u00f3digo en diferentes versiones de Python de manera simult\u00e1nea.","title":"\u00bfQu\u00e9 es Pyenv y por qu\u00e9 es importante?"},{"location":"setup/pyenv/#instalacion","text":"La instalaci\u00f3n de Pyenv es sencilla y altamente recomendada para cualquier desarrollador de Python. Para usuarios de Linux y Mac, se proporciona una gu\u00eda detallada que te ayudar\u00e1 a configurar los pre-requisitos necesarios antes de usar pyenv-installer para instalar Pyenv en tu sistema.","title":"Instalaci\u00f3n"},{"location":"setup/pyenv/#uso","text":"Una vez que tienes Pyenv instalado, puedes aprovechar sus funcionalidades de la siguiente manera: Instalaci\u00f3n de Versiones de Python : Utiliza el comando pyenv install <VERSION> para instalar la versi\u00f3n espec\u00edfica de Python que necesitas para tu proyecto. Exploraci\u00f3n de Versiones Disponibles : Puedes ver la lista de versiones de Python disponibles para instalaci\u00f3n utilizando pyenv install -l . La variedad es amplia, desde Miniconda y Anaconda hasta Cython, Pypy y Jython.","title":"Uso"},{"location":"setup/pyenv/#recomendaciones","text":"Configura Pyenv como tu versi\u00f3n de Python por defecto ejecutando pyenv global <VERSION> . Esto asegurar\u00e1 que siempre utilices la versi\u00f3n deseada, a menos que especifiques lo contrario. Para la gesti\u00f3n de entornos virtuales, considera herramientas como Poetry o Pipenv, que funcionan de manera excelente junto a Pyenv. En resumen, Pyenv es una herramienta imprescindible para cualquier desarrollador de Python que desee mantener su entorno de desarrollo limpio y seguro, gestionar m\u00faltiples versiones de Python de manera efectiva y asegurarse de que sus proyectos funcionen de manera consistente en diferentes entornos. Simplifica tu experiencia de desarrollo con Pyenv y desbloquea todo el potencial de Python en tu trayectoria como desarrollador.","title":"Recomendaciones"},{"location":"setup/virtualenv/","text":"Ambientes Virtuales (Venv) Introducci\u00f3n El desarrollo de software en Python a menudo implica trabajar en una variedad de proyectos, cada uno con sus propias dependencias y versiones de bibliotecas. Para mantener un entorno de desarrollo limpio, organizado y aislado, Python ofrece ambientes virtuales , y uno de los enfoques m\u00e1s comunes es utilizar la herramienta Venv . En este documento, exploraremos la importancia de los ambientes virtuales, c\u00f3mo trabajar con ellos de manera efectiva, y proporcionaremos enlaces a recursos adicionales para un aprendizaje m\u00e1s profundo. \u00bfQu\u00e9 es un Ambiente Virtual y por qu\u00e9 son Importantes? Un ambiente virtual es un espacio aislado en el que puedes instalar bibliotecas, paquetes y versiones espec\u00edficas de Python para un proyecto en particular. Esto evita conflictos entre diferentes proyectos que requieren versiones diferentes de las mismas bibliotecas y garantiza que cada proyecto tenga su propio entorno limpio y funcional. Referencia: Documentaci\u00f3n oficial de Venv Creaci\u00f3n de un Ambiente Virtual con Venv La herramienta venv es una biblioteca est\u00e1ndar de Python que te permite crear ambientes virtuales f\u00e1cilmente. Aqu\u00ed hay un ejemplo sencillo de c\u00f3mo crear y activar un ambiente virtual utilizando Venv: Crear un Directorio para tu Proyecto : Abre una terminal y crea un directorio para tu proyecto (si a\u00fan no lo has hecho). mkdir mi_proyecto cd mi_proyecto Crear el Ambiente Virtual : Ejecuta el siguiente comando para crear un ambiente virtual llamado mi_entorno : python -m venv mi_entorno Activar el Ambiente Virtual : Dependiendo de tu sistema operativo, activa el ambiente virtual con uno de los siguientes comandos: En Linux/macOS: source mi_entorno/bin/activate En Windows: mi_entorno \\S cripts \\a ctivate Ahora, tu terminal deber\u00eda mostrar el nombre del ambiente virtual activo en el indicador de comando, lo que indica que est\u00e1s trabajando dentro de ese ambiente aislado. Trabajando en un Ambiente Virtual Dentro de un ambiente virtual, puedes instalar bibliotecas y paquetes espec\u00edficos utilizando pip , sin afectar al Python del sistema ni a otros ambientes virtuales. Aqu\u00ed hay un ejemplo: Instalar una Biblioteca : Supongamos que deseas instalar la biblioteca requests en tu ambiente virtual. Simplemente ejecuta: pip install requests Verificar las Bibliotecas Instaladas : Puedes ver las bibliotecas instaladas en tu ambiente virtual con: pip list Desactivar el Ambiente Virtual : Cuando hayas terminado de trabajar en tu proyecto, puedes desactivar el ambiente virtual con: deactivate Beneficios de los Ambientes Virtuales Aislamiento : Los ambientes virtuales evitan conflictos entre proyectos al mantener las dependencias separadas. Organizaci\u00f3n : Facilitan la organizaci\u00f3n de tus proyectos y la gesti\u00f3n de las versiones de las bibliotecas. Reproducibilidad : Garantizan que otros desarrolladores puedan reproducir tu entorno de desarrollo. Referencia: Python Virtual Environments: A Primer En resumen, los ambientes virtuales con Venv son una herramienta esencial en el desarrollo de software en Python. Permiten trabajar de manera ordenada, aislada y eficiente, asegurando que cada proyecto tenga su propio entorno controlado. Esta pr\u00e1ctica es especialmente valiosa cuando trabajas en varios proyectos de Python a la vez, lo que te permite mantener la sanidad de tu entorno de desarrollo. \u00a1Explora m\u00e1s sobre los ambientes virtuales y \u00fasalos para potenciar tu desarrollo de Python!","title":"Venv"},{"location":"setup/virtualenv/#ambientes-virtuales-venv","text":"","title":"Ambientes Virtuales (Venv)"},{"location":"setup/virtualenv/#introduccion","text":"El desarrollo de software en Python a menudo implica trabajar en una variedad de proyectos, cada uno con sus propias dependencias y versiones de bibliotecas. Para mantener un entorno de desarrollo limpio, organizado y aislado, Python ofrece ambientes virtuales , y uno de los enfoques m\u00e1s comunes es utilizar la herramienta Venv . En este documento, exploraremos la importancia de los ambientes virtuales, c\u00f3mo trabajar con ellos de manera efectiva, y proporcionaremos enlaces a recursos adicionales para un aprendizaje m\u00e1s profundo.","title":"Introducci\u00f3n"},{"location":"setup/virtualenv/#que-es-un-ambiente-virtual-y-por-que-son-importantes","text":"Un ambiente virtual es un espacio aislado en el que puedes instalar bibliotecas, paquetes y versiones espec\u00edficas de Python para un proyecto en particular. Esto evita conflictos entre diferentes proyectos que requieren versiones diferentes de las mismas bibliotecas y garantiza que cada proyecto tenga su propio entorno limpio y funcional. Referencia: Documentaci\u00f3n oficial de Venv","title":"\u00bfQu\u00e9 es un Ambiente Virtual y por qu\u00e9 son Importantes?"},{"location":"setup/virtualenv/#creacion-de-un-ambiente-virtual-con-venv","text":"La herramienta venv es una biblioteca est\u00e1ndar de Python que te permite crear ambientes virtuales f\u00e1cilmente. Aqu\u00ed hay un ejemplo sencillo de c\u00f3mo crear y activar un ambiente virtual utilizando Venv: Crear un Directorio para tu Proyecto : Abre una terminal y crea un directorio para tu proyecto (si a\u00fan no lo has hecho). mkdir mi_proyecto cd mi_proyecto Crear el Ambiente Virtual : Ejecuta el siguiente comando para crear un ambiente virtual llamado mi_entorno : python -m venv mi_entorno Activar el Ambiente Virtual : Dependiendo de tu sistema operativo, activa el ambiente virtual con uno de los siguientes comandos: En Linux/macOS: source mi_entorno/bin/activate En Windows: mi_entorno \\S cripts \\a ctivate Ahora, tu terminal deber\u00eda mostrar el nombre del ambiente virtual activo en el indicador de comando, lo que indica que est\u00e1s trabajando dentro de ese ambiente aislado.","title":"Creaci\u00f3n de un Ambiente Virtual con Venv"},{"location":"setup/virtualenv/#trabajando-en-un-ambiente-virtual","text":"Dentro de un ambiente virtual, puedes instalar bibliotecas y paquetes espec\u00edficos utilizando pip , sin afectar al Python del sistema ni a otros ambientes virtuales. Aqu\u00ed hay un ejemplo: Instalar una Biblioteca : Supongamos que deseas instalar la biblioteca requests en tu ambiente virtual. Simplemente ejecuta: pip install requests Verificar las Bibliotecas Instaladas : Puedes ver las bibliotecas instaladas en tu ambiente virtual con: pip list Desactivar el Ambiente Virtual : Cuando hayas terminado de trabajar en tu proyecto, puedes desactivar el ambiente virtual con: deactivate","title":"Trabajando en un Ambiente Virtual"},{"location":"setup/virtualenv/#beneficios-de-los-ambientes-virtuales","text":"Aislamiento : Los ambientes virtuales evitan conflictos entre proyectos al mantener las dependencias separadas. Organizaci\u00f3n : Facilitan la organizaci\u00f3n de tus proyectos y la gesti\u00f3n de las versiones de las bibliotecas. Reproducibilidad : Garantizan que otros desarrolladores puedan reproducir tu entorno de desarrollo. Referencia: Python Virtual Environments: A Primer En resumen, los ambientes virtuales con Venv son una herramienta esencial en el desarrollo de software en Python. Permiten trabajar de manera ordenada, aislada y eficiente, asegurando que cada proyecto tenga su propio entorno controlado. Esta pr\u00e1ctica es especialmente valiosa cuando trabajas en varios proyectos de Python a la vez, lo que te permite mantener la sanidad de tu entorno de desarrollo. \u00a1Explora m\u00e1s sobre los ambientes virtuales y \u00fasalos para potenciar tu desarrollo de Python!","title":"Beneficios de los Ambientes Virtuales"},{"location":"testing/coverage/","text":"Coverage La cobertura de c\u00f3digo es una pr\u00e1ctica esencial en el desarrollo de software que permite evaluar qu\u00e9 parte de su c\u00f3digo fuente se ha ejecutado durante la ejecuci\u00f3n de pruebas. Cuanto mayor sea la cobertura, mayor ser\u00e1 la confianza en la calidad de su c\u00f3digo. En esta gu\u00eda, exploraremos en detalle qu\u00e9 es la cobertura de c\u00f3digo y c\u00f3mo se puede medir utilizando Pytest, una herramienta popular en el mundo de las pruebas de Python. \u00bfQu\u00e9 es la Cobertura de C\u00f3digo? La cobertura de c\u00f3digo es una medida que cuantifica la proporci\u00f3n del c\u00f3digo fuente que se ha ejecutado al menos una vez durante la ejecuci\u00f3n de las pruebas. En otras palabras, proporciona una idea de qu\u00e9 partes de su c\u00f3digo han sido \"visitadas\" por las pruebas y qu\u00e9 partes a\u00fan no se han examinado. Una alta cobertura de c\u00f3digo no garantiza que su software sea libre de errores, pero ofrece varias ventajas clave: Identificaci\u00f3n de C\u00f3digo No Utilizado : La cobertura de c\u00f3digo puede revelar partes de su c\u00f3digo que no se utilizan y, por lo tanto, pueden eliminarse o refactorizarse para mejorar la eficiencia. Detecci\u00f3n Temprana de Problemas : Al medir la cobertura de c\u00f3digo, puede descubrir \u00e1reas del c\u00f3digo que no se prueban adecuadamente y, por lo tanto, tienen un mayor riesgo de contener errores. Confianza en las Pruebas : Una alta cobertura de c\u00f3digo proporciona una mayor confianza en la efectividad de sus pruebas. Si las pruebas han recorrido la mayor\u00eda de las rutas de su c\u00f3digo, es m\u00e1s probable que detecten problemas. Documentaci\u00f3n Impl\u00edcita : La cobertura de c\u00f3digo puede servir como documentaci\u00f3n impl\u00edcita al mostrar qu\u00e9 partes del c\u00f3digo son esenciales y se han probado. Cobertura de C\u00f3digo con Pytest Pytest es un marco de prueba popular para Python que se integra bien con herramientas de cobertura de c\u00f3digo como coverage.py . A continuaci\u00f3n, veremos c\u00f3mo configurar y utilizar Pytest para medir la cobertura de c\u00f3digo. Configuraci\u00f3n Inicial Antes de comenzar a medir la cobertura de c\u00f3digo con Pytest, aseg\u00farese de tener instalados los siguientes componentes: Pytest : Instale Pytest utilizando pip si a\u00fan no lo ha hecho: pip install pytest Coverage.py : Instale la herramienta de cobertura de c\u00f3digo coverage.py: pip install coverage Ejecuci\u00f3n de Pruebas con Cobertura de C\u00f3digo Para medir la cobertura de c\u00f3digo con Pytest y coverage.py , siga estos pasos: Escriba sus pruebas : Cree las pruebas unitarias para su c\u00f3digo utilizando Pytest. Aseg\u00farese de tener pruebas que cubran diferentes aspectos de su c\u00f3digo. Ejecute Pytest con Coverage.py : Utilice el comando coverage run para ejecutar Pytest y medir la cobertura de c\u00f3digo. Reemplace your_test_file.py con el nombre de su archivo de pruebas. coverage run -m pytest your_test_file.py Genere un Informe de Cobertura : Despu\u00e9s de ejecutar sus pruebas, use coverage report para generar un informe detallado de la cobertura de c\u00f3digo. coverage report -m El informe de cobertura mostrar\u00e1 qu\u00e9 porcentaje del c\u00f3digo fuente se ha ejecutado durante las pruebas. Tambi\u00e9n proporcionar\u00e1 informaci\u00f3n sobre qu\u00e9 l\u00edneas de c\u00f3digo se han ejecutado y cu\u00e1les no. Ejemplo de Cobertura de C\u00f3digo con Pytest Para ilustrar c\u00f3mo funciona la cobertura de c\u00f3digo con Pytest, consideremos un ejemplo simple. Supongamos que tenemos una funci\u00f3n en un m\u00f3dulo llamado math_operations.py que realiza operaciones matem\u00e1ticas b\u00e1sicas: # math_operations.py def add ( a , b ): return a + b def subtract ( a , b ): return a - b Ahora, escribiremos pruebas para estas funciones en un archivo llamado test_math_operations.py : # test_math_operations.py import math_operations def test_add (): result = math_operations . add ( 2 , 3 ) assert result == 5 def test_subtract (): result = math_operations . subtract ( 5 , 3 ) assert result == 2 Luego, ejecutaremos Pytest con Coverage.py para medir la cobertura de c\u00f3digo: coverage run -m pytest test_math_operations.py Finalmente, generaremos un informe de cobertura: coverage report -m El informe mostrar\u00e1 el porcentaje de cobertura de c\u00f3digo y resaltar\u00e1 las l\u00edneas que se han ejecutado (en verde) y las que no (en rojo). Esto proporciona una visi\u00f3n clara de las \u00e1reas de su c\u00f3digo que necesitan m\u00e1s pruebas. Conclusiones La cobertura de c\u00f3digo es una pr\u00e1ctica fundamental en el desarrollo de software que ayuda a garantizar que su c\u00f3digo sea robusto y libre de errores. Pytest y coverage.py son herramientas poderosas que facilitan la medici\u00f3n de la cobertura de c\u00f3digo en proyectos de Python. Al utilizar Pytest junto con coverage.py , puede escribir pruebas efectivas y tener una visi\u00f3n clara de qu\u00e9 partes de su c\u00f3digo necesitan una cobertura adicional. Esto conduce a un c\u00f3digo m\u00e1s confiable y de mayor calidad en sus proyectos de desarrollo de software.","title":"Coverage"},{"location":"testing/coverage/#coverage","text":"La cobertura de c\u00f3digo es una pr\u00e1ctica esencial en el desarrollo de software que permite evaluar qu\u00e9 parte de su c\u00f3digo fuente se ha ejecutado durante la ejecuci\u00f3n de pruebas. Cuanto mayor sea la cobertura, mayor ser\u00e1 la confianza en la calidad de su c\u00f3digo. En esta gu\u00eda, exploraremos en detalle qu\u00e9 es la cobertura de c\u00f3digo y c\u00f3mo se puede medir utilizando Pytest, una herramienta popular en el mundo de las pruebas de Python.","title":"Coverage"},{"location":"testing/coverage/#que-es-la-cobertura-de-codigo","text":"La cobertura de c\u00f3digo es una medida que cuantifica la proporci\u00f3n del c\u00f3digo fuente que se ha ejecutado al menos una vez durante la ejecuci\u00f3n de las pruebas. En otras palabras, proporciona una idea de qu\u00e9 partes de su c\u00f3digo han sido \"visitadas\" por las pruebas y qu\u00e9 partes a\u00fan no se han examinado. Una alta cobertura de c\u00f3digo no garantiza que su software sea libre de errores, pero ofrece varias ventajas clave: Identificaci\u00f3n de C\u00f3digo No Utilizado : La cobertura de c\u00f3digo puede revelar partes de su c\u00f3digo que no se utilizan y, por lo tanto, pueden eliminarse o refactorizarse para mejorar la eficiencia. Detecci\u00f3n Temprana de Problemas : Al medir la cobertura de c\u00f3digo, puede descubrir \u00e1reas del c\u00f3digo que no se prueban adecuadamente y, por lo tanto, tienen un mayor riesgo de contener errores. Confianza en las Pruebas : Una alta cobertura de c\u00f3digo proporciona una mayor confianza en la efectividad de sus pruebas. Si las pruebas han recorrido la mayor\u00eda de las rutas de su c\u00f3digo, es m\u00e1s probable que detecten problemas. Documentaci\u00f3n Impl\u00edcita : La cobertura de c\u00f3digo puede servir como documentaci\u00f3n impl\u00edcita al mostrar qu\u00e9 partes del c\u00f3digo son esenciales y se han probado.","title":"\u00bfQu\u00e9 es la Cobertura de C\u00f3digo?"},{"location":"testing/coverage/#cobertura-de-codigo-con-pytest","text":"Pytest es un marco de prueba popular para Python que se integra bien con herramientas de cobertura de c\u00f3digo como coverage.py . A continuaci\u00f3n, veremos c\u00f3mo configurar y utilizar Pytest para medir la cobertura de c\u00f3digo.","title":"Cobertura de C\u00f3digo con Pytest"},{"location":"testing/coverage/#configuracion-inicial","text":"Antes de comenzar a medir la cobertura de c\u00f3digo con Pytest, aseg\u00farese de tener instalados los siguientes componentes: Pytest : Instale Pytest utilizando pip si a\u00fan no lo ha hecho: pip install pytest Coverage.py : Instale la herramienta de cobertura de c\u00f3digo coverage.py: pip install coverage","title":"Configuraci\u00f3n Inicial"},{"location":"testing/coverage/#ejecucion-de-pruebas-con-cobertura-de-codigo","text":"Para medir la cobertura de c\u00f3digo con Pytest y coverage.py , siga estos pasos: Escriba sus pruebas : Cree las pruebas unitarias para su c\u00f3digo utilizando Pytest. Aseg\u00farese de tener pruebas que cubran diferentes aspectos de su c\u00f3digo. Ejecute Pytest con Coverage.py : Utilice el comando coverage run para ejecutar Pytest y medir la cobertura de c\u00f3digo. Reemplace your_test_file.py con el nombre de su archivo de pruebas. coverage run -m pytest your_test_file.py Genere un Informe de Cobertura : Despu\u00e9s de ejecutar sus pruebas, use coverage report para generar un informe detallado de la cobertura de c\u00f3digo. coverage report -m El informe de cobertura mostrar\u00e1 qu\u00e9 porcentaje del c\u00f3digo fuente se ha ejecutado durante las pruebas. Tambi\u00e9n proporcionar\u00e1 informaci\u00f3n sobre qu\u00e9 l\u00edneas de c\u00f3digo se han ejecutado y cu\u00e1les no.","title":"Ejecuci\u00f3n de Pruebas con Cobertura de C\u00f3digo"},{"location":"testing/coverage/#ejemplo-de-cobertura-de-codigo-con-pytest","text":"Para ilustrar c\u00f3mo funciona la cobertura de c\u00f3digo con Pytest, consideremos un ejemplo simple. Supongamos que tenemos una funci\u00f3n en un m\u00f3dulo llamado math_operations.py que realiza operaciones matem\u00e1ticas b\u00e1sicas: # math_operations.py def add ( a , b ): return a + b def subtract ( a , b ): return a - b Ahora, escribiremos pruebas para estas funciones en un archivo llamado test_math_operations.py : # test_math_operations.py import math_operations def test_add (): result = math_operations . add ( 2 , 3 ) assert result == 5 def test_subtract (): result = math_operations . subtract ( 5 , 3 ) assert result == 2 Luego, ejecutaremos Pytest con Coverage.py para medir la cobertura de c\u00f3digo: coverage run -m pytest test_math_operations.py Finalmente, generaremos un informe de cobertura: coverage report -m El informe mostrar\u00e1 el porcentaje de cobertura de c\u00f3digo y resaltar\u00e1 las l\u00edneas que se han ejecutado (en verde) y las que no (en rojo). Esto proporciona una visi\u00f3n clara de las \u00e1reas de su c\u00f3digo que necesitan m\u00e1s pruebas.","title":"Ejemplo de Cobertura de C\u00f3digo con Pytest"},{"location":"testing/coverage/#conclusiones","text":"La cobertura de c\u00f3digo es una pr\u00e1ctica fundamental en el desarrollo de software que ayuda a garantizar que su c\u00f3digo sea robusto y libre de errores. Pytest y coverage.py son herramientas poderosas que facilitan la medici\u00f3n de la cobertura de c\u00f3digo en proyectos de Python. Al utilizar Pytest junto con coverage.py , puede escribir pruebas efectivas y tener una visi\u00f3n clara de qu\u00e9 partes de su c\u00f3digo necesitan una cobertura adicional. Esto conduce a un c\u00f3digo m\u00e1s confiable y de mayor calidad en sus proyectos de desarrollo de software.","title":"Conclusiones"},{"location":"testing/hypothesis/","text":"Hypothesis Introducci\u00f3n Cuando escribes pruebas unitarias, es dif\u00edcil estar seguro de que has cubierto todos los casos de prueba posibles. Puedes pensar en algunos casos obvios, pero es f\u00e1cil pasar por alto casos extremos o situaciones inesperadas. El Property-based Testing (Pruebas basadas en propiedades) es una t\u00e9cnica de prueba que aborda este problema al permitirte definir propiedades generales que tu c\u00f3digo debe cumplir y luego generar autom\u00e1ticamente una amplia variedad de casos de prueba para verificar esas propiedades. En lugar de escribir casos de prueba espec\u00edficos uno por uno, el Property-based Testing utiliza la generaci\u00f3n autom\u00e1tica de datos de prueba y las propiedades declarativas para evaluar la calidad de tu c\u00f3digo. Esto ayuda a descubrir errores inesperados y a probar una variedad m\u00e1s amplia de escenarios que las pruebas tradicionales. En Python, una de las bibliotecas m\u00e1s populares para realizar Property-based Testing es Hypothesis . Hypothesis: Una visi\u00f3n general Hypothesis es una poderosa biblioteca de Property-based Testing para Python. Ofrece una amplia gama de estrategias de generaci\u00f3n de datos y se integra bien con los sistemas de prueba existentes, como pytest. Ejemplo: Factorizaci\u00f3n de enteros Para ilustrar c\u00f3mo funciona Hypothesis en la pr\u00e1ctica, consideremos un ejemplo simple: la factorizaci\u00f3n de enteros. Supongamos que tenemos una funci\u00f3n factorize(n: int) -> List[int] que toma un n\u00famero entero n y devuelve una lista de sus factores primos. Vamos a explorar c\u00f3mo podemos usar Hypothesis para probar esta funci\u00f3n. from typing import List import math def factorize ( number : int ) -> List [ int ]: if number in [ - 1 , 0 , 1 ]: return [ number ] if number < 0 : return [ - 1 ] + factorize ( - number ) factors = [] while number % 2 == 0 : factors . append ( 2 ) number = number // 2 if number == 1 : return factors i = 3 while i <= int ( math . ceil ( number ** 0.5 )) + 1 : while number % i == 0 : factors . append ( i ) number = number // i i += 2 return factors Escribiendo pruebas unitarias tradicionales Enfoqu\u00e9monos primero en escribir pruebas unitarias tradicionales para nuestra funci\u00f3n factorize . Aqu\u00ed hay algunas pruebas de ejemplo utilizando el m\u00f3dulo unittest : import unittest class TestFactorize ( unittest . TestCase ): def test_factorize_zero ( self ): self . assertEqual ( factorize ( 0 ), [ 0 ]) def test_factorize_one ( self ): self . assertEqual ( factorize ( 1 ), [ 1 ]) def test_factorize_negative ( self ): self . assertEqual ( factorize ( - 1 ), [ - 1 ]) def test_factorize_negative_prime ( self ): self . assertEqual ( factorize ( - 2 ), [ - 1 , 2 ]) def test_factorize_prime ( self ): self . assertEqual ( factorize ( 2 ), [ 2 ]) def test_factorize_another_prime ( self ): self . assertEqual ( factorize ( 3 ), [ 3 ]) def test_factorize_multiple_primes ( self ): self . assertEqual ( factorize ( 6 ), [ 2 , 3 ]) def test_factorize_same_prime_multiple_times ( self ): self . assertEqual ( factorize ( 8 ), [ 2 , 2 , 2 ]) if __name__ == '__main__' : unittest . main () Estas pruebas son espec\u00edficas y est\u00e1n dise\u00f1adas para casos de entrada particulares. A medida que aumenta la complejidad de la funci\u00f3n, escribir pruebas unitarias tradicionales para todos los casos posibles puede volverse tedioso y propenso a errores. Escribiendo pruebas basadas en propiedades con Hypothesis Ahora, veamos c\u00f3mo podemos usar Hypothesis para escribir pruebas basadas en propiedades para la funci\u00f3n factorize . Definiremos una propiedad que deber\u00eda cumplir esta funci\u00f3n: el producto de los factores primos devueltos debe ser igual al n\u00famero original. import hypothesis.strategies as st from hypothesis import given @given ( st . integers ( min_value =- ( 10 ** 6 ), max_value = 10 ** 6 )) def test_factorize_property ( n ): factors = factorize ( n ) product = 1 for factor in factors : product *= factor assert product == n , f \"factorize( { n } ) returned { factors } \" En este c\u00f3digo: Utilizamos la decoraci\u00f3n @given de Hypothesis para declarar una propiedad de prueba. Usamos la estrategia st.integers para generar enteros en un rango razonable de -1,000,000 a 1,000,000, lo que nos permite probar una amplia gama de valores. Luego, dentro de la prueba, factorizamos el n\u00famero y calculamos el producto de los factores primos. Comparamos el producto con el n\u00famero original y afirmamos que deben ser iguales. Ejecutando pruebas con Hypothesis Para ejecutar las pruebas con Hypothesis, simplemente usamos un comando de prueba como pytest : pytest nombre_del_archivo_de_prueba.py Hypothesis generar\u00e1 autom\u00e1ticamente un conjunto diverso de ejemplos para probar nuestra propiedad. Si encuentra un caso que no cumple con la propiedad, lo informar\u00e1, lo que nos ayudar\u00e1 a encontrar errores en nuestra funci\u00f3n factorize . Beneficios de Property-based Testing con Hypothesis Property-based Testing con Hypothesis ofrece varios beneficios: Cobertura exhaustiva : Genera autom\u00e1ticamente una amplia gama de casos de prueba, lo que puede revelar problemas que no se encuentran en las pruebas tradicionales. Identificaci\u00f3n de errores inesperados : Puede descubrir errores que no hab\u00edas considerado al probar casos espec\u00edficos. Refactorizaci\u00f3n segura : Cuando refactorizas o cambias el c\u00f3digo, Hypothesis puede ayudarte a asegurarte de que las propiedades fundamentales de tu c\u00f3digo a\u00fan se mantengan. Ahorro de tiempo : Escritura menos pruebas espec\u00edficas y m\u00e1s pruebas basadas en propiedades puede ahorrar tiempo en la escritura y mantenimiento de pruebas. Facilita la exploraci\u00f3n de esquinas y casos l\u00edmite : Puedes probar casos que nunca habr\u00edas pens ado en escribir manualmente. Conclusiones Property-based Testing con Hypothesis es una t\u00e9cnica poderosa para mejorar la calidad de tus pruebas y encontrar errores dif\u00edciles de detectar. A medida que tu c\u00f3digo crece en complejidad, las pruebas basadas en propiedades pueden convertirse en una parte esencial de tu proceso de desarrollo. Recuerda que, aunque Hypothesis puede ayudarte a encontrar problemas, a\u00fan es importante usar tu juicio y experiencia para interpretar los resultados de las pruebas y corregir los errores de manera adecuada. Adem\u00e1s, investiga m\u00e1s sobre Hypothesis y sus estrategias de generaci\u00f3n de datos para aprovechar al m\u00e1ximo esta valiosa herramienta de pruebas. Referencias Documentaci\u00f3n oficial de Hypothesis Propiedades y generaci\u00f3n de datos con Hypothesis Estrategias de generaci\u00f3n de datos en Hypothesis Introducci\u00f3n a Property-based Testing con Python y Hypothesis Property-Based Testing in Python with Hypothesis","title":"Hypothesis"},{"location":"testing/hypothesis/#hypothesis","text":"","title":"Hypothesis"},{"location":"testing/hypothesis/#introduccion","text":"Cuando escribes pruebas unitarias, es dif\u00edcil estar seguro de que has cubierto todos los casos de prueba posibles. Puedes pensar en algunos casos obvios, pero es f\u00e1cil pasar por alto casos extremos o situaciones inesperadas. El Property-based Testing (Pruebas basadas en propiedades) es una t\u00e9cnica de prueba que aborda este problema al permitirte definir propiedades generales que tu c\u00f3digo debe cumplir y luego generar autom\u00e1ticamente una amplia variedad de casos de prueba para verificar esas propiedades. En lugar de escribir casos de prueba espec\u00edficos uno por uno, el Property-based Testing utiliza la generaci\u00f3n autom\u00e1tica de datos de prueba y las propiedades declarativas para evaluar la calidad de tu c\u00f3digo. Esto ayuda a descubrir errores inesperados y a probar una variedad m\u00e1s amplia de escenarios que las pruebas tradicionales. En Python, una de las bibliotecas m\u00e1s populares para realizar Property-based Testing es Hypothesis .","title":"Introducci\u00f3n"},{"location":"testing/hypothesis/#hypothesis-una-vision-general","text":"Hypothesis es una poderosa biblioteca de Property-based Testing para Python. Ofrece una amplia gama de estrategias de generaci\u00f3n de datos y se integra bien con los sistemas de prueba existentes, como pytest.","title":"Hypothesis: Una visi\u00f3n general"},{"location":"testing/hypothesis/#ejemplo-factorizacion-de-enteros","text":"Para ilustrar c\u00f3mo funciona Hypothesis en la pr\u00e1ctica, consideremos un ejemplo simple: la factorizaci\u00f3n de enteros. Supongamos que tenemos una funci\u00f3n factorize(n: int) -> List[int] que toma un n\u00famero entero n y devuelve una lista de sus factores primos. Vamos a explorar c\u00f3mo podemos usar Hypothesis para probar esta funci\u00f3n. from typing import List import math def factorize ( number : int ) -> List [ int ]: if number in [ - 1 , 0 , 1 ]: return [ number ] if number < 0 : return [ - 1 ] + factorize ( - number ) factors = [] while number % 2 == 0 : factors . append ( 2 ) number = number // 2 if number == 1 : return factors i = 3 while i <= int ( math . ceil ( number ** 0.5 )) + 1 : while number % i == 0 : factors . append ( i ) number = number // i i += 2 return factors","title":"Ejemplo: Factorizaci\u00f3n de enteros"},{"location":"testing/hypothesis/#escribiendo-pruebas-unitarias-tradicionales","text":"Enfoqu\u00e9monos primero en escribir pruebas unitarias tradicionales para nuestra funci\u00f3n factorize . Aqu\u00ed hay algunas pruebas de ejemplo utilizando el m\u00f3dulo unittest : import unittest class TestFactorize ( unittest . TestCase ): def test_factorize_zero ( self ): self . assertEqual ( factorize ( 0 ), [ 0 ]) def test_factorize_one ( self ): self . assertEqual ( factorize ( 1 ), [ 1 ]) def test_factorize_negative ( self ): self . assertEqual ( factorize ( - 1 ), [ - 1 ]) def test_factorize_negative_prime ( self ): self . assertEqual ( factorize ( - 2 ), [ - 1 , 2 ]) def test_factorize_prime ( self ): self . assertEqual ( factorize ( 2 ), [ 2 ]) def test_factorize_another_prime ( self ): self . assertEqual ( factorize ( 3 ), [ 3 ]) def test_factorize_multiple_primes ( self ): self . assertEqual ( factorize ( 6 ), [ 2 , 3 ]) def test_factorize_same_prime_multiple_times ( self ): self . assertEqual ( factorize ( 8 ), [ 2 , 2 , 2 ]) if __name__ == '__main__' : unittest . main () Estas pruebas son espec\u00edficas y est\u00e1n dise\u00f1adas para casos de entrada particulares. A medida que aumenta la complejidad de la funci\u00f3n, escribir pruebas unitarias tradicionales para todos los casos posibles puede volverse tedioso y propenso a errores.","title":"Escribiendo pruebas unitarias tradicionales"},{"location":"testing/hypothesis/#escribiendo-pruebas-basadas-en-propiedades-con-hypothesis","text":"Ahora, veamos c\u00f3mo podemos usar Hypothesis para escribir pruebas basadas en propiedades para la funci\u00f3n factorize . Definiremos una propiedad que deber\u00eda cumplir esta funci\u00f3n: el producto de los factores primos devueltos debe ser igual al n\u00famero original. import hypothesis.strategies as st from hypothesis import given @given ( st . integers ( min_value =- ( 10 ** 6 ), max_value = 10 ** 6 )) def test_factorize_property ( n ): factors = factorize ( n ) product = 1 for factor in factors : product *= factor assert product == n , f \"factorize( { n } ) returned { factors } \" En este c\u00f3digo: Utilizamos la decoraci\u00f3n @given de Hypothesis para declarar una propiedad de prueba. Usamos la estrategia st.integers para generar enteros en un rango razonable de -1,000,000 a 1,000,000, lo que nos permite probar una amplia gama de valores. Luego, dentro de la prueba, factorizamos el n\u00famero y calculamos el producto de los factores primos. Comparamos el producto con el n\u00famero original y afirmamos que deben ser iguales.","title":"Escribiendo pruebas basadas en propiedades con Hypothesis"},{"location":"testing/hypothesis/#ejecutando-pruebas-con-hypothesis","text":"Para ejecutar las pruebas con Hypothesis, simplemente usamos un comando de prueba como pytest : pytest nombre_del_archivo_de_prueba.py Hypothesis generar\u00e1 autom\u00e1ticamente un conjunto diverso de ejemplos para probar nuestra propiedad. Si encuentra un caso que no cumple con la propiedad, lo informar\u00e1, lo que nos ayudar\u00e1 a encontrar errores en nuestra funci\u00f3n factorize .","title":"Ejecutando pruebas con Hypothesis"},{"location":"testing/hypothesis/#beneficios-de-property-based-testing-con-hypothesis","text":"Property-based Testing con Hypothesis ofrece varios beneficios: Cobertura exhaustiva : Genera autom\u00e1ticamente una amplia gama de casos de prueba, lo que puede revelar problemas que no se encuentran en las pruebas tradicionales. Identificaci\u00f3n de errores inesperados : Puede descubrir errores que no hab\u00edas considerado al probar casos espec\u00edficos. Refactorizaci\u00f3n segura : Cuando refactorizas o cambias el c\u00f3digo, Hypothesis puede ayudarte a asegurarte de que las propiedades fundamentales de tu c\u00f3digo a\u00fan se mantengan. Ahorro de tiempo : Escritura menos pruebas espec\u00edficas y m\u00e1s pruebas basadas en propiedades puede ahorrar tiempo en la escritura y mantenimiento de pruebas. Facilita la exploraci\u00f3n de esquinas y casos l\u00edmite : Puedes probar casos que nunca habr\u00edas pens ado en escribir manualmente.","title":"Beneficios de Property-based Testing con Hypothesis"},{"location":"testing/hypothesis/#conclusiones","text":"Property-based Testing con Hypothesis es una t\u00e9cnica poderosa para mejorar la calidad de tus pruebas y encontrar errores dif\u00edciles de detectar. A medida que tu c\u00f3digo crece en complejidad, las pruebas basadas en propiedades pueden convertirse en una parte esencial de tu proceso de desarrollo. Recuerda que, aunque Hypothesis puede ayudarte a encontrar problemas, a\u00fan es importante usar tu juicio y experiencia para interpretar los resultados de las pruebas y corregir los errores de manera adecuada. Adem\u00e1s, investiga m\u00e1s sobre Hypothesis y sus estrategias de generaci\u00f3n de datos para aprovechar al m\u00e1ximo esta valiosa herramienta de pruebas.","title":"Conclusiones"},{"location":"testing/hypothesis/#referencias","text":"Documentaci\u00f3n oficial de Hypothesis Propiedades y generaci\u00f3n de datos con Hypothesis Estrategias de generaci\u00f3n de datos en Hypothesis Introducci\u00f3n a Property-based Testing con Python y Hypothesis Property-Based Testing in Python with Hypothesis","title":"Referencias"},{"location":"testing/intro/","text":"Introducci\u00f3n \u00bfQu\u00e9 es el Test Driven Development ? En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el coraz\u00f3n de nuestro trabajo. En su forma m\u00e1s simple consiste en un proceso iterativo de 3 fases: Red : Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla Green : Escribe el c\u00f3digo m\u00ednimo necesario para pasar ese test Refactor : Refactoriza de ser necesario Ejemplo sencillo A modo de ejemplo, vamos a testear la funci\u00f3n paridad , que determina si un n\u00famero natural es par o no. Lo primero que se debe hacer es crear el test, para ello se ocupar\u00e1 la librer\u00eda pytest . Nota : No es necesario conocer previamente la librer\u00eda pytest para entender el ejemplo. @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected El test nos dice que si el input es el n\u00famero 2 , la funci\u00f3n paridad devuelve el output 'par' . C\u00f3mo a\u00fan no hemos escrito la funci\u00f3n, el test fallar\u00e1 ( fase red ). ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py F [100%] ========= 1 failed in 0.14s =============================================== Ahora, se escribe la funci\u00f3n paridad ( fase green ): def paridad ( n : int ) -> str : \"\"\" Determina si un numero natural es par o no. :param n: numero entero :return: 'par' si es el numero es par; 'impar' en otro caso \"\"\" return 'par' if n % 2 == 0 else 'impar' Volvemos a correr el test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py . [100%] ========= 1 passed in 0.06s =============================================== Hemos cometido un descuido a proposito, no hemos testeado el caso si el n\u00famero fuese impar, por lo cual reescribimos el test ( fase refactor ) @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ( 3 , 'impar' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected y corremos nuevamente los test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 2 items temp/test_funcion.py .. [100%] ========= 2 passed in 0.06s =============================================== Listo, nuestra funci\u00f3n paridad ha sido testeado correctamente!. \u00bfPorqu\u00e9 deber\u00eda usarlo? Existen varias razones por las que uno deber\u00eda usar TDD. Entre ellas podemos encontrar: - Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los l\u00edmites del problema y c\u00f3mo podemos resolverlo. Con el tiempo esto ayuda a obtener un dise\u00f1o modular y reusable del c\u00f3digo. - Escribir tests ayuda la forma en que escribimos c\u00f3digo, haci\u00e9ndolo m\u00e1s legible a otros. Sin embargo, no es un acto de altruismo, la mayor\u00eda de las veces ese otro es tu futuro yo. - Verifica que el c\u00f3digo funciona de la manera que se espera, y lo hace de forma autom\u00e1tica. - Te permite realizar refactoring con la certeza de que no has roto nada. - Los tests escritos sirven como documentaci\u00f3n para otros desarrolladores. - Es una pr\u00e1ctica requerida en metodolog\u00edas de desarrollo de software agile . Evidencia emp\u00edrica El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de c\u00f3digo hasta las 155k. Estas son parte de sus conclusiones: Todos los equipos demostraron una baja considerable en la densidad de defectos: 40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. Como todo en la vida, nada es gratis: Incremento del tiempo de desarrollo var\u00eda entre un 15% a 35%. Sin embargo Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantenci\u00f3n reducidos debido al incremento en calidad. Adem\u00e1s, es importante escribir tests junto con la implementaci\u00f3n en peque\u00f1as iteraciones. George y Williams encontraron que escribir tests despu\u00e9s de que la aplicaci\u00f3n est\u00e1 mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y adem\u00e1s la aplicaci\u00f3n se vuelve menos testeable. Otra conclusi\u00f3n interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un dise\u00f1o m\u00e1s simple. \u00bfPuedo usar TDD siempre? No, pero puedes usarlo casi siempre. El an\u00e1lisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementaci\u00f3n v\u00eda testing. Librer\u00edas disponibles Ac\u00e1 listamos algunas librer\u00edas de TDD en Python: unittest : M\u00f3dulo dentro de la librer\u00eda est\u00e1ndar de Python. Permite realizar tests unitarios, de integraci\u00f3n y end to end. doctest : Permite realizar test de la documentaci\u00f3n del c\u00f3digo (ejemplos: Numpy o Pandas ). pytest : Librer\u00eda de testing ampliamente usada en proyectos nuevos de Python. nose : Librer\u00eda que extiende unittest para hacerlo m\u00e1s simple. coverage : Herramienta para medir la cobertura de c\u00f3digo de los proyectos. tox : Herramienta para facilitar el test de una librer\u00eda en diferentes versiones e int\u00e9rpretes de Python. hypothesis : Librer\u00eda para escribir tests v\u00eda reglas que ayuda a encontrar casos borde. behave : Permite utilizar Behavior Driven Development , un proceso de desarrollo derivado del TDD. Knowledge base / Lecturas recomendadas Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , es una buena lectura, sobretodo los consejos que dan en las conclusiones. Google Testing Blog : Poseen varios art\u00edculos sobre c\u00f3mo abordar problemas tipo, buenas pr\u00e1cticas de dise\u00f1o para generar c\u00f3digo testeable, entre otros. En particular destaca la serie Testing on the Toilet . Cualquier art\u00edculo de Martin Fowler sobre testing , empezando por \u00e9ste Design Patterns : Los patrones de dise\u00f1o de software tienen en consideraci\u00f3n que el c\u00f3digo sea testeable .","title":"Introducci\u00f3n"},{"location":"testing/intro/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"testing/intro/#que-es-el-test-driven-development","text":"En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el coraz\u00f3n de nuestro trabajo. En su forma m\u00e1s simple consiste en un proceso iterativo de 3 fases: Red : Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla Green : Escribe el c\u00f3digo m\u00ednimo necesario para pasar ese test Refactor : Refactoriza de ser necesario","title":"\u00bfQu\u00e9 es el Test Driven Development?"},{"location":"testing/intro/#ejemplo-sencillo","text":"A modo de ejemplo, vamos a testear la funci\u00f3n paridad , que determina si un n\u00famero natural es par o no. Lo primero que se debe hacer es crear el test, para ello se ocupar\u00e1 la librer\u00eda pytest . Nota : No es necesario conocer previamente la librer\u00eda pytest para entender el ejemplo. @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected El test nos dice que si el input es el n\u00famero 2 , la funci\u00f3n paridad devuelve el output 'par' . C\u00f3mo a\u00fan no hemos escrito la funci\u00f3n, el test fallar\u00e1 ( fase red ). ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py F [100%] ========= 1 failed in 0.14s =============================================== Ahora, se escribe la funci\u00f3n paridad ( fase green ): def paridad ( n : int ) -> str : \"\"\" Determina si un numero natural es par o no. :param n: numero entero :return: 'par' si es el numero es par; 'impar' en otro caso \"\"\" return 'par' if n % 2 == 0 else 'impar' Volvemos a correr el test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py . [100%] ========= 1 passed in 0.06s =============================================== Hemos cometido un descuido a proposito, no hemos testeado el caso si el n\u00famero fuese impar, por lo cual reescribimos el test ( fase refactor ) @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ( 3 , 'impar' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected y corremos nuevamente los test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 2 items temp/test_funcion.py .. [100%] ========= 2 passed in 0.06s =============================================== Listo, nuestra funci\u00f3n paridad ha sido testeado correctamente!.","title":"Ejemplo sencillo"},{"location":"testing/intro/#porque-deberia-usarlo","text":"Existen varias razones por las que uno deber\u00eda usar TDD. Entre ellas podemos encontrar: - Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los l\u00edmites del problema y c\u00f3mo podemos resolverlo. Con el tiempo esto ayuda a obtener un dise\u00f1o modular y reusable del c\u00f3digo. - Escribir tests ayuda la forma en que escribimos c\u00f3digo, haci\u00e9ndolo m\u00e1s legible a otros. Sin embargo, no es un acto de altruismo, la mayor\u00eda de las veces ese otro es tu futuro yo. - Verifica que el c\u00f3digo funciona de la manera que se espera, y lo hace de forma autom\u00e1tica. - Te permite realizar refactoring con la certeza de que no has roto nada. - Los tests escritos sirven como documentaci\u00f3n para otros desarrolladores. - Es una pr\u00e1ctica requerida en metodolog\u00edas de desarrollo de software agile .","title":"\u00bfPorqu\u00e9 deber\u00eda usarlo?"},{"location":"testing/intro/#evidencia-empirica","text":"El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de c\u00f3digo hasta las 155k. Estas son parte de sus conclusiones: Todos los equipos demostraron una baja considerable en la densidad de defectos: 40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. Como todo en la vida, nada es gratis: Incremento del tiempo de desarrollo var\u00eda entre un 15% a 35%. Sin embargo Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantenci\u00f3n reducidos debido al incremento en calidad. Adem\u00e1s, es importante escribir tests junto con la implementaci\u00f3n en peque\u00f1as iteraciones. George y Williams encontraron que escribir tests despu\u00e9s de que la aplicaci\u00f3n est\u00e1 mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y adem\u00e1s la aplicaci\u00f3n se vuelve menos testeable. Otra conclusi\u00f3n interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un dise\u00f1o m\u00e1s simple.","title":"Evidencia emp\u00edrica"},{"location":"testing/intro/#puedo-usar-tdd-siempre","text":"No, pero puedes usarlo casi siempre. El an\u00e1lisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementaci\u00f3n v\u00eda testing.","title":"\u00bfPuedo usar TDD siempre?"},{"location":"testing/intro/#librerias-disponibles","text":"Ac\u00e1 listamos algunas librer\u00edas de TDD en Python: unittest : M\u00f3dulo dentro de la librer\u00eda est\u00e1ndar de Python. Permite realizar tests unitarios, de integraci\u00f3n y end to end. doctest : Permite realizar test de la documentaci\u00f3n del c\u00f3digo (ejemplos: Numpy o Pandas ). pytest : Librer\u00eda de testing ampliamente usada en proyectos nuevos de Python. nose : Librer\u00eda que extiende unittest para hacerlo m\u00e1s simple. coverage : Herramienta para medir la cobertura de c\u00f3digo de los proyectos. tox : Herramienta para facilitar el test de una librer\u00eda en diferentes versiones e int\u00e9rpretes de Python. hypothesis : Librer\u00eda para escribir tests v\u00eda reglas que ayuda a encontrar casos borde. behave : Permite utilizar Behavior Driven Development , un proceso de desarrollo derivado del TDD.","title":"Librer\u00edas disponibles"},{"location":"testing/intro/#knowledge-base-lecturas-recomendadas","text":"Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , es una buena lectura, sobretodo los consejos que dan en las conclusiones. Google Testing Blog : Poseen varios art\u00edculos sobre c\u00f3mo abordar problemas tipo, buenas pr\u00e1cticas de dise\u00f1o para generar c\u00f3digo testeable, entre otros. En particular destaca la serie Testing on the Toilet . Cualquier art\u00edculo de Martin Fowler sobre testing , empezando por \u00e9ste Design Patterns : Los patrones de dise\u00f1o de software tienen en consideraci\u00f3n que el c\u00f3digo sea testeable .","title":"Knowledge base / Lecturas recomendadas"},{"location":"testing/mocking/","text":"Mocking En el desarrollo de software, las pruebas unitarias son esenciales para garantizar que su c\u00f3digo funcione correctamente. Sin embargo, a menudo es necesario simular o \"burlarse\" de ciertas partes de su c\u00f3digo para probar componentes de manera aislada y controlada. Esto se logra mediante el uso de mocks o \"mocker\" en el contexto de pruebas. En esta gu\u00eda, exploraremos qu\u00e9 es el \"mocking\", c\u00f3mo se aplica en las pruebas unitarias y c\u00f3mo utilizarlo en conjunto con Pytest, un popular marco de pruebas para Python. \u00bfQu\u00e9 es el Mocking en Pruebas Unitarias? El \"mocking\" es una t\u00e9cnica que implica simular el comportamiento de ciertas partes de su c\u00f3digo para probar componentes de manera aislada. En lugar de usar implementaciones reales, se utilizan objetos simulados o \"mocks\" que imitan el comportamiento de los objetos reales, pero de manera controlada. Los \"mocks\" se utilizan principalmente para: Aislar Componentes : Al simular componentes externos, como bases de datos o servicios web, puede aislar la unidad que est\u00e1 probando y evitar que interact\u00fae con componentes reales durante las pruebas. Controlar Comportamientos : Puede especificar el comportamiento deseado de un \"mock\" para que se comporte de una manera particular durante una prueba. Simular Condiciones de Error : Puede simular condiciones de error o excepciones lanzadas por un componente para asegurarse de que su c\u00f3digo maneje adecuadamente estas situaciones. Aplicaci\u00f3n de Mocking con Pytest Pytest es un marco de pruebas popular en Python que ofrece soporte integrado para el \"mocking\" a trav\u00e9s de la biblioteca unittest.mock . A continuaci\u00f3n, veremos c\u00f3mo aplicar el \"mocking\" en pruebas unitarias con Pytest. Configuraci\u00f3n Inicial Antes de comenzar a utilizar \"mocks\" en sus pruebas con Pytest, aseg\u00farese de tener instalado Pytest y la biblioteca unittest.mock (tambi\u00e9n conocida como mock ) si a\u00fan no las ha instalado: pip install pytest pip install pytest-mock Ejemplo de Mocking con Pytest Supongamos que tiene una funci\u00f3n que realiza una solicitud HTTP a una API externa y procesa la respuesta. Desea probar esta funci\u00f3n sin depender de la API real, por lo que utilizar\u00e1 un \"mock\" para simular la solicitud HTTP. Primero, definimos la funci\u00f3n que realiza la solicitud HTTP en un m\u00f3dulo llamado api_client.py : # api_client.py import requests def get_data_from_api ( url ): response = requests . get ( url ) return response . json () Luego, escribiremos una prueba unitaria utilizando Pytest y un \"mock\" para simular la solicitud HTTP. Creamos un archivo de prueba llamado test_api_client.py : # test_api_client.py import pytest from unittest.mock import Mock from api_client import get_data_from_api def test_get_data_from_api ( mocker ): # Creamos un mock de requests.get mock_get = mocker . patch ( 'requests.get' ) # Configuramos el comportamiento del mock mock_get . return_value . json . return_value = { 'data' : 'mocked_data' } # Llamamos a la funci\u00f3n bajo prueba result = get_data_from_api ( 'http://example.com/api/data' ) # Verificamos que se llamara a requests.get con la URL correcta mock_get . assert_called_once_with ( 'http://example.com/api/data' ) # Verificamos que la funci\u00f3n devuelva el valor esperado del mock assert result == { 'data' : 'mocked_data' } En esta prueba: Importamos pytest y unittest.mock (alias mocker ) para usarlos en la prueba. Creamos un \"mock\" de la funci\u00f3n requests.get utilizando mocker.patch . Esto simula la funci\u00f3n get de la biblioteca requests . Configuramos el comportamiento del \"mock\" para que devuelva un valor simulado cuando se llama a json . Esto simula la respuesta de la API. Llamamos a la funci\u00f3n get_data_from_api con la URL, que deber\u00eda utilizar el \"mock\" en lugar de realizar una solicitud real. Verificamos que la funci\u00f3n requests.get se llam\u00f3 una vez con la URL correcta utilizando assert_called_once_with . Finalmente, verificamos que la funci\u00f3n bajo prueba devuelva el valor esperado. Uso Avanzado de Mocking El \"mocking\" con Pytest y unittest.mock permite una variedad de configuraciones avanzadas, como especificar valores de retorno din\u00e1micos, contar cu\u00e1ntas veces se llama una funci\u00f3n y capturar llamadas y argumentos. Por ejemplo, para especificar un valor de retorno din\u00e1mico, puede usar side_effect : # Configurar un mock con un valor de retorno din\u00e1mico mock_get . side_effect = [ Exception ( 'Error 1' ), { 'data' : 'mocked_data' }] Conclusiones El \"mocking\" es una t\u00e9cnica poderosa en las pruebas unitarias que le permite controlar el comportamiento de componentes externos y aislar unidades de c\u00f3digo para pruebas efectivas. Pytest junto con la biblioteca unittest.mock hace que el proceso de \"mocking\" sea m\u00e1s f\u00e1cil y efectivo en el contexto de las pruebas en Python. Al utilizar \"mocks\", puede asegurarse de que sus pruebas se ejecuten de manera controlada y repetible, lo que aumenta la confianza en la calidad de su c\u00f3digo y permite identificar y corregir problemas de manera eficiente.","title":"Mocking"},{"location":"testing/mocking/#mocking","text":"En el desarrollo de software, las pruebas unitarias son esenciales para garantizar que su c\u00f3digo funcione correctamente. Sin embargo, a menudo es necesario simular o \"burlarse\" de ciertas partes de su c\u00f3digo para probar componentes de manera aislada y controlada. Esto se logra mediante el uso de mocks o \"mocker\" en el contexto de pruebas. En esta gu\u00eda, exploraremos qu\u00e9 es el \"mocking\", c\u00f3mo se aplica en las pruebas unitarias y c\u00f3mo utilizarlo en conjunto con Pytest, un popular marco de pruebas para Python.","title":"Mocking"},{"location":"testing/mocking/#que-es-el-mocking-en-pruebas-unitarias","text":"El \"mocking\" es una t\u00e9cnica que implica simular el comportamiento de ciertas partes de su c\u00f3digo para probar componentes de manera aislada. En lugar de usar implementaciones reales, se utilizan objetos simulados o \"mocks\" que imitan el comportamiento de los objetos reales, pero de manera controlada. Los \"mocks\" se utilizan principalmente para: Aislar Componentes : Al simular componentes externos, como bases de datos o servicios web, puede aislar la unidad que est\u00e1 probando y evitar que interact\u00fae con componentes reales durante las pruebas. Controlar Comportamientos : Puede especificar el comportamiento deseado de un \"mock\" para que se comporte de una manera particular durante una prueba. Simular Condiciones de Error : Puede simular condiciones de error o excepciones lanzadas por un componente para asegurarse de que su c\u00f3digo maneje adecuadamente estas situaciones.","title":"\u00bfQu\u00e9 es el Mocking en Pruebas Unitarias?"},{"location":"testing/mocking/#aplicacion-de-mocking-con-pytest","text":"Pytest es un marco de pruebas popular en Python que ofrece soporte integrado para el \"mocking\" a trav\u00e9s de la biblioteca unittest.mock . A continuaci\u00f3n, veremos c\u00f3mo aplicar el \"mocking\" en pruebas unitarias con Pytest.","title":"Aplicaci\u00f3n de Mocking con Pytest"},{"location":"testing/mocking/#configuracion-inicial","text":"Antes de comenzar a utilizar \"mocks\" en sus pruebas con Pytest, aseg\u00farese de tener instalado Pytest y la biblioteca unittest.mock (tambi\u00e9n conocida como mock ) si a\u00fan no las ha instalado: pip install pytest pip install pytest-mock","title":"Configuraci\u00f3n Inicial"},{"location":"testing/mocking/#ejemplo-de-mocking-con-pytest","text":"Supongamos que tiene una funci\u00f3n que realiza una solicitud HTTP a una API externa y procesa la respuesta. Desea probar esta funci\u00f3n sin depender de la API real, por lo que utilizar\u00e1 un \"mock\" para simular la solicitud HTTP. Primero, definimos la funci\u00f3n que realiza la solicitud HTTP en un m\u00f3dulo llamado api_client.py : # api_client.py import requests def get_data_from_api ( url ): response = requests . get ( url ) return response . json () Luego, escribiremos una prueba unitaria utilizando Pytest y un \"mock\" para simular la solicitud HTTP. Creamos un archivo de prueba llamado test_api_client.py : # test_api_client.py import pytest from unittest.mock import Mock from api_client import get_data_from_api def test_get_data_from_api ( mocker ): # Creamos un mock de requests.get mock_get = mocker . patch ( 'requests.get' ) # Configuramos el comportamiento del mock mock_get . return_value . json . return_value = { 'data' : 'mocked_data' } # Llamamos a la funci\u00f3n bajo prueba result = get_data_from_api ( 'http://example.com/api/data' ) # Verificamos que se llamara a requests.get con la URL correcta mock_get . assert_called_once_with ( 'http://example.com/api/data' ) # Verificamos que la funci\u00f3n devuelva el valor esperado del mock assert result == { 'data' : 'mocked_data' } En esta prueba: Importamos pytest y unittest.mock (alias mocker ) para usarlos en la prueba. Creamos un \"mock\" de la funci\u00f3n requests.get utilizando mocker.patch . Esto simula la funci\u00f3n get de la biblioteca requests . Configuramos el comportamiento del \"mock\" para que devuelva un valor simulado cuando se llama a json . Esto simula la respuesta de la API. Llamamos a la funci\u00f3n get_data_from_api con la URL, que deber\u00eda utilizar el \"mock\" en lugar de realizar una solicitud real. Verificamos que la funci\u00f3n requests.get se llam\u00f3 una vez con la URL correcta utilizando assert_called_once_with . Finalmente, verificamos que la funci\u00f3n bajo prueba devuelva el valor esperado.","title":"Ejemplo de Mocking con Pytest"},{"location":"testing/mocking/#uso-avanzado-de-mocking","text":"El \"mocking\" con Pytest y unittest.mock permite una variedad de configuraciones avanzadas, como especificar valores de retorno din\u00e1micos, contar cu\u00e1ntas veces se llama una funci\u00f3n y capturar llamadas y argumentos. Por ejemplo, para especificar un valor de retorno din\u00e1mico, puede usar side_effect : # Configurar un mock con un valor de retorno din\u00e1mico mock_get . side_effect = [ Exception ( 'Error 1' ), { 'data' : 'mocked_data' }]","title":"Uso Avanzado de Mocking"},{"location":"testing/mocking/#conclusiones","text":"El \"mocking\" es una t\u00e9cnica poderosa en las pruebas unitarias que le permite controlar el comportamiento de componentes externos y aislar unidades de c\u00f3digo para pruebas efectivas. Pytest junto con la biblioteca unittest.mock hace que el proceso de \"mocking\" sea m\u00e1s f\u00e1cil y efectivo en el contexto de las pruebas en Python. Al utilizar \"mocks\", puede asegurarse de que sus pruebas se ejecuten de manera controlada y repetible, lo que aumenta la confianza en la calidad de su c\u00f3digo y permite identificar y corregir problemas de manera eficiente.","title":"Conclusiones"},{"location":"testing/pytest/","text":"Pytest Introducci\u00f3n Pytest es un framework de pruebas en Python que simplifica el proceso de escribir y ejecutar pruebas de unidad y funcionales. A lo largo de este art\u00edculo, exploraremos en detalle c\u00f3mo usar Pytest para escribir pruebas, organizarlas y aprovechar algunas de sus caracter\u00edsticas avanzadas. Tambi\u00e9n se proporcionar\u00e1n ejemplos concretos para ilustrar cada concepto. Instalaci\u00f3n Para comenzar, debes asegurarte de tener Pytest instalado en tu entorno. Si a\u00fan no lo has hecho, puedes instalarlo utilizando pip: pip install pytest Estructura de las pruebas Antes de profundizar en el uso de Pytest, es importante comprender c\u00f3mo se estructuran las pruebas en un proyecto. Pytest busca autom\u00e1ticamente archivos de prueba en directorios y archivos que sigan una convenci\u00f3n espec\u00edfica. Aqu\u00ed hay un ejemplo de una estructura de proyecto de prueba: mi_proyecto/ |-- mi_modulo.py |-- tests/ | |-- test_mi_modulo.py En este ejemplo: mi_proyecto es el directorio principal de tu proyecto. mi_modulo.py es el m\u00f3dulo que deseas probar. tests es un directorio que contiene archivos de prueba. test_mi_modulo.py es el archivo de prueba espec\u00edfico para mi_modulo.py . Pytest busca archivos que comiencen con test_ o terminen con _test.py en el directorio tests por defecto. Puedes personalizar estas convenciones si es necesario. Primeros pasos con Pytest Ahora, vamos a crear algunas pruebas simples para un m\u00f3dulo hipot\u00e9tico llamado mi_modulo.py . Creaci\u00f3n de funciones para probar Primero, creemos algunas funciones en mi_modulo.py que queremos probar. Aqu\u00ed hay un ejemplo: # mi_modulo.py def sumar ( a , b ): return a + b def restar ( a , b ): return a - b Escribir pruebas b\u00e1sicas A continuaci\u00f3n, crearemos un archivo de prueba llamado test_mi_modulo.py en el directorio tests para escribir nuestras pruebas. Las funciones de prueba deben comenzar con test_ . # test_mi_modulo.py from mi_modulo import sumar , restar def test_sumar (): resultado = sumar ( 2 , 3 ) assert resultado == 5 def test_restar (): resultado = restar ( 5 , 2 ) assert resultado == 3 Ejecutar las pruebas Para ejecutar las pruebas, simplemente ejecuta pytest desde el directorio ra\u00edz del proyecto: pytest Pytest buscar\u00e1 autom\u00e1ticamente los archivos de prueba en el directorio tests y ejecutar\u00e1 las pruebas. Deber\u00edas ver una salida similar a esta: ============================== test session starts =============================== platform linux -- Python 3.x.x, pytest-6.x.x, pluggy-0.x.x rootdir: /ruta/a/tu/proyecto collected 2 items test_mi_modulo.py .. [100%] =============================== 2 passed in 0.12s =============================== Esto indica que ambas pruebas han pasado con \u00e9xito. Marcadores (Markers) Los marcadores son etiquetas que puedes aplicar a tus pruebas y que te permiten organizar y ejecutar pruebas de manera selectiva. Pytest incluye varios marcadores incorporados, como @pytest.mark.skip , @pytest.mark.xfail , y otros, pero tambi\u00e9n puedes crear tus propios marcadores personalizados. Ejemplo de uso de marcadores incorporados @pytest.mark.skip Este marcador permite omitir una prueba espec\u00edfica. Por ejemplo, si tienes una prueba que no es relevante en un sistema operativo en particular, puedes omitirla con @pytest.mark.skip . import pytest @pytest . mark . skip ( reason = \"No es relevante en Linux\" ) def test_alguna_prueba (): # Tu c\u00f3digo de prueba aqu\u00ed @pytest.mark.xfail Este marcador indica que se espera que una prueba falle. Puede ser \u00fatil cuando se est\u00e1 trabajando en el desarrollo y se sabe que una prueba fallar\u00e1 hasta que se implemente una correcci\u00f3n. import pytest @pytest . mark . xfail def test_prueba_que_fallara (): # Tu c\u00f3digo de prueba aqu\u00ed Ejemplo de marcador personalizado Puedes crear tus propios marcadores personalizados para clasificar tus pruebas de acuerdo a tus necesidades. Por ejemplo, podr\u00edas crear un marcador personalizado llamado @pytest.mark.api para pruebas relacionadas con una API. import pytest @pytest . mark . api def test_obtener_datos_de_la_api (): # Tu c\u00f3digo de prueba aqu\u00ed Luego, puedes ejecutar pruebas espec\u00edficas con marcadores usando el siguiente comando: pytest -m marcador Por ejemplo, para ejecutar todas las pruebas con el marcador @pytest.mark.api , puedes usar: pytest -m api Par\u00e1metros en pruebas parametrizadas Pytest permite definir par\u00e1metros en pruebas parametrizadas. Esto es \u00fatil cuando deseas ejecutar la misma prueba con diferentes conjuntos de datos o condiciones. Para usar pruebas parametrizadas, utiliza el decorador @pytest.mark.parametrize . Ejemplo de prueba parametrizada Supongamos que queremos probar una funci\u00f3n dividir(a, b) con varios conjuntos de datos de entrada y resultados esperados. Podemos hacerlo de la siguiente manera: import pytest def dividir ( a , b ): return a / b @pytest . mark . parametrize ( \"entrada, resultado_esperado\" , [ ( 2 , 1 ), ( 6 , 2 ), ( 10 , 5 ), ]) def test_dividir ( entrada , resultado_esperado ): resultado = dividir ( entrada , 2 ) assert resultado == resultado_esperado En este ejemplo, hemos parametrizado la prueba con tres conjuntos de datos diferentes, lo que significa que la prueba test_dividir se ejecutar\u00e1 tres veces, una vez para cada conjunto de datos. Pytest tomar\u00e1 autom\u00e1ticamente los valores de entrada y resultados esperados y los pasar\u00e1 como argumentos a la funci\u00f3n de prueba. Uso de fixtures Las fixtures son funciones que proporcionan datos de configuraci\u00f3n o recursos necesarios para las pruebas. Puedes utilizar el decorador @pytest.fixture para definir una fixture. Ejemplo de fixture Supongamos que tenemos una base de datos SQLite que queremos usar en nuestras pruebas. Podemos crear una fixture para crear y configurar la base de datos antes de que las pruebas la utilicen. import pytest import sqlite3 # Fixture para crear y configurar la base de datos @pytest . fixture def base_de_datos (): conexion = sqlite3 . connect ( ':memory:' ) # Base de datos en memoria cursor = conexion . cursor () cursor . execute ( '''CREATE TABLE usuarios (id INTEGER PRIMARY KEY, nombre TEXT)''' ) conexion . commit () yield conexion # Proporciona la conexi\u00f3n a las pruebas conexion . close () # Cierra la conexi\u00f3n despu\u00e9s de las pruebas # Ejemplo de prueba que utiliza la fixture def test_insertar_usuario ( base_de_datos ): cursor = base_de_datos . cursor () cursor . execute ( \"INSERT INTO usuarios (nombre) VALUES ('Alice')\" ) base_de_datos . commit () cursor . execute ( \"SELECT nombre FROM usuarios WHERE id=1\" ) resultado = cursor . fetchone () assert resultado [ 0 ] == 'Alice' En este ejemplo, la fixture base_de_datos crea una base de datos SQLite en memoria y la configura con una tabla de usuarios. Luego, la conexi\u00f3n a la base de datos se proporciona como un argumento a la funci\u00f3n de prueba test_insertar_usuario . Organizaci\u00f3n de pruebas en carpetas Organizar tus pruebas en carpetas es una buena pr\u00e1ctica para mantener tu c\u00f3digo organizado y f\u00e1cil de mantener. A continuaci\u00f3n, se muestra una estructura de carpetas com\u00fan para un proyecto de prueba: mi_proyecto/ |-- mi_modulo.py |-- tests/ | |-- unit/ | | |-- test_mi_modulo.py | |-- integration/ | | |-- test_integracion.py | |-- end_to_end/ | |-- test_e2e.py En esta estructura: mi_proyecto es el directorio principal de tu proyecto. mi_modulo.py es el m\u00f3dulo que deseas probar. tests es el directorio que contiene todas las pruebas. unit es una carpeta que contiene pruebas de unidades. integration es una carpeta que contiene pruebas de integraci\u00f3n. end_to_end es una carpeta que contiene pruebas de extremo a extremo. Puedes crear tantas carpetas de prueba como necesites para organizar tus pruebas de manera l\u00f3gica. A continuaci\u00f3n, se detallan algunos ejemplos de c\u00f3mo escribir pruebas en estas carpetas. Pruebas de unidad Las pruebas de unidad se centran en probar unidades individuales de c\u00f3digo, como funciones o m\u00e9todos, de forma aislada. Aqu\u00ed hay un ejemplo de c\u00f3mo escribir pruebas de unidad: # mi_modulo.py def sumar ( a , b ): return a + b def restar ( a , b ): return a - b # tests/unit/test_mi_modulo.py from mi_modulo import sumar , restar def test_sumar (): resultado = sumar ( 2 , 3 ) assert resultado == 5 def test_restar (): resultado = restar ( 5 , 2 ) assert resultado == 3 Para ejecutar estas pruebas de unidad, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/unit Pruebas de integraci\u00f3n Las pruebas de integraci\u00f3n verifican c\u00f3mo varias partes de un sistema interact\u00faan entre s\u00ed. Aqu\u00ed hay un ejemplo de c\u00f3mo escribir pruebas de integraci\u00f3n para el mismo m\u00f3dulo: # tests/integration/test_integracion.py from mi_modulo import sumar , restar def test_sumar_y_restar (): resultado1 = sumar ( 2 , 3 ) resultado2 = restar ( resultado1 , 1 ) assert resultado2 == 4 Para ejecutar estas pruebas de integraci\u00f3n, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/integration Pruebas de extremo a extremo (End-to-End) Las pruebas de extremo a extremo (E2E) verifican todo el flujo de una aplicaci\u00f3n, desde la entrada hasta la salida. Estas pruebas son m\u00e1s complejas y pueden involucrar m\u00faltiples componentes o sistemas. A continuaci\u00f3n, un ejemplo de c\u00f3mo escribir pruebas E2E: # tests/end_to_end/test_e2e.py def test_flujo_completo (): # Simula el flujo completo de la aplicaci\u00f3n # (por ejemplo, abrir la aplicaci\u00f3n, interactuar con la interfaz de usuario, etc.) resultado = funcion_principal_de_la_aplicacion () assert resultado == \"\u00c9xito\" Las pruebas E2E pueden ser m\u00e1s complicadas y requerir herramientas adicionales para simular la interacci\u00f3n del usuario o configurar el entorno adecuadamente. El enfoque de estas pruebas depende de la naturaleza de tu aplicaci\u00f3n. Para ejecutar estas pruebas E2E, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/end_to_end Con esta estructura de carpetas y ejemplos, puedes organizar tus pruebas de manera efectiva y ejecutar pruebas espec\u00edficas seg\u00fan tus necesidades. A medida que desarrollas tu proyecto, puedes agregar m\u00e1s pruebas a cada carpeta seg\u00fan sea necesario.","title":"Pytest"},{"location":"testing/pytest/#pytest","text":"","title":"Pytest"},{"location":"testing/pytest/#introduccion","text":"Pytest es un framework de pruebas en Python que simplifica el proceso de escribir y ejecutar pruebas de unidad y funcionales. A lo largo de este art\u00edculo, exploraremos en detalle c\u00f3mo usar Pytest para escribir pruebas, organizarlas y aprovechar algunas de sus caracter\u00edsticas avanzadas. Tambi\u00e9n se proporcionar\u00e1n ejemplos concretos para ilustrar cada concepto.","title":"Introducci\u00f3n"},{"location":"testing/pytest/#instalacion","text":"Para comenzar, debes asegurarte de tener Pytest instalado en tu entorno. Si a\u00fan no lo has hecho, puedes instalarlo utilizando pip: pip install pytest","title":"Instalaci\u00f3n"},{"location":"testing/pytest/#estructura-de-las-pruebas","text":"Antes de profundizar en el uso de Pytest, es importante comprender c\u00f3mo se estructuran las pruebas en un proyecto. Pytest busca autom\u00e1ticamente archivos de prueba en directorios y archivos que sigan una convenci\u00f3n espec\u00edfica. Aqu\u00ed hay un ejemplo de una estructura de proyecto de prueba: mi_proyecto/ |-- mi_modulo.py |-- tests/ | |-- test_mi_modulo.py En este ejemplo: mi_proyecto es el directorio principal de tu proyecto. mi_modulo.py es el m\u00f3dulo que deseas probar. tests es un directorio que contiene archivos de prueba. test_mi_modulo.py es el archivo de prueba espec\u00edfico para mi_modulo.py . Pytest busca archivos que comiencen con test_ o terminen con _test.py en el directorio tests por defecto. Puedes personalizar estas convenciones si es necesario.","title":"Estructura de las pruebas"},{"location":"testing/pytest/#primeros-pasos-con-pytest","text":"Ahora, vamos a crear algunas pruebas simples para un m\u00f3dulo hipot\u00e9tico llamado mi_modulo.py .","title":"Primeros pasos con Pytest"},{"location":"testing/pytest/#creacion-de-funciones-para-probar","text":"Primero, creemos algunas funciones en mi_modulo.py que queremos probar. Aqu\u00ed hay un ejemplo: # mi_modulo.py def sumar ( a , b ): return a + b def restar ( a , b ): return a - b","title":"Creaci\u00f3n de funciones para probar"},{"location":"testing/pytest/#escribir-pruebas-basicas","text":"A continuaci\u00f3n, crearemos un archivo de prueba llamado test_mi_modulo.py en el directorio tests para escribir nuestras pruebas. Las funciones de prueba deben comenzar con test_ . # test_mi_modulo.py from mi_modulo import sumar , restar def test_sumar (): resultado = sumar ( 2 , 3 ) assert resultado == 5 def test_restar (): resultado = restar ( 5 , 2 ) assert resultado == 3","title":"Escribir pruebas b\u00e1sicas"},{"location":"testing/pytest/#ejecutar-las-pruebas","text":"Para ejecutar las pruebas, simplemente ejecuta pytest desde el directorio ra\u00edz del proyecto: pytest Pytest buscar\u00e1 autom\u00e1ticamente los archivos de prueba en el directorio tests y ejecutar\u00e1 las pruebas. Deber\u00edas ver una salida similar a esta: ============================== test session starts =============================== platform linux -- Python 3.x.x, pytest-6.x.x, pluggy-0.x.x rootdir: /ruta/a/tu/proyecto collected 2 items test_mi_modulo.py .. [100%] =============================== 2 passed in 0.12s =============================== Esto indica que ambas pruebas han pasado con \u00e9xito.","title":"Ejecutar las pruebas"},{"location":"testing/pytest/#marcadores-markers","text":"Los marcadores son etiquetas que puedes aplicar a tus pruebas y que te permiten organizar y ejecutar pruebas de manera selectiva. Pytest incluye varios marcadores incorporados, como @pytest.mark.skip , @pytest.mark.xfail , y otros, pero tambi\u00e9n puedes crear tus propios marcadores personalizados.","title":"Marcadores (Markers)"},{"location":"testing/pytest/#ejemplo-de-uso-de-marcadores-incorporados","text":"","title":"Ejemplo de uso de marcadores incorporados"},{"location":"testing/pytest/#pytestmarkskip","text":"Este marcador permite omitir una prueba espec\u00edfica. Por ejemplo, si tienes una prueba que no es relevante en un sistema operativo en particular, puedes omitirla con @pytest.mark.skip . import pytest @pytest . mark . skip ( reason = \"No es relevante en Linux\" ) def test_alguna_prueba (): # Tu c\u00f3digo de prueba aqu\u00ed","title":"@pytest.mark.skip"},{"location":"testing/pytest/#pytestmarkxfail","text":"Este marcador indica que se espera que una prueba falle. Puede ser \u00fatil cuando se est\u00e1 trabajando en el desarrollo y se sabe que una prueba fallar\u00e1 hasta que se implemente una correcci\u00f3n. import pytest @pytest . mark . xfail def test_prueba_que_fallara (): # Tu c\u00f3digo de prueba aqu\u00ed","title":"@pytest.mark.xfail"},{"location":"testing/pytest/#ejemplo-de-marcador-personalizado","text":"Puedes crear tus propios marcadores personalizados para clasificar tus pruebas de acuerdo a tus necesidades. Por ejemplo, podr\u00edas crear un marcador personalizado llamado @pytest.mark.api para pruebas relacionadas con una API. import pytest @pytest . mark . api def test_obtener_datos_de_la_api (): # Tu c\u00f3digo de prueba aqu\u00ed Luego, puedes ejecutar pruebas espec\u00edficas con marcadores usando el siguiente comando: pytest -m marcador Por ejemplo, para ejecutar todas las pruebas con el marcador @pytest.mark.api , puedes usar: pytest -m api","title":"Ejemplo de marcador personalizado"},{"location":"testing/pytest/#parametros-en-pruebas-parametrizadas","text":"Pytest permite definir par\u00e1metros en pruebas parametrizadas. Esto es \u00fatil cuando deseas ejecutar la misma prueba con diferentes conjuntos de datos o condiciones. Para usar pruebas parametrizadas, utiliza el decorador @pytest.mark.parametrize .","title":"Par\u00e1metros en pruebas parametrizadas"},{"location":"testing/pytest/#ejemplo-de-prueba-parametrizada","text":"Supongamos que queremos probar una funci\u00f3n dividir(a, b) con varios conjuntos de datos de entrada y resultados esperados. Podemos hacerlo de la siguiente manera: import pytest def dividir ( a , b ): return a / b @pytest . mark . parametrize ( \"entrada, resultado_esperado\" , [ ( 2 , 1 ), ( 6 , 2 ), ( 10 , 5 ), ]) def test_dividir ( entrada , resultado_esperado ): resultado = dividir ( entrada , 2 ) assert resultado == resultado_esperado En este ejemplo, hemos parametrizado la prueba con tres conjuntos de datos diferentes, lo que significa que la prueba test_dividir se ejecutar\u00e1 tres veces, una vez para cada conjunto de datos. Pytest tomar\u00e1 autom\u00e1ticamente los valores de entrada y resultados esperados y los pasar\u00e1 como argumentos a la funci\u00f3n de prueba.","title":"Ejemplo de prueba parametrizada"},{"location":"testing/pytest/#uso-de-fixtures","text":"Las fixtures son funciones que proporcionan datos de configuraci\u00f3n o recursos necesarios para las pruebas. Puedes utilizar el decorador @pytest.fixture para definir una fixture.","title":"Uso de fixtures"},{"location":"testing/pytest/#ejemplo-de-fixture","text":"Supongamos que tenemos una base de datos SQLite que queremos usar en nuestras pruebas. Podemos crear una fixture para crear y configurar la base de datos antes de que las pruebas la utilicen. import pytest import sqlite3 # Fixture para crear y configurar la base de datos @pytest . fixture def base_de_datos (): conexion = sqlite3 . connect ( ':memory:' ) # Base de datos en memoria cursor = conexion . cursor () cursor . execute ( '''CREATE TABLE usuarios (id INTEGER PRIMARY KEY, nombre TEXT)''' ) conexion . commit () yield conexion # Proporciona la conexi\u00f3n a las pruebas conexion . close () # Cierra la conexi\u00f3n despu\u00e9s de las pruebas # Ejemplo de prueba que utiliza la fixture def test_insertar_usuario ( base_de_datos ): cursor = base_de_datos . cursor () cursor . execute ( \"INSERT INTO usuarios (nombre) VALUES ('Alice')\" ) base_de_datos . commit () cursor . execute ( \"SELECT nombre FROM usuarios WHERE id=1\" ) resultado = cursor . fetchone () assert resultado [ 0 ] == 'Alice' En este ejemplo, la fixture base_de_datos crea una base de datos SQLite en memoria y la configura con una tabla de usuarios. Luego, la conexi\u00f3n a la base de datos se proporciona como un argumento a la funci\u00f3n de prueba test_insertar_usuario .","title":"Ejemplo de fixture"},{"location":"testing/pytest/#organizacion-de-pruebas-en-carpetas","text":"Organizar tus pruebas en carpetas es una buena pr\u00e1ctica para mantener tu c\u00f3digo organizado y f\u00e1cil de mantener. A continuaci\u00f3n, se muestra una estructura de carpetas com\u00fan para un proyecto de prueba: mi_proyecto/ |-- mi_modulo.py |-- tests/ | |-- unit/ | | |-- test_mi_modulo.py | |-- integration/ | | |-- test_integracion.py | |-- end_to_end/ | |-- test_e2e.py En esta estructura: mi_proyecto es el directorio principal de tu proyecto. mi_modulo.py es el m\u00f3dulo que deseas probar. tests es el directorio que contiene todas las pruebas. unit es una carpeta que contiene pruebas de unidades. integration es una carpeta que contiene pruebas de integraci\u00f3n. end_to_end es una carpeta que contiene pruebas de extremo a extremo. Puedes crear tantas carpetas de prueba como necesites para organizar tus pruebas de manera l\u00f3gica. A continuaci\u00f3n, se detallan algunos ejemplos de c\u00f3mo escribir pruebas en estas carpetas.","title":"Organizaci\u00f3n de pruebas en carpetas"},{"location":"testing/pytest/#pruebas-de-unidad","text":"Las pruebas de unidad se centran en probar unidades individuales de c\u00f3digo, como funciones o m\u00e9todos, de forma aislada. Aqu\u00ed hay un ejemplo de c\u00f3mo escribir pruebas de unidad: # mi_modulo.py def sumar ( a , b ): return a + b def restar ( a , b ): return a - b # tests/unit/test_mi_modulo.py from mi_modulo import sumar , restar def test_sumar (): resultado = sumar ( 2 , 3 ) assert resultado == 5 def test_restar (): resultado = restar ( 5 , 2 ) assert resultado == 3 Para ejecutar estas pruebas de unidad, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/unit","title":"Pruebas de unidad"},{"location":"testing/pytest/#pruebas-de-integracion","text":"Las pruebas de integraci\u00f3n verifican c\u00f3mo varias partes de un sistema interact\u00faan entre s\u00ed. Aqu\u00ed hay un ejemplo de c\u00f3mo escribir pruebas de integraci\u00f3n para el mismo m\u00f3dulo: # tests/integration/test_integracion.py from mi_modulo import sumar , restar def test_sumar_y_restar (): resultado1 = sumar ( 2 , 3 ) resultado2 = restar ( resultado1 , 1 ) assert resultado2 == 4 Para ejecutar estas pruebas de integraci\u00f3n, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/integration","title":"Pruebas de integraci\u00f3n"},{"location":"testing/pytest/#pruebas-de-extremo-a-extremo-end-to-end","text":"Las pruebas de extremo a extremo (E2E) verifican todo el flujo de una aplicaci\u00f3n, desde la entrada hasta la salida. Estas pruebas son m\u00e1s complejas y pueden involucrar m\u00faltiples componentes o sistemas. A continuaci\u00f3n, un ejemplo de c\u00f3mo escribir pruebas E2E: # tests/end_to_end/test_e2e.py def test_flujo_completo (): # Simula el flujo completo de la aplicaci\u00f3n # (por ejemplo, abrir la aplicaci\u00f3n, interactuar con la interfaz de usuario, etc.) resultado = funcion_principal_de_la_aplicacion () assert resultado == \"\u00c9xito\" Las pruebas E2E pueden ser m\u00e1s complicadas y requerir herramientas adicionales para simular la interacci\u00f3n del usuario o configurar el entorno adecuadamente. El enfoque de estas pruebas depende de la naturaleza de tu aplicaci\u00f3n. Para ejecutar estas pruebas E2E, utiliza el comando pytest desde la carpeta ra\u00edz del proyecto: pytest tests/end_to_end Con esta estructura de carpetas y ejemplos, puedes organizar tus pruebas de manera efectiva y ejecutar pruebas espec\u00edficas seg\u00fan tus necesidades. A medida que desarrollas tu proyecto, puedes agregar m\u00e1s pruebas a cada carpeta seg\u00fan sea necesario.","title":"Pruebas de extremo a extremo (End-to-End)"},{"location":"utilities/logging/","text":"Logging Python, como lenguaje de programaci\u00f3n, ofrece un m\u00f3dulo de registro extremadamente vers\u00e1til conocido como logging . Ya sea para depurar una simple aplicaci\u00f3n o gestionar registros desde m\u00faltiples servidores, el m\u00f3dulo logging de Python puede ser una herramienta esencial para desarrolladores y operadores. En este art\u00edculo, exploraremos en profundidad el concepto de registro, la importancia de su uso y c\u00f3mo aprovechar al m\u00e1ximo el m\u00f3dulo logging de Python. Introducci\u00f3n Logging , que proviene del t\u00e9rmino ingl\u00e9s \"log,\" se refiere a un protocolo que registra eventos y acciones importantes en la historia de un proceso o aplicaci\u00f3n. En el contexto de la programaci\u00f3n, esto significa la captura y el registro de eventos y datos relevantes durante la ejecuci\u00f3n de un programa. Dependiendo de los requisitos de seguimiento, puedes configurar el registro para registrar solo eventos espec\u00edficos o para registrar todo lo que ocurra en tu aplicaci\u00f3n. Cuando trabajas en aplicaciones complejas, el registro de Python puede generar una gran cantidad de datos. El m\u00f3dulo logging de Python permite escribir estos datos en archivos de registro, pero es importante que esta escritura sea asincr\u00f3nica para evitar bloqueos en la ejecuci\u00f3n del c\u00f3digo. An\u00e1lisis de Errores con Niveles de Gravedad El m\u00f3dulo logging de Python proporciona cinco niveles de gravedad distintos, tambi\u00e9n conocidos como \"levels of severity.\" Aunque puedes crear tus propios filtros de registro, los niveles de gravedad predefinidos en el m\u00f3dulo logging de Python, desarrollado por Vinay Sajip , son bastante adecuados y comunes en la industria: Nombre del Nivel de Registro Uso Ejemplo de Mensaje de Registro Debug Diagn\u00f3stico de problemas, informaci\u00f3n detallada Sangr\u00eda inesperada en la l\u00ednea X Info Indica que la aplicaci\u00f3n funciona correctamente La funci\u00f3n 1*1 se est\u00e1 ejecutando. Warning La aplicaci\u00f3n funciona correctamente, pero se ha producido una situaci\u00f3n inesperada o se predice un problema futuro. Poco espacio de almacenamiento Error No se pudo realizar una funci\u00f3n debido a un problema. Ha ocurrido un error y se ha interrumpido la acci\u00f3n. Critical Ha ocurrido un problema grave. Es posible que la aplicaci\u00f3n deba interrumpirse por completo. Error grave: el programa no puede acceder a este servicio y debe cerrarse. Debug es el nivel m\u00e1s bajo y se utiliza para la informaci\u00f3n de baja prioridad. Esto no significa que los errores registrados con este nivel sean menos graves que los registrados con nivel Critical . Debug incluye todos los niveles superiores, lo que significa que si configuras el registro en Debug , se registrar\u00e1n todos los mensajes, desde Debug hasta Critical . Componentes Principales del M\u00f3dulo logging Logger Los loggers registran acciones durante la ejecuci\u00f3n de un programa. No se pueden utilizar directamente como instancias, sino que se obtienen mediante la funci\u00f3n logging.getLogger(nombre del logger) . Asignar un nombre concreto a un logger puede ayudar a estructurar las jerarqu\u00edas de registros. Por ejemplo, si tienes un paquete llamado log , los loggers pueden tener nombres como log.bam o log.bar.loco . Los loggers funcionan de manera similar a la estructura de directorios en Python, donde los puntos separan los paquetes. Esto significa que el objeto log recibir\u00e1 los registros de los directorios log.bam y log.bar.loco . Handler Los handlers recopilan informaci\u00f3n del logger y la env\u00edan a un destino espec\u00edfico. Los handlers son clases b\u00e1sicas que determinan c\u00f3mo se comportan las instancias del handler. Para configurar el destino, debes usar el tipo de handler correspondiente. Por ejemplo, StreamHandler env\u00eda los datos de registro a flujos, mientras que FileHandler los env\u00eda a archivos. Puedes usar varios handlers en un programa para enviar mensajes del mismo logger a diferentes destinos. Esto es \u00fatil si deseas mostrar mensajes de depuraci\u00f3n en la consola y mensajes de error en un archivo independiente. Mediante el m\u00e9todo setLevel() , puedes establecer el nivel m\u00ednimo de gravedad que un mensaje de registro debe tener para ser enviado al handler correspondiente. Para establecer el nivel de registro de un handler en lugar del logger, utiliza [nombre del handler].setLevel . Formatter Los formateadores (o formatters) se utilizan para definir el formato en el que se presentar\u00e1n los mensajes en el archivo de registro. Si no se utiliza un formato personalizado, solo se mostrar\u00e1 el mensaje especificado en el registro. Filter Los filtros permiten definir condiciones precisas para los mensajes de salida. Debes configurar los filtros primero y luego agregarlos al handler o logger correspondiente utilizando el m\u00e9todo addFilter() . Si el valor de un filtro es falso debido a las propiedades del mensaje, el mensaje no se enviar\u00e1. Puedes utilizar filtros para permitir que solo los datos de registro de un logger espec\u00edfico se env\u00eden y bloquear todos los dem\u00e1s loggers. Uso del M\u00f3dulo logging de Python Ahora que hemos explorado los fundamentos del m\u00f3dulo ` logging` de Python, es hora de aprender c\u00f3mo utilizarlo en la pr\u00e1ctica. A continuaci\u00f3n, se muestra un ejemplo simple de c\u00f3mo configurar un logger y registrar mensajes: import logging # Configurar el logger logging . basicConfig ( level = logging . DEBUG , filename = 'app.log' , format = ' %(asctime)s - %(levelname)s : %(message)s ' ) # Crear un logger con un nombre espec\u00edfico logger = logging . getLogger ( 'mi_aplicacion' ) # Registrar eventos logger . debug ( 'Este es un mensaje de depuraci\u00f3n.' ) logger . info ( 'Informaci\u00f3n: La aplicaci\u00f3n funciona correctamente.' ) logger . warning ( '\u00a1Advertencia! Espacio de almacenamiento bajo.' ) logger . error ( 'Error: La operaci\u00f3n ha fallado.' ) logger . critical ( 'Error cr\u00edtico: La aplicaci\u00f3n debe cerrarse.' ) # Finalizar el registro logging . shutdown () En este ejemplo: Configuramos el nivel de registro en DEBUG , lo que significa que se registrar\u00e1n todos los mensajes, desde DEBUG hasta CRITICAL . Especificamos un archivo de registro llamado app.log y un formato personalizado para los mensajes de registro. Creamos un logger con el nombre 'mi_aplicacion' para estructurar los registros. Registramos eventos con diferentes niveles de gravedad. Finalizamos el registro con logging.shutdown() . Recuerda que el m\u00f3dulo logging de Python ofrece muchas m\u00e1s opciones de configuraci\u00f3n y personalizaci\u00f3n. Puedes ajustar los handlers, formatters y filtros seg\u00fan tus necesidades espec\u00edficas. Loguru Loguru es una biblioteca de registro en Python que tiene como objetivo hacer que el proceso de registro sea m\u00e1s sencillo y agradable. Desarrollada por Delgan , Loguru est\u00e1 dise\u00f1ada para mejorar la experiencia de registro en Python, proporcionando una amplia gama de funcionalidades \u00fatiles y resolviendo muchas de las dificultades asociadas con los loggers est\u00e1ndar. Facilidad de Uso La principal filosof\u00eda detr\u00e1s de Loguru es que \"hay uno y solo uno\" logger . Este logger se configura autom\u00e1ticamente y env\u00eda los mensajes a la salida est\u00e1ndar ( stderr ) por defecto. Esto significa que puedes comenzar a registrar eventos sin necesidad de configuraciones complejas. Veamos un ejemplo simple de c\u00f3mo funciona: from loguru import logger logger . debug ( \"\u00a1As\u00ed de sencillo es utilizar Loguru para el registro de eventos!\" ) Sin Necesidad de Handlers, Formatters o Filtros: Todo en Uno En el mundo de los loggers est\u00e1ndar, configurar handlers, definir el formato de los registros, aplicar filtros y establecer niveles de registro puede ser una tarea tediosa. Loguru simplifica todo esto con una funci\u00f3n llamada add() : from loguru import logger logger . add ( \"archivo.log\" , format = \" {time} {level} {message} \" , filter = \"mi_modulo\" , level = \"INFO\" ) La funci\u00f3n add() se utiliza para agregar \"sinks\", que son responsables de manejar los mensajes de registro contextualizados en forma de diccionarios. Un \"sink\" puede tomar varias formas, desde una funci\u00f3n simple hasta una ruta de archivo, y se encarga de la administraci\u00f3n de los mensajes de registro. Registro de Archivos Simplificado con Rotaci\u00f3n, Retenci\u00f3n y Compresi\u00f3n Si deseas registrar mensajes en un archivo, Loguru lo hace extremadamente sencillo. Puedes especificar una ruta de archivo como destino de registro: from loguru import logger logger . add ( \"archivo_ {time} .log\" ) Loguru tambi\u00e9n facilita la configuraci\u00f3n de la rotaci\u00f3n de archivos (por tama\u00f1o, tiempo o cualquier criterio personalizado), la retenci\u00f3n de registros antiguos y la compresi\u00f3n de archivos de registro al cerrar la aplicaci\u00f3n: from loguru import logger logger . add ( \"archivo_1.log\" , rotation = \"500 MB\" ) # Rotaci\u00f3n cuando el archivo supera los 500 MB logger . add ( \"archivo_2.log\" , rotation = \"12:00\" ) # Nuevo archivo cada d\u00eda al mediod\u00eda logger . add ( \"archivo_3.log\" , rotation = \"1 week\" ) # Rotaci\u00f3n semanal logger . add ( \"archivo_X.log\" , retention = \"10 days\" ) # Retenci\u00f3n durante 10 d\u00edas logger . add ( \"archivo_Y.log\" , compression = \"zip\" ) # Compresi\u00f3n de archivos en formato ZIP Captura de Excepciones en Hilos y el Flujo Principal Loguru resuelve un problema com\u00fan al capturar excepciones en hilos o en el flujo principal del programa. \u00bfAlguna vez has visto que tu aplicaci\u00f3n falla sin ning\u00fan mensaje de registro? \u00bfO has notado que las excepciones en los hilos no se registran? Loguru soluciona esto utilizando el decorador/administrador de contexto catch , que garantiza que las excepciones se propaguen correctamente al logger: from loguru import logger @logger . catch def mi_funcion ( x , y , z ): # \u00a1Las excepciones se registran autom\u00e1ticamente! return 1 / ( x + y + z ) Registro Atractivo con Colores Loguru agrega autom\u00e1ticamente colores a tus registros si tu terminal es compatible. Puedes definir tu propio estilo utilizando etiquetas de marcado en el formato del \"sink\": from loguru import logger logger . add ( sys . stdout , colorize = True , format = \"<green> {time} </green> <level> {message} </level>\" ) Las funciones as\u00edncronas utilizadas como \"sink\" tambi\u00e9n son compatibles y se pueden esperar con complete() . Excepciones Totalmente Descriptivas Registrar excepciones es fundamental para depurar problemas, pero puede ser in\u00fatil si no tienes informaci\u00f3n suficiente para solucionarlos. Loguru te ayuda a identificar problemas mostrando todo el seguimiento de la pila, incluyendo los valores de las variables: from loguru import logger logger . add ( \"salida.log\" , backtrace = True , diagnose = True ) # Cuidado, esto puede exponer datos sensibles en producci\u00f3n def mi_funcion ( a , b ): return a / b def anidada ( c ): try : mi_funcion ( 5 , c ) except ZeroDivisionError : logger . exception ( \"\u00a1Ups!\" ) Mejor Gesti\u00f3n de Fecha y Hora Lograr que los registros tengan una fecha y hora legibles puede ser complicado con los loggers est\u00e1ndar. Loguru lo resuelve de manera sencilla: from loguru import logger logger . add ( \"archivo.log\" , format = \"{time:YYYY-MM-DD a las HH:mm:ss} | {level} | {message} \" ) En resumen, Loguru simplifica significativamente el proceso de registro de eventos en Python y ofrece una amplia gama de caracter\u00edsticas \u00fatiles. Ya sea para una peque\u00f1a aplicaci\u00f3n o un proyecto m\u00e1s grande, Loguru puede mejorar tu experiencia de registro y ayudarte a mantener un mejor control sobre los eventos de tu aplicaci\u00f3n.","title":"Logging"},{"location":"utilities/logging/#logging","text":"Python, como lenguaje de programaci\u00f3n, ofrece un m\u00f3dulo de registro extremadamente vers\u00e1til conocido como logging . Ya sea para depurar una simple aplicaci\u00f3n o gestionar registros desde m\u00faltiples servidores, el m\u00f3dulo logging de Python puede ser una herramienta esencial para desarrolladores y operadores. En este art\u00edculo, exploraremos en profundidad el concepto de registro, la importancia de su uso y c\u00f3mo aprovechar al m\u00e1ximo el m\u00f3dulo logging de Python.","title":"Logging"},{"location":"utilities/logging/#introduccion","text":"Logging , que proviene del t\u00e9rmino ingl\u00e9s \"log,\" se refiere a un protocolo que registra eventos y acciones importantes en la historia de un proceso o aplicaci\u00f3n. En el contexto de la programaci\u00f3n, esto significa la captura y el registro de eventos y datos relevantes durante la ejecuci\u00f3n de un programa. Dependiendo de los requisitos de seguimiento, puedes configurar el registro para registrar solo eventos espec\u00edficos o para registrar todo lo que ocurra en tu aplicaci\u00f3n. Cuando trabajas en aplicaciones complejas, el registro de Python puede generar una gran cantidad de datos. El m\u00f3dulo logging de Python permite escribir estos datos en archivos de registro, pero es importante que esta escritura sea asincr\u00f3nica para evitar bloqueos en la ejecuci\u00f3n del c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"utilities/logging/#analisis-de-errores-con-niveles-de-gravedad","text":"El m\u00f3dulo logging de Python proporciona cinco niveles de gravedad distintos, tambi\u00e9n conocidos como \"levels of severity.\" Aunque puedes crear tus propios filtros de registro, los niveles de gravedad predefinidos en el m\u00f3dulo logging de Python, desarrollado por Vinay Sajip , son bastante adecuados y comunes en la industria: Nombre del Nivel de Registro Uso Ejemplo de Mensaje de Registro Debug Diagn\u00f3stico de problemas, informaci\u00f3n detallada Sangr\u00eda inesperada en la l\u00ednea X Info Indica que la aplicaci\u00f3n funciona correctamente La funci\u00f3n 1*1 se est\u00e1 ejecutando. Warning La aplicaci\u00f3n funciona correctamente, pero se ha producido una situaci\u00f3n inesperada o se predice un problema futuro. Poco espacio de almacenamiento Error No se pudo realizar una funci\u00f3n debido a un problema. Ha ocurrido un error y se ha interrumpido la acci\u00f3n. Critical Ha ocurrido un problema grave. Es posible que la aplicaci\u00f3n deba interrumpirse por completo. Error grave: el programa no puede acceder a este servicio y debe cerrarse. Debug es el nivel m\u00e1s bajo y se utiliza para la informaci\u00f3n de baja prioridad. Esto no significa que los errores registrados con este nivel sean menos graves que los registrados con nivel Critical . Debug incluye todos los niveles superiores, lo que significa que si configuras el registro en Debug , se registrar\u00e1n todos los mensajes, desde Debug hasta Critical .","title":"An\u00e1lisis de Errores con Niveles de Gravedad"},{"location":"utilities/logging/#componentes-principales-del-modulo-logging","text":"","title":"Componentes Principales del M\u00f3dulo logging"},{"location":"utilities/logging/#logger","text":"Los loggers registran acciones durante la ejecuci\u00f3n de un programa. No se pueden utilizar directamente como instancias, sino que se obtienen mediante la funci\u00f3n logging.getLogger(nombre del logger) . Asignar un nombre concreto a un logger puede ayudar a estructurar las jerarqu\u00edas de registros. Por ejemplo, si tienes un paquete llamado log , los loggers pueden tener nombres como log.bam o log.bar.loco . Los loggers funcionan de manera similar a la estructura de directorios en Python, donde los puntos separan los paquetes. Esto significa que el objeto log recibir\u00e1 los registros de los directorios log.bam y log.bar.loco .","title":"Logger"},{"location":"utilities/logging/#handler","text":"Los handlers recopilan informaci\u00f3n del logger y la env\u00edan a un destino espec\u00edfico. Los handlers son clases b\u00e1sicas que determinan c\u00f3mo se comportan las instancias del handler. Para configurar el destino, debes usar el tipo de handler correspondiente. Por ejemplo, StreamHandler env\u00eda los datos de registro a flujos, mientras que FileHandler los env\u00eda a archivos. Puedes usar varios handlers en un programa para enviar mensajes del mismo logger a diferentes destinos. Esto es \u00fatil si deseas mostrar mensajes de depuraci\u00f3n en la consola y mensajes de error en un archivo independiente. Mediante el m\u00e9todo setLevel() , puedes establecer el nivel m\u00ednimo de gravedad que un mensaje de registro debe tener para ser enviado al handler correspondiente. Para establecer el nivel de registro de un handler en lugar del logger, utiliza [nombre del handler].setLevel .","title":"Handler"},{"location":"utilities/logging/#formatter","text":"Los formateadores (o formatters) se utilizan para definir el formato en el que se presentar\u00e1n los mensajes en el archivo de registro. Si no se utiliza un formato personalizado, solo se mostrar\u00e1 el mensaje especificado en el registro.","title":"Formatter"},{"location":"utilities/logging/#filter","text":"Los filtros permiten definir condiciones precisas para los mensajes de salida. Debes configurar los filtros primero y luego agregarlos al handler o logger correspondiente utilizando el m\u00e9todo addFilter() . Si el valor de un filtro es falso debido a las propiedades del mensaje, el mensaje no se enviar\u00e1. Puedes utilizar filtros para permitir que solo los datos de registro de un logger espec\u00edfico se env\u00eden y bloquear todos los dem\u00e1s loggers.","title":"Filter"},{"location":"utilities/logging/#uso-del-modulo-logging-de-python","text":"Ahora que hemos explorado los fundamentos del m\u00f3dulo ` logging` de Python, es hora de aprender c\u00f3mo utilizarlo en la pr\u00e1ctica. A continuaci\u00f3n, se muestra un ejemplo simple de c\u00f3mo configurar un logger y registrar mensajes: import logging # Configurar el logger logging . basicConfig ( level = logging . DEBUG , filename = 'app.log' , format = ' %(asctime)s - %(levelname)s : %(message)s ' ) # Crear un logger con un nombre espec\u00edfico logger = logging . getLogger ( 'mi_aplicacion' ) # Registrar eventos logger . debug ( 'Este es un mensaje de depuraci\u00f3n.' ) logger . info ( 'Informaci\u00f3n: La aplicaci\u00f3n funciona correctamente.' ) logger . warning ( '\u00a1Advertencia! Espacio de almacenamiento bajo.' ) logger . error ( 'Error: La operaci\u00f3n ha fallado.' ) logger . critical ( 'Error cr\u00edtico: La aplicaci\u00f3n debe cerrarse.' ) # Finalizar el registro logging . shutdown () En este ejemplo: Configuramos el nivel de registro en DEBUG , lo que significa que se registrar\u00e1n todos los mensajes, desde DEBUG hasta CRITICAL . Especificamos un archivo de registro llamado app.log y un formato personalizado para los mensajes de registro. Creamos un logger con el nombre 'mi_aplicacion' para estructurar los registros. Registramos eventos con diferentes niveles de gravedad. Finalizamos el registro con logging.shutdown() . Recuerda que el m\u00f3dulo logging de Python ofrece muchas m\u00e1s opciones de configuraci\u00f3n y personalizaci\u00f3n. Puedes ajustar los handlers, formatters y filtros seg\u00fan tus necesidades espec\u00edficas.","title":"Uso del M\u00f3dulo logging de Python"},{"location":"utilities/logging/#loguru","text":"Loguru es una biblioteca de registro en Python que tiene como objetivo hacer que el proceso de registro sea m\u00e1s sencillo y agradable. Desarrollada por Delgan , Loguru est\u00e1 dise\u00f1ada para mejorar la experiencia de registro en Python, proporcionando una amplia gama de funcionalidades \u00fatiles y resolviendo muchas de las dificultades asociadas con los loggers est\u00e1ndar.","title":"Loguru"},{"location":"utilities/logging/#facilidad-de-uso","text":"La principal filosof\u00eda detr\u00e1s de Loguru es que \"hay uno y solo uno\" logger . Este logger se configura autom\u00e1ticamente y env\u00eda los mensajes a la salida est\u00e1ndar ( stderr ) por defecto. Esto significa que puedes comenzar a registrar eventos sin necesidad de configuraciones complejas. Veamos un ejemplo simple de c\u00f3mo funciona: from loguru import logger logger . debug ( \"\u00a1As\u00ed de sencillo es utilizar Loguru para el registro de eventos!\" )","title":"Facilidad de Uso"},{"location":"utilities/logging/#sin-necesidad-de-handlers-formatters-o-filtros-todo-en-uno","text":"En el mundo de los loggers est\u00e1ndar, configurar handlers, definir el formato de los registros, aplicar filtros y establecer niveles de registro puede ser una tarea tediosa. Loguru simplifica todo esto con una funci\u00f3n llamada add() : from loguru import logger logger . add ( \"archivo.log\" , format = \" {time} {level} {message} \" , filter = \"mi_modulo\" , level = \"INFO\" ) La funci\u00f3n add() se utiliza para agregar \"sinks\", que son responsables de manejar los mensajes de registro contextualizados en forma de diccionarios. Un \"sink\" puede tomar varias formas, desde una funci\u00f3n simple hasta una ruta de archivo, y se encarga de la administraci\u00f3n de los mensajes de registro.","title":"Sin Necesidad de Handlers, Formatters o Filtros: Todo en Uno"},{"location":"utilities/logging/#registro-de-archivos-simplificado-con-rotacion-retencion-y-compresion","text":"Si deseas registrar mensajes en un archivo, Loguru lo hace extremadamente sencillo. Puedes especificar una ruta de archivo como destino de registro: from loguru import logger logger . add ( \"archivo_ {time} .log\" ) Loguru tambi\u00e9n facilita la configuraci\u00f3n de la rotaci\u00f3n de archivos (por tama\u00f1o, tiempo o cualquier criterio personalizado), la retenci\u00f3n de registros antiguos y la compresi\u00f3n de archivos de registro al cerrar la aplicaci\u00f3n: from loguru import logger logger . add ( \"archivo_1.log\" , rotation = \"500 MB\" ) # Rotaci\u00f3n cuando el archivo supera los 500 MB logger . add ( \"archivo_2.log\" , rotation = \"12:00\" ) # Nuevo archivo cada d\u00eda al mediod\u00eda logger . add ( \"archivo_3.log\" , rotation = \"1 week\" ) # Rotaci\u00f3n semanal logger . add ( \"archivo_X.log\" , retention = \"10 days\" ) # Retenci\u00f3n durante 10 d\u00edas logger . add ( \"archivo_Y.log\" , compression = \"zip\" ) # Compresi\u00f3n de archivos en formato ZIP","title":"Registro de Archivos Simplificado con Rotaci\u00f3n, Retenci\u00f3n y Compresi\u00f3n"},{"location":"utilities/logging/#captura-de-excepciones-en-hilos-y-el-flujo-principal","text":"Loguru resuelve un problema com\u00fan al capturar excepciones en hilos o en el flujo principal del programa. \u00bfAlguna vez has visto que tu aplicaci\u00f3n falla sin ning\u00fan mensaje de registro? \u00bfO has notado que las excepciones en los hilos no se registran? Loguru soluciona esto utilizando el decorador/administrador de contexto catch , que garantiza que las excepciones se propaguen correctamente al logger: from loguru import logger @logger . catch def mi_funcion ( x , y , z ): # \u00a1Las excepciones se registran autom\u00e1ticamente! return 1 / ( x + y + z )","title":"Captura de Excepciones en Hilos y el Flujo Principal"},{"location":"utilities/logging/#registro-atractivo-con-colores","text":"Loguru agrega autom\u00e1ticamente colores a tus registros si tu terminal es compatible. Puedes definir tu propio estilo utilizando etiquetas de marcado en el formato del \"sink\": from loguru import logger logger . add ( sys . stdout , colorize = True , format = \"<green> {time} </green> <level> {message} </level>\" ) Las funciones as\u00edncronas utilizadas como \"sink\" tambi\u00e9n son compatibles y se pueden esperar con complete() .","title":"Registro Atractivo con Colores"},{"location":"utilities/logging/#excepciones-totalmente-descriptivas","text":"Registrar excepciones es fundamental para depurar problemas, pero puede ser in\u00fatil si no tienes informaci\u00f3n suficiente para solucionarlos. Loguru te ayuda a identificar problemas mostrando todo el seguimiento de la pila, incluyendo los valores de las variables: from loguru import logger logger . add ( \"salida.log\" , backtrace = True , diagnose = True ) # Cuidado, esto puede exponer datos sensibles en producci\u00f3n def mi_funcion ( a , b ): return a / b def anidada ( c ): try : mi_funcion ( 5 , c ) except ZeroDivisionError : logger . exception ( \"\u00a1Ups!\" )","title":"Excepciones Totalmente Descriptivas"},{"location":"utilities/logging/#mejor-gestion-de-fecha-y-hora","text":"Lograr que los registros tengan una fecha y hora legibles puede ser complicado con los loggers est\u00e1ndar. Loguru lo resuelve de manera sencilla: from loguru import logger logger . add ( \"archivo.log\" , format = \"{time:YYYY-MM-DD a las HH:mm:ss} | {level} | {message} \" ) En resumen, Loguru simplifica significativamente el proceso de registro de eventos en Python y ofrece una amplia gama de caracter\u00edsticas \u00fatiles. Ya sea para una peque\u00f1a aplicaci\u00f3n o un proyecto m\u00e1s grande, Loguru puede mejorar tu experiencia de registro y ayudarte a mantener un mejor control sobre los eventos de tu aplicaci\u00f3n.","title":"Mejor Gesti\u00f3n de Fecha y Hora"},{"location":"utilities/precommit/","text":"Pre-commit La calidad del c\u00f3digo es esencial en cualquier proyecto de desarrollo de software. Es importante mantener un c\u00f3digo limpio, formateado correctamente y libre de errores para facilitar la colaboraci\u00f3n y mantener la sostenibilidad del proyecto a largo plazo. Una herramienta valiosa que puede ayudarte a automatizar y mejorar la calidad de tu c\u00f3digo en proyectos Python es Pre-commit . \u00bfQu\u00e9 es Pre-commit? Pre-commit es una herramienta que automatiza las verificaciones de calidad en tu repositorio de c\u00f3digo antes de cada commit. Se integra con sistemas de control de versiones como Git y te permite configurar una serie de ganchos (hooks) que se ejecutan autom\u00e1ticamente antes de que se realice un commit. Estos ganchos pueden realizar diversas tareas, como formatear el c\u00f3digo, verificar errores sint\u00e1cticos, buscar problemas de estilo y m\u00e1s. Configuraci\u00f3n B\u00e1sica de Pre-commit Para comenzar a utilizar Pre-commit en tu proyecto de Python, sigue estos pasos: 1. Instala Pre-commit Puedes instalar Pre-commit utilizando pip: pip install pre-commit 2. Crea un Archivo de Configuraci\u00f3n En la ra\u00edz de tu proyecto, crea un archivo llamado .pre-commit-config.yaml . Este archivo contendr\u00e1 la configuraci\u00f3n de Pre-commit. Aqu\u00ed hay un ejemplo b\u00e1sico de configuraci\u00f3n: repos : - repo : https://github.com/pre-commit/mirrors-black rev : v20.8b1 hooks : - id : black En este ejemplo, hemos configurado un gancho para formatear el c\u00f3digo utilizando la herramienta Black. El repositorio https://github.com/pre-commit/mirrors-black es un espejo de Black que Pre-commit utiliza para instalar la herramienta. 3. Instala los Ganchos Ejecuta el siguiente comando para instalar los ganchos configurados en tu repositorio: pre-commit install Esto configurar\u00e1 Pre-commit para que se ejecute antes de cada commit. 4. Realiza un Commit Ahora, cuando realices un commit en tu repositorio, Pre-commit ejecutar\u00e1 autom\u00e1ticamente el gancho que hemos configurado para formatear el c\u00f3digo con Black. Si el c\u00f3digo necesita cambios, Pre-commit te los mostrar\u00e1 y podr\u00e1s realizar los cambios necesarios antes de completar el commit. Casos de Uso Comunes Pre-commit es una herramienta vers\u00e1til que se puede utilizar para automatizar una amplia variedad de verificaciones de calidad en proyectos Python. Aqu\u00ed hay algunos casos de uso comunes: 1. Formateo de C\u00f3digo Puedes configurar Pre-commit para que formatee autom\u00e1ticamente tu c\u00f3digo antes de cada commit. Esto garantiza que el c\u00f3digo en tu repositorio siga un estilo de codificaci\u00f3n consistente. 2. Verificaci\u00f3n de Estilo Utiliza herramientas como Flake8 o pylint para verificar el estilo de tu c\u00f3digo y garantizar que cumple con las convenciones de estilo de Python, como la PEP 8. repos : - repo : https://github.com/pre-commit/mirrors-flake8 rev : v3.9.2 hooks : - id : flake8 3. Detecci\u00f3n de Errores Puedes configurar ganchos que ejecuten pruebas est\u00e1ticas en tu c\u00f3digo para detectar errores y problemas potenciales antes de que se realice un commit. repos : - repo : https://github.com/pre-commit/mirrors-pylint rev : v2.9.6 hooks : - id : pylint 4. Pruebas Unitarias Aunque Pre-commit se enfoca en verificaciones antes del commit, tambi\u00e9n puedes configurarlo para ejecutar pruebas unitarias antes de confirmar tus cambios. Esto garantiza que no se introduzcan regresiones en tu c\u00f3digo. repos : - repo : https://github.com/pre-commit/mirrors-tox rev : v3.24.0 hooks : - id : tox Ejemplo de Uso Avanzado Supongamos que tienes un proyecto de Python con las siguientes caracter\u00edsticas: Utilizas Black para formatear el c\u00f3digo. Utilizas Flake8 para verificar el estilo. Tienes pruebas unitarias escritas con pytest. Puedes configurar Pre-commit para que realice todas estas verificaciones antes de cada commit. Aqu\u00ed est\u00e1 un ejemplo de configuraci\u00f3n avanzada: repos : - repo : https://github.com/pre-commit/mirrors-black rev : v20.8b1 hooks : - id : black - repo : https://github.com/pre-commit/mirrors-flake8 rev : v3.9.2 hooks : - id : flake8 - repo : https://github.com/pre-commit/mirrors-pytest rev : v6.2.4 hooks : - id : pytest Con esta configuraci\u00f3n, Pre-commit ejecutar\u00e1 Black, Flake8 y pytest antes de cada commit, asegur\u00e1ndose de que tu c\u00f3digo est\u00e9 formateado correctamente, cumpla con las convenciones de estilo y pase todas las pruebas unitarias. Conclusi\u00f3n Pre-commit es una herramienta poderosa que puede mejorar significativamente la calidad y la consistencia de tu c\u00f3digo en proyectos Python. Al automatizar las verificaciones de calidad antes de cada commit, te aseguras de que tu c\u00f3digo est\u00e9 limpio, formateado correctamente y libre de errores. Esto facilita la colaboraci\u00f3n en equipos de desarrollo y contribuye a la sostenibilidad a largo plazo de tus proyectos. Si deseas obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo configurar Pre-commit o explorar otras opciones de ganchos disponibles, consulta la documentaci\u00f3n oficial de Pre-commit . Integrar Pre-commit en tu flujo de trabajo de desarrollo de software es una decisi\u00f3n inteligente que te ayudar\u00e1 a mantener la calidad de tu c\u00f3digo sin esfuerzo adicional. \u00a1Pru\u00e9balo en tu pr\u00f3ximo proyecto y experimenta los beneficios por ti mismo!","title":"Pre-commit"},{"location":"utilities/precommit/#pre-commit","text":"La calidad del c\u00f3digo es esencial en cualquier proyecto de desarrollo de software. Es importante mantener un c\u00f3digo limpio, formateado correctamente y libre de errores para facilitar la colaboraci\u00f3n y mantener la sostenibilidad del proyecto a largo plazo. Una herramienta valiosa que puede ayudarte a automatizar y mejorar la calidad de tu c\u00f3digo en proyectos Python es Pre-commit .","title":"Pre-commit"},{"location":"utilities/precommit/#que-es-pre-commit","text":"Pre-commit es una herramienta que automatiza las verificaciones de calidad en tu repositorio de c\u00f3digo antes de cada commit. Se integra con sistemas de control de versiones como Git y te permite configurar una serie de ganchos (hooks) que se ejecutan autom\u00e1ticamente antes de que se realice un commit. Estos ganchos pueden realizar diversas tareas, como formatear el c\u00f3digo, verificar errores sint\u00e1cticos, buscar problemas de estilo y m\u00e1s.","title":"\u00bfQu\u00e9 es Pre-commit?"},{"location":"utilities/precommit/#configuracion-basica-de-pre-commit","text":"Para comenzar a utilizar Pre-commit en tu proyecto de Python, sigue estos pasos:","title":"Configuraci\u00f3n B\u00e1sica de Pre-commit"},{"location":"utilities/precommit/#1-instala-pre-commit","text":"Puedes instalar Pre-commit utilizando pip: pip install pre-commit","title":"1. Instala Pre-commit"},{"location":"utilities/precommit/#2-crea-un-archivo-de-configuracion","text":"En la ra\u00edz de tu proyecto, crea un archivo llamado .pre-commit-config.yaml . Este archivo contendr\u00e1 la configuraci\u00f3n de Pre-commit. Aqu\u00ed hay un ejemplo b\u00e1sico de configuraci\u00f3n: repos : - repo : https://github.com/pre-commit/mirrors-black rev : v20.8b1 hooks : - id : black En este ejemplo, hemos configurado un gancho para formatear el c\u00f3digo utilizando la herramienta Black. El repositorio https://github.com/pre-commit/mirrors-black es un espejo de Black que Pre-commit utiliza para instalar la herramienta.","title":"2. Crea un Archivo de Configuraci\u00f3n"},{"location":"utilities/precommit/#3-instala-los-ganchos","text":"Ejecuta el siguiente comando para instalar los ganchos configurados en tu repositorio: pre-commit install Esto configurar\u00e1 Pre-commit para que se ejecute antes de cada commit.","title":"3. Instala los Ganchos"},{"location":"utilities/precommit/#4-realiza-un-commit","text":"Ahora, cuando realices un commit en tu repositorio, Pre-commit ejecutar\u00e1 autom\u00e1ticamente el gancho que hemos configurado para formatear el c\u00f3digo con Black. Si el c\u00f3digo necesita cambios, Pre-commit te los mostrar\u00e1 y podr\u00e1s realizar los cambios necesarios antes de completar el commit.","title":"4. Realiza un Commit"},{"location":"utilities/precommit/#casos-de-uso-comunes","text":"Pre-commit es una herramienta vers\u00e1til que se puede utilizar para automatizar una amplia variedad de verificaciones de calidad en proyectos Python. Aqu\u00ed hay algunos casos de uso comunes:","title":"Casos de Uso Comunes"},{"location":"utilities/precommit/#1-formateo-de-codigo","text":"Puedes configurar Pre-commit para que formatee autom\u00e1ticamente tu c\u00f3digo antes de cada commit. Esto garantiza que el c\u00f3digo en tu repositorio siga un estilo de codificaci\u00f3n consistente.","title":"1. Formateo de C\u00f3digo"},{"location":"utilities/precommit/#2-verificacion-de-estilo","text":"Utiliza herramientas como Flake8 o pylint para verificar el estilo de tu c\u00f3digo y garantizar que cumple con las convenciones de estilo de Python, como la PEP 8. repos : - repo : https://github.com/pre-commit/mirrors-flake8 rev : v3.9.2 hooks : - id : flake8","title":"2. Verificaci\u00f3n de Estilo"},{"location":"utilities/precommit/#3-deteccion-de-errores","text":"Puedes configurar ganchos que ejecuten pruebas est\u00e1ticas en tu c\u00f3digo para detectar errores y problemas potenciales antes de que se realice un commit. repos : - repo : https://github.com/pre-commit/mirrors-pylint rev : v2.9.6 hooks : - id : pylint","title":"3. Detecci\u00f3n de Errores"},{"location":"utilities/precommit/#4-pruebas-unitarias","text":"Aunque Pre-commit se enfoca en verificaciones antes del commit, tambi\u00e9n puedes configurarlo para ejecutar pruebas unitarias antes de confirmar tus cambios. Esto garantiza que no se introduzcan regresiones en tu c\u00f3digo. repos : - repo : https://github.com/pre-commit/mirrors-tox rev : v3.24.0 hooks : - id : tox","title":"4. Pruebas Unitarias"},{"location":"utilities/precommit/#ejemplo-de-uso-avanzado","text":"Supongamos que tienes un proyecto de Python con las siguientes caracter\u00edsticas: Utilizas Black para formatear el c\u00f3digo. Utilizas Flake8 para verificar el estilo. Tienes pruebas unitarias escritas con pytest. Puedes configurar Pre-commit para que realice todas estas verificaciones antes de cada commit. Aqu\u00ed est\u00e1 un ejemplo de configuraci\u00f3n avanzada: repos : - repo : https://github.com/pre-commit/mirrors-black rev : v20.8b1 hooks : - id : black - repo : https://github.com/pre-commit/mirrors-flake8 rev : v3.9.2 hooks : - id : flake8 - repo : https://github.com/pre-commit/mirrors-pytest rev : v6.2.4 hooks : - id : pytest Con esta configuraci\u00f3n, Pre-commit ejecutar\u00e1 Black, Flake8 y pytest antes de cada commit, asegur\u00e1ndose de que tu c\u00f3digo est\u00e9 formateado correctamente, cumpla con las convenciones de estilo y pase todas las pruebas unitarias.","title":"Ejemplo de Uso Avanzado"},{"location":"utilities/precommit/#conclusion","text":"Pre-commit es una herramienta poderosa que puede mejorar significativamente la calidad y la consistencia de tu c\u00f3digo en proyectos Python. Al automatizar las verificaciones de calidad antes de cada commit, te aseguras de que tu c\u00f3digo est\u00e9 limpio, formateado correctamente y libre de errores. Esto facilita la colaboraci\u00f3n en equipos de desarrollo y contribuye a la sostenibilidad a largo plazo de tus proyectos. Si deseas obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo configurar Pre-commit o explorar otras opciones de ganchos disponibles, consulta la documentaci\u00f3n oficial de Pre-commit . Integrar Pre-commit en tu flujo de trabajo de desarrollo de software es una decisi\u00f3n inteligente que te ayudar\u00e1 a mantener la calidad de tu c\u00f3digo sin esfuerzo adicional. \u00a1Pru\u00e9balo en tu pr\u00f3ximo proyecto y experimenta los beneficios por ti mismo!","title":"Conclusi\u00f3n"},{"location":"utilities/styling/","text":"Styling & Formatting Code El c\u00f3digo limpio y bien formateado es esencial para escribir programas mantenibles y colaborativos en Python. La estilizaci\u00f3n y el formateo adecuados ayudan a que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de entender para los desarrolladores, lo que a su vez facilita la detecci\u00f3n y correcci\u00f3n de errores. En este art\u00edculo, exploraremos las mejores pr\u00e1cticas y herramientas para estilizar y formatear c\u00f3digo en Python. Por qu\u00e9 es Importante el Formateo de C\u00f3digo El formateo de c\u00f3digo es importante por varias razones: Legibilidad : Un c\u00f3digo bien formateado es m\u00e1s f\u00e1cil de leer y comprender, lo que facilita su mantenimiento y depuraci\u00f3n. Consistencia : El formateo consistente hace que el c\u00f3digo se vea uniforme y coherente, incluso cuando es escrito por m\u00faltiples desarrolladores. Cumplimiento de Est\u00e1ndares : Algunos proyectos y equipos de desarrollo tienen est\u00e1ndares de estilo de c\u00f3digo que deben seguirse para garantizar la coherencia en todo el proyecto. Facilita la Colaboraci\u00f3n : Cuando varios desarrolladores trabajan en un proyecto, un estilo de c\u00f3digo coherente reduce las posibilidades de conflictos y errores. PEP 8: La Gu\u00eda de Estilo de Python El est\u00e1ndar de estilo de c\u00f3digo m\u00e1s ampliamente aceptado y utilizado en Python es el PEP 8 , que es la \"Propuesta de Mejora de Python\" n\u00famero 8. PEP 8 establece las pautas y recomendaciones para la estilizaci\u00f3n del c\u00f3digo Python. Aqu\u00ed hay algunos aspectos destacados de PEP 8: Indentaci\u00f3n : Usar 4 espacios para la indentaci\u00f3n. No usar tabulaciones. Longitud de l\u00ednea : Las l\u00edneas no deben tener m\u00e1s de 79 caracteres. Para las cadenas de documentaci\u00f3n o comentarios, el l\u00edmite es de 72 caracteres. Espacios en blanco : Evitar espacios en blanco in\u00fatiles alrededor de par\u00e9ntesis, corchetes y llaves. Separar las funciones y clases con dos l\u00edneas en blanco. Nombres de Variables y Funciones : Usar min\u00fasculas con guiones bajos para los nombres de variables y funciones (snake_case). Para las clases, usar CamelCase. Comentarios y Docstrings : Usar comentarios para explicar el c\u00f3digo cuando sea necesario. Usar docstrings para documentar funciones, clases y m\u00f3dulos. Configuraci\u00f3n en Editores de Texto La mayor\u00eda de los editores de texto y entornos de desarrollo populares ofrecen extensiones o plugins que pueden ayudarte a mantener el estilo de c\u00f3digo de acuerdo con PEP 8. Algunos ejemplos incluyen: Visual Studio Code : La extensi\u00f3n Python incluye opciones de formateo basadas en PEP 8. Tambi\u00e9n puedes integrar Black con Visual Studio Code usando la extensi\u00f3n Python Black . PyCharm : PyCharm tiene integraci\u00f3n nativa con PEP 8 y puede aplicar autom\u00e1ticamente el formateo cuando guardas un archivo. Sublime Text : Puedes instalar el plugin SublimeLinter con autopep8 para formatear tu c\u00f3digo en tiempo real. Herramientas Black Black es una herramienta de formateo de c\u00f3digo que se describe a s\u00ed misma como \"el formateador de c\u00f3digo sin discusi\u00f3n de Python\". Su objetivo principal es garantizar que el c\u00f3digo Python sea consistente y siga un estilo de codificaci\u00f3n predefinido. Black se enfoca en automatizar el proceso de formateo, eliminando as\u00ed las discusiones sobre el estilo de c\u00f3digo en el equipo de desarrollo. Caracter\u00edsticas Principales Opini\u00f3n Fuerte : Black tiene una opini\u00f3n fuerte sobre c\u00f3mo debe formatearse el c\u00f3digo y aplica ese estilo de manera consistente. Sin Configuraci\u00f3n : A diferencia de algunas otras herramientas, Black no requiere configuraci\u00f3n. Simplemente se ejecuta y formatea tu c\u00f3digo de acuerdo con sus reglas predefinidas. Reformatting : Black puede reformatear todo tu c\u00f3digo autom\u00e1ticamente, lo que lo hace ideal para proyectos existentes. Integraci\u00f3n con Editores : Black se integra f\u00e1cilmente con editores de c\u00f3digo populares como VSCode, PyCharm y otros, lo que facilita el formateo del c\u00f3digo en tiempo real. Ejemplo de Uso de Black Supongamos que tenemos el siguiente c\u00f3digo desordenado en un archivo llamado mi_script.py : def suma ( a , b ): return a + b Ejecutar Black en este archivo reformatear\u00e1 el c\u00f3digo autom\u00e1ticamente: def suma ( a , b ): return a + b Para usar Black, primero debes instalarlo mediante pip: pip install black Luego, puedes ejecutar Black en un archivo o directorio de la siguiente manera: black mi_script.py isort isort es una herramienta de ordenaci\u00f3n de importaciones en Python. Su funci\u00f3n principal es organizar las declaraciones de importaci\u00f3n en tu c\u00f3digo de manera consistente y siguiendo ciertas reglas predefinidas. Mantener un orden en las importaciones facilita la lectura del c\u00f3digo y evita problemas de importaci\u00f3n circular. Caracter\u00edsticas Principales Clasificaci\u00f3n Inteligente : isort organiza las importaciones de forma inteligente, agrup\u00e1ndolas en categor\u00edas como est\u00e1ndar, terceros y propios. Configuraci\u00f3n Personalizada : Aunque isort viene con una configuraci\u00f3n predefinida que funciona bien en la mayor\u00eda de los casos, tambi\u00e9n puedes personalizar las reglas de ordenaci\u00f3n seg\u00fan las necesidades de tu proyecto. Integraci\u00f3n con Editores : Al igual que Black, isort se integra f\u00e1cilmente con editores populares, lo que facilita la ordenaci\u00f3n de importaciones en tiempo real. Ejemplo de Uso de isort Supongamos que tenemos un archivo llamado mi_script.py con importaciones desordenadas: import os import sys import math import requests Ejecutar isort en este archivo organizar\u00e1 las importaciones: import math import os import sys import requests Para usar isort, primero debes instalarlo mediante pip: pip install isort Luego, puedes ejecutar isort en un archivo o directorio de la siguiente manera: isort mi_script.py Flake8 Flake8 es una herramienta de verificaci\u00f3n de c\u00f3digo est\u00e1tico que se encarga de buscar problemas de estilo y errores en el c\u00f3digo Python. A diferencia de Black e isort, Flake8 no formatea el c\u00f3digo, pero te ayuda a identificar problemas potenciales. Caracter\u00edsticas Principales Verificaci\u00f3n de Estilo : Flake8 verifica que tu c\u00f3digo siga las convenciones de estilo de Python, como la PEP 8. Detecci\u00f3n de Errores : Flake8 detecta errores en el c\u00f3digo, como variables no utilizadas, importaciones no utilizadas y m\u00e1s. Personalizaci\u00f3n : Puedes personalizar las reglas y configuraciones de Flake8 seg\u00fan las necesidades de tu proyecto. Ejemplo de Uso de Flake8 Supongamos que tenemos un archivo llamado mi_script.py con algunas violaciones de estilo y errores: def suma ( a , b ): return a + b result = suma ( 3 , 4 ) print ( result ) unused_variable = 42 Ejecutar Flake8 en este archivo mostrar\u00e1 mensajes de error y advertencias: mi_script.py:1:1: E302 expected 2 blank lines, found 1 mi_script.py:1:9: E231 missing whitespace after ',' mi_script.py:2:1: E305 expected 2 blank lines after function or class definition, found 1 mi_script.py:3:5: E701 multiple statements on one line (colon) mi_script.py:6:1: F841 local variable 'unused_variable' is assigned to but never used Para usar Flake8, primero debes instalarlo mediante pip: pip install flake8 Luego, puedes ejecutar Flake8 en un archivo o directorio de la siguiente manera: flake8 mi_script.py pyupgrade pyupgrade es una herramienta poderosa que te permite actualizar autom\u00e1ticamente el c\u00f3digo Python a una versi\u00f3n m\u00e1s reciente del lenguaje. Esto es \u00fatil para aprovechar las caracter\u00edsticas m\u00e1s recientes de Python, hacer que tu c\u00f3digo sea m\u00e1s limpio y legible, y asegurarte de que est\u00e9s utilizando las mejores pr\u00e1cticas. Motivos para Usar pyupgrade Existen varias razones para utilizar pyupgrade en tus proyectos de Python: Mantener el C\u00f3digo Actualizado : Python est\u00e1 en constante evoluci\u00f3n, y cada nueva versi\u00f3n trae consigo mejoras y caracter\u00edsticas nuevas. Al mantener tu c\u00f3digo actualizado, puedes aprovechar estas mejoras y mantenerlo en l\u00ednea con las \u00faltimas pr\u00e1cticas recomendadas. Mejorar la Legibilidad : pyupgrade puede realizar cambios que mejoran la legibilidad del c\u00f3digo. Por ejemplo, puede convertir el uso de str.format() en f-strings, lo que hace que las cadenas de formato sean m\u00e1s claras y concisas. Eliminar Obsolescencias : Python introduce obsolescencias (deprecations) en versiones posteriores para indicar que ciertas caracter\u00edsticas o bibliotecas ya no se recomiendan. pyupgrade puede ayudarte a eliminar esas obsolescencias de manera autom\u00e1tica. Est\u00e1ndares de C\u00f3digo : pyupgrade puede ayudarte a cumplir con los est\u00e1ndares de c\u00f3digo de Python y seguir las pautas de estilo recomendadas. Ejemplos de Actualizaciones Realizadas por pyupgrade A continuaci\u00f3n, se presentan algunos ejemplos de actualizaciones que pyupgrade puede realizar en tu c\u00f3digo: 1.- Set Literals En versiones recientes de Python, se introdujo una sintaxis m\u00e1s concisa para definir conjuntos (sets) llamada \"set literals\". pyupgrade puede convertir las definiciones de conjuntos obsoletas en set literals m\u00e1s legibles. Antes : my_set = set ([ 1 , 2 , 3 ]) Despu\u00e9s : my_set = { 1 , 2 , 3 } 2.- Dictionary Comprehensions Python admite \"dictionary comprehensions\" que permiten crear diccionarios de manera m\u00e1s eficiente y legible que utilizando bucles. pyupgrade puede actualizar las construcciones de diccionarios obsoletas a \"dictionary comprehensions\". Antes : my_dict = {} for i in range ( 5 ): my_dict [ i ] = i * i Despu\u00e9s : my_dict = { i : i * i for i in range ( 5 )} 3.- Format Specifiers Las \"f-strings\" introducidas en Python 3.6 ofrecen una forma m\u00e1s concisa y legible de formatear cadenas. pyupgrade puede convertir las llamadas a str.format() en f-strings. Antes : name = \"Alice\" age = 30 message = \"My name is {} and I am {} years old.\" . format ( name , age ) Despu\u00e9s : name = \"Alice\" age = 30 message = f \"My name is { name } and I am { age } years old.\" Estos son solo algunos ejemplos de las actualizaciones que pyupgrade puede realizar. La herramienta es altamente configurable y puede adaptarse a las necesidades de tu proyecto espec\u00edfico. Uso de pyupgrade Para utilizar pyupgrade, primero debes instalarlo mediante pip: pip install pyupgrade Luego, puedes ejecutar pyupgrade en un archivo o directorio de la siguiente manera: pyupgrade your_file.py pyupgrade analizar\u00e1 el c\u00f3digo en busca de oportunidades de actualizaci\u00f3n y realizar\u00e1 las modificaciones necesarias. Aseg\u00farate de revisar los cambios realizados por pyupgrade para garantizar que el c\u00f3digo siga funcionando como se esperaba. En resumen, pyupgrade es una herramienta valiosa para mantener tu c\u00f3digo Python actualizado y en l\u00ednea con las \u00faltimas mejores pr\u00e1cticas del lenguaje. Puede ahorrarte tiempo y esfuerzo al automatizar las actualizaciones y mejoras de c\u00f3digo, lo que te permite concentrarte en el desarrollo de nuevas caracter\u00edsticas y funcionalidades.","title":"Styling & Formatting Code"},{"location":"utilities/styling/#styling-formatting-code","text":"El c\u00f3digo limpio y bien formateado es esencial para escribir programas mantenibles y colaborativos en Python. La estilizaci\u00f3n y el formateo adecuados ayudan a que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de entender para los desarrolladores, lo que a su vez facilita la detecci\u00f3n y correcci\u00f3n de errores. En este art\u00edculo, exploraremos las mejores pr\u00e1cticas y herramientas para estilizar y formatear c\u00f3digo en Python.","title":"Styling &amp; Formatting Code"},{"location":"utilities/styling/#por-que-es-importante-el-formateo-de-codigo","text":"El formateo de c\u00f3digo es importante por varias razones: Legibilidad : Un c\u00f3digo bien formateado es m\u00e1s f\u00e1cil de leer y comprender, lo que facilita su mantenimiento y depuraci\u00f3n. Consistencia : El formateo consistente hace que el c\u00f3digo se vea uniforme y coherente, incluso cuando es escrito por m\u00faltiples desarrolladores. Cumplimiento de Est\u00e1ndares : Algunos proyectos y equipos de desarrollo tienen est\u00e1ndares de estilo de c\u00f3digo que deben seguirse para garantizar la coherencia en todo el proyecto. Facilita la Colaboraci\u00f3n : Cuando varios desarrolladores trabajan en un proyecto, un estilo de c\u00f3digo coherente reduce las posibilidades de conflictos y errores.","title":"Por qu\u00e9 es Importante el Formateo de C\u00f3digo"},{"location":"utilities/styling/#pep-8-la-guia-de-estilo-de-python","text":"El est\u00e1ndar de estilo de c\u00f3digo m\u00e1s ampliamente aceptado y utilizado en Python es el PEP 8 , que es la \"Propuesta de Mejora de Python\" n\u00famero 8. PEP 8 establece las pautas y recomendaciones para la estilizaci\u00f3n del c\u00f3digo Python. Aqu\u00ed hay algunos aspectos destacados de PEP 8: Indentaci\u00f3n : Usar 4 espacios para la indentaci\u00f3n. No usar tabulaciones. Longitud de l\u00ednea : Las l\u00edneas no deben tener m\u00e1s de 79 caracteres. Para las cadenas de documentaci\u00f3n o comentarios, el l\u00edmite es de 72 caracteres. Espacios en blanco : Evitar espacios en blanco in\u00fatiles alrededor de par\u00e9ntesis, corchetes y llaves. Separar las funciones y clases con dos l\u00edneas en blanco. Nombres de Variables y Funciones : Usar min\u00fasculas con guiones bajos para los nombres de variables y funciones (snake_case). Para las clases, usar CamelCase. Comentarios y Docstrings : Usar comentarios para explicar el c\u00f3digo cuando sea necesario. Usar docstrings para documentar funciones, clases y m\u00f3dulos.","title":"PEP 8: La Gu\u00eda de Estilo de Python"},{"location":"utilities/styling/#configuracion-en-editores-de-texto","text":"La mayor\u00eda de los editores de texto y entornos de desarrollo populares ofrecen extensiones o plugins que pueden ayudarte a mantener el estilo de c\u00f3digo de acuerdo con PEP 8. Algunos ejemplos incluyen: Visual Studio Code : La extensi\u00f3n Python incluye opciones de formateo basadas en PEP 8. Tambi\u00e9n puedes integrar Black con Visual Studio Code usando la extensi\u00f3n Python Black . PyCharm : PyCharm tiene integraci\u00f3n nativa con PEP 8 y puede aplicar autom\u00e1ticamente el formateo cuando guardas un archivo. Sublime Text : Puedes instalar el plugin SublimeLinter con autopep8 para formatear tu c\u00f3digo en tiempo real.","title":"Configuraci\u00f3n en Editores de Texto"},{"location":"utilities/styling/#herramientas","text":"","title":"Herramientas"},{"location":"utilities/styling/#black","text":"Black es una herramienta de formateo de c\u00f3digo que se describe a s\u00ed misma como \"el formateador de c\u00f3digo sin discusi\u00f3n de Python\". Su objetivo principal es garantizar que el c\u00f3digo Python sea consistente y siga un estilo de codificaci\u00f3n predefinido. Black se enfoca en automatizar el proceso de formateo, eliminando as\u00ed las discusiones sobre el estilo de c\u00f3digo en el equipo de desarrollo. Caracter\u00edsticas Principales Opini\u00f3n Fuerte : Black tiene una opini\u00f3n fuerte sobre c\u00f3mo debe formatearse el c\u00f3digo y aplica ese estilo de manera consistente. Sin Configuraci\u00f3n : A diferencia de algunas otras herramientas, Black no requiere configuraci\u00f3n. Simplemente se ejecuta y formatea tu c\u00f3digo de acuerdo con sus reglas predefinidas. Reformatting : Black puede reformatear todo tu c\u00f3digo autom\u00e1ticamente, lo que lo hace ideal para proyectos existentes. Integraci\u00f3n con Editores : Black se integra f\u00e1cilmente con editores de c\u00f3digo populares como VSCode, PyCharm y otros, lo que facilita el formateo del c\u00f3digo en tiempo real. Ejemplo de Uso de Black Supongamos que tenemos el siguiente c\u00f3digo desordenado en un archivo llamado mi_script.py : def suma ( a , b ): return a + b Ejecutar Black en este archivo reformatear\u00e1 el c\u00f3digo autom\u00e1ticamente: def suma ( a , b ): return a + b Para usar Black, primero debes instalarlo mediante pip: pip install black Luego, puedes ejecutar Black en un archivo o directorio de la siguiente manera: black mi_script.py","title":"Black"},{"location":"utilities/styling/#isort","text":"isort es una herramienta de ordenaci\u00f3n de importaciones en Python. Su funci\u00f3n principal es organizar las declaraciones de importaci\u00f3n en tu c\u00f3digo de manera consistente y siguiendo ciertas reglas predefinidas. Mantener un orden en las importaciones facilita la lectura del c\u00f3digo y evita problemas de importaci\u00f3n circular. Caracter\u00edsticas Principales Clasificaci\u00f3n Inteligente : isort organiza las importaciones de forma inteligente, agrup\u00e1ndolas en categor\u00edas como est\u00e1ndar, terceros y propios. Configuraci\u00f3n Personalizada : Aunque isort viene con una configuraci\u00f3n predefinida que funciona bien en la mayor\u00eda de los casos, tambi\u00e9n puedes personalizar las reglas de ordenaci\u00f3n seg\u00fan las necesidades de tu proyecto. Integraci\u00f3n con Editores : Al igual que Black, isort se integra f\u00e1cilmente con editores populares, lo que facilita la ordenaci\u00f3n de importaciones en tiempo real. Ejemplo de Uso de isort Supongamos que tenemos un archivo llamado mi_script.py con importaciones desordenadas: import os import sys import math import requests Ejecutar isort en este archivo organizar\u00e1 las importaciones: import math import os import sys import requests Para usar isort, primero debes instalarlo mediante pip: pip install isort Luego, puedes ejecutar isort en un archivo o directorio de la siguiente manera: isort mi_script.py","title":"isort"},{"location":"utilities/styling/#flake8","text":"Flake8 es una herramienta de verificaci\u00f3n de c\u00f3digo est\u00e1tico que se encarga de buscar problemas de estilo y errores en el c\u00f3digo Python. A diferencia de Black e isort, Flake8 no formatea el c\u00f3digo, pero te ayuda a identificar problemas potenciales. Caracter\u00edsticas Principales Verificaci\u00f3n de Estilo : Flake8 verifica que tu c\u00f3digo siga las convenciones de estilo de Python, como la PEP 8. Detecci\u00f3n de Errores : Flake8 detecta errores en el c\u00f3digo, como variables no utilizadas, importaciones no utilizadas y m\u00e1s. Personalizaci\u00f3n : Puedes personalizar las reglas y configuraciones de Flake8 seg\u00fan las necesidades de tu proyecto. Ejemplo de Uso de Flake8 Supongamos que tenemos un archivo llamado mi_script.py con algunas violaciones de estilo y errores: def suma ( a , b ): return a + b result = suma ( 3 , 4 ) print ( result ) unused_variable = 42 Ejecutar Flake8 en este archivo mostrar\u00e1 mensajes de error y advertencias: mi_script.py:1:1: E302 expected 2 blank lines, found 1 mi_script.py:1:9: E231 missing whitespace after ',' mi_script.py:2:1: E305 expected 2 blank lines after function or class definition, found 1 mi_script.py:3:5: E701 multiple statements on one line (colon) mi_script.py:6:1: F841 local variable 'unused_variable' is assigned to but never used Para usar Flake8, primero debes instalarlo mediante pip: pip install flake8 Luego, puedes ejecutar Flake8 en un archivo o directorio de la siguiente manera: flake8 mi_script.py","title":"Flake8"},{"location":"utilities/styling/#pyupgrade","text":"pyupgrade es una herramienta poderosa que te permite actualizar autom\u00e1ticamente el c\u00f3digo Python a una versi\u00f3n m\u00e1s reciente del lenguaje. Esto es \u00fatil para aprovechar las caracter\u00edsticas m\u00e1s recientes de Python, hacer que tu c\u00f3digo sea m\u00e1s limpio y legible, y asegurarte de que est\u00e9s utilizando las mejores pr\u00e1cticas. Motivos para Usar pyupgrade Existen varias razones para utilizar pyupgrade en tus proyectos de Python: Mantener el C\u00f3digo Actualizado : Python est\u00e1 en constante evoluci\u00f3n, y cada nueva versi\u00f3n trae consigo mejoras y caracter\u00edsticas nuevas. Al mantener tu c\u00f3digo actualizado, puedes aprovechar estas mejoras y mantenerlo en l\u00ednea con las \u00faltimas pr\u00e1cticas recomendadas. Mejorar la Legibilidad : pyupgrade puede realizar cambios que mejoran la legibilidad del c\u00f3digo. Por ejemplo, puede convertir el uso de str.format() en f-strings, lo que hace que las cadenas de formato sean m\u00e1s claras y concisas. Eliminar Obsolescencias : Python introduce obsolescencias (deprecations) en versiones posteriores para indicar que ciertas caracter\u00edsticas o bibliotecas ya no se recomiendan. pyupgrade puede ayudarte a eliminar esas obsolescencias de manera autom\u00e1tica. Est\u00e1ndares de C\u00f3digo : pyupgrade puede ayudarte a cumplir con los est\u00e1ndares de c\u00f3digo de Python y seguir las pautas de estilo recomendadas. Ejemplos de Actualizaciones Realizadas por pyupgrade A continuaci\u00f3n, se presentan algunos ejemplos de actualizaciones que pyupgrade puede realizar en tu c\u00f3digo: 1.- Set Literals En versiones recientes de Python, se introdujo una sintaxis m\u00e1s concisa para definir conjuntos (sets) llamada \"set literals\". pyupgrade puede convertir las definiciones de conjuntos obsoletas en set literals m\u00e1s legibles. Antes : my_set = set ([ 1 , 2 , 3 ]) Despu\u00e9s : my_set = { 1 , 2 , 3 } 2.- Dictionary Comprehensions Python admite \"dictionary comprehensions\" que permiten crear diccionarios de manera m\u00e1s eficiente y legible que utilizando bucles. pyupgrade puede actualizar las construcciones de diccionarios obsoletas a \"dictionary comprehensions\". Antes : my_dict = {} for i in range ( 5 ): my_dict [ i ] = i * i Despu\u00e9s : my_dict = { i : i * i for i in range ( 5 )} 3.- Format Specifiers Las \"f-strings\" introducidas en Python 3.6 ofrecen una forma m\u00e1s concisa y legible de formatear cadenas. pyupgrade puede convertir las llamadas a str.format() en f-strings. Antes : name = \"Alice\" age = 30 message = \"My name is {} and I am {} years old.\" . format ( name , age ) Despu\u00e9s : name = \"Alice\" age = 30 message = f \"My name is { name } and I am { age } years old.\" Estos son solo algunos ejemplos de las actualizaciones que pyupgrade puede realizar. La herramienta es altamente configurable y puede adaptarse a las necesidades de tu proyecto espec\u00edfico. Uso de pyupgrade Para utilizar pyupgrade, primero debes instalarlo mediante pip: pip install pyupgrade Luego, puedes ejecutar pyupgrade en un archivo o directorio de la siguiente manera: pyupgrade your_file.py pyupgrade analizar\u00e1 el c\u00f3digo en busca de oportunidades de actualizaci\u00f3n y realizar\u00e1 las modificaciones necesarias. Aseg\u00farate de revisar los cambios realizados por pyupgrade para garantizar que el c\u00f3digo siga funcionando como se esperaba. En resumen, pyupgrade es una herramienta valiosa para mantener tu c\u00f3digo Python actualizado y en l\u00ednea con las \u00faltimas mejores pr\u00e1cticas del lenguaje. Puede ahorrarte tiempo y esfuerzo al automatizar las actualizaciones y mejoras de c\u00f3digo, lo que te permite concentrarte en el desarrollo de nuevas caracter\u00edsticas y funcionalidades.","title":"pyupgrade"}]}