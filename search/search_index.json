{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Conceptos b\u00e1sicos sobre el dise\u00f1o de software Material El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk Contenidos tem\u00e1ticos Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Home"},{"location":"#home","text":"Conceptos b\u00e1sicos sobre el dise\u00f1o de software","title":"Home"},{"location":"#material","text":"El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk","title":"Material"},{"location":"#contenidos-tematicos","text":"Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Contenidos tem\u00e1ticos"},{"location":"oop/oop/","text":"Introducci\u00f3n La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop/#introduccion","text":"La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop_abstraccion/","text":"Abstracci\u00f3n La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430> M\u00e9todos en las subclases Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come Ejercicios Ejercicio 01 Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Abstraccion"},{"location":"oop/oop_abstraccion/#abstraccion","text":"La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430>","title":"Abstracci\u00f3n"},{"location":"oop/oop_abstraccion/#metodos-en-las-subclases","text":"Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come","title":"M\u00e9todos en las subclases"},{"location":"oop/oop_abstraccion/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_abstraccion/#ejercicio-01","text":"Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Ejercicio 01"},{"location":"oop/oop_acoplamiento/","text":"Acoplamiento en programaci\u00f3n El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte. Ejercicios Ejercicio 01 Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Acoplamiento"},{"location":"oop/oop_acoplamiento/#acoplamiento-en-programacion","text":"El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte.","title":"Acoplamiento en programaci\u00f3n"},{"location":"oop/oop_acoplamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_acoplamiento/#ejercicio-01","text":"Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Ejercicio 01"},{"location":"oop/oop_cohesion/","text":"Cohesi\u00f3n La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesion"},{"location":"oop/oop_cohesion/#cohesion","text":"La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesi\u00f3n"},{"location":"oop/oop_conceptos_basicos/","text":"Conceptos b\u00e1sicos Clases y objetos Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro). Definiendo atributos A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma. Definiendo m\u00e9todos Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments Tipos de m\u00e9todos Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" M\u00e9todos de instancia Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase M\u00e9todos de clase A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase. M\u00e9todos est\u00e1ticos Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta. Ejercicios Ejercicio 01 Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Conceptos B\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#conceptos-basicos","text":"","title":"Conceptos b\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#clases-y-objetos","text":"Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro).","title":"Clases y objetos"},{"location":"oop/oop_conceptos_basicos/#definiendo-atributos","text":"A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma.","title":"Definiendo atributos"},{"location":"oop/oop_conceptos_basicos/#definiendo-metodos","text":"Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments","title":"Definiendo m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#tipos-de-metodos","text":"Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\"","title":"Tipos de m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#metodos-de-instancia","text":"Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase","title":"M\u00e9todos de instancia"},{"location":"oop/oop_conceptos_basicos/#metodos-de-clase","text":"A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase.","title":"M\u00e9todos de clase"},{"location":"oop/oop_conceptos_basicos/#metodos-estaticos","text":"Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta.","title":"M\u00e9todos est\u00e1ticos"},{"location":"oop/oop_conceptos_basicos/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_conceptos_basicos/#ejercicio-01","text":"Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Ejercicio 01"},{"location":"oop/oop_encapsulamiento/","text":"Encapsulamiento El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo Decoradores Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d. Ejercicios Ejercicio 01 Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#encapsulamiento","text":"El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#decoradores","text":"Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d.","title":"Decoradores"},{"location":"oop/oop_encapsulamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_encapsulamiento/#ejercicio-01","text":"Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Ejercicio 01"},{"location":"oop/oop_herencia/","text":"Herencia La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n. Extendiendo y modificando m\u00e9todos Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar! Uso de super() En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis' Herencia m\u00faltiple Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>) Ejercicios Ejercicio 01 Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Herencia"},{"location":"oop/oop_herencia/#herencia","text":"La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n.","title":"Herencia"},{"location":"oop/oop_herencia/#extendiendo-y-modificando-metodos","text":"Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar!","title":"Extendiendo y modificando m\u00e9todos"},{"location":"oop/oop_herencia/#uso-de-super","text":"En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis'","title":"Uso de super()"},{"location":"oop/oop_herencia/#herencia-multiple","text":"Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>)","title":"Herencia m\u00faltiple"},{"location":"oop/oop_herencia/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_herencia/#ejercicio-01","text":"Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Ejercicio 01"},{"location":"oop/oop_polimorfismo/","text":"Polimorfismo en programaci\u00f3n El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu! Ejercicios Ejercicio 01 Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Polimorfismo"},{"location":"oop/oop_polimorfismo/#polimorfismo-en-programacion","text":"El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu!","title":"Polimorfismo en programaci\u00f3n"},{"location":"oop/oop_polimorfismo/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_polimorfismo/#ejercicio-01","text":"Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Ejercicio 01"},{"location":"patterns/comportamiento/","text":"Patrones de comportamiento Los patrones de comportamiento estudian las relaciones entre llamadas entre los diferentes objetos, normalmente ligados con la dimensi\u00f3n temporal. Chain of Responsibility Evita acoplar el emisor de una petici\u00f3n a su receptor, al dar a m\u00e1s de un objeto la posibilidad de responder a la petici\u00f3n. Crea una cadena con los objetos receptores y pasa la petici\u00f3n a trav\u00e9s de la cadena hasta que esta sea tratada por alg\u00fan objeto. Ejemplo # patron class Handler : def __init__ ( self ): self . __succesor__ = None def set_succesor ( self , succesor ): self . __succesor__ = succesor def handler_request ( self , opt ): pass class HandlerOptionOne ( Handler ): def handler_request ( self , opt ): if opt == 1 : print ( \"Domingo\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionTwo ( Handler ): def handler_request ( self , opt ): if opt == 2 : print ( \"Lunes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionThree ( Handler ): def handler_request ( self , opt ): if opt == 3 : print ( \"Martes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFour ( Handler ): def handler_request ( self , opt ): if opt == 4 : print ( \"Miercoles\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFive ( Handler ): def handler_request ( self , opt ): if opt == 5 : print ( \"Jueves\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSix ( Handler ): def handler_request ( self , opt ): if opt == 6 : print ( \"Viernes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSeven ( Handler ): def handler_request ( self , opt ): if opt == 7 : print ( \"Sabado\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionDefault ( Handler ): def handler_request ( self , opt ): print ( \"Opci\u00f3n no valida\" ) # ejemplo class EjemploCadena : def obtener_nombre ( self ): return \"Chain of responsability\" def operacion ( self , opcion = 5 ): cadena = [ HandlerOptionSix (), HandlerOptionTwo (), HandlerOptionThree (), HandlerOptionFour (), HandlerOptionFive (), HandlerOptionOne (), HandlerOptionSeven (), HandlerOptionDefault ()] for i in range ( len ( cadena ) - 1 ): cadena [ i ] . set_succesor ( cadena [ i + 1 ]) #opcion = int(input(\"ingrese un n\u00famero: \")) cadena [ 0 ] . handler_request ( opcion ) # resultado EjemploCadena () . operacion () Jueves Command Encapsula una petici\u00f3n en un objeto, permitiendo as\u00ed parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer la operaciones. # patron class Command : def execute ( self , recivier ): pass class Recivier (): def show_message ( self , msg ): print ( msg ) class DomesticEngineer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take out the trash\" ) class Politician ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take the money from the rich, take the votes from poor\" ) class Programmer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"sell the bugs, charge extra for the fixes\" ) # ejemplo class EjemploCommand : def obtener_nombre ( self ): return \"Command\" def operacion ( self ): comandos = [ Politician (), DomesticEngineer (), Programmer ()] r = Recivier () for i in comandos : i . execute ( r ) # resultado EjemploCommand () . operacion () take the money from the rich, take the votes from poor take out the trash sell the bugs, charge extra for the fixes Interpreter Dado un lenguaje, define una representaci\u00f3n de su gram\u00e1tica junto con un int\u00e9rprete que usa dicha representaci\u00f3n para interpretar las sentencias del lenguaje. # patron class Expresion : def __init__ ( self , value = None , left = None , right = None ): self . __value__ = value self . __left__ = left self . __right__ = right class ExpresionNumber ( Expresion ): def evaluate ( self ): return int ( self . __value__ ) class ExpresionPluss ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () + self . __right__ . evaluate () class ExpresionMinus ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () - self . __right__ . evaluate () # ejemplo class EjemploInterpreter : def obtener_nombre ( self ): return \"Interpreter\" def operacion ( self ): operacion = ExpresionPluss ( left = ExpresionNumber ( value = '15' ), right = ExpresionMinus ( left = ExpresionNumber ( value = '25' ), right = ExpresionNumber ( value = '5' ))) print ( operacion . evaluate ()) # resultado EjemploInterpreter () . operacion () 35 Otros Patrones Iterator: Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representaci\u00f3n interna. Mediator: Define un objeto que encapsula c\u00f3mo interact\u00faan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros expl\u00edcitamente, y permite variar la interacci\u00f3n entre ellos de forma independiente. Memento: Representa y externaliza el estado interno de un objeto sin violar la encapsulaci\u00f3n, de forma que \u00e9ste puede volver a dicho estado m\u00e1s tarde. Observer: Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambia de estado se notifica y actualizan autom\u00e1ticamente todos los objetos. State: Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecer\u00e1 que cambia la clase del objeto. Strategy: Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo var\u00ede independientemente de los clientes que lo usan. Template Method: Define en una operaci\u00f3n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura. Visitor: Representa una operaci\u00f3n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci\u00f3n sin cambiar las clases de los elementos sobre los que opera.","title":"Patrones de comportamiento"},{"location":"patterns/comportamiento/#patrones-de-comportamiento","text":"Los patrones de comportamiento estudian las relaciones entre llamadas entre los diferentes objetos, normalmente ligados con la dimensi\u00f3n temporal.","title":"Patrones de comportamiento"},{"location":"patterns/comportamiento/#chain-of-responsibility","text":"Evita acoplar el emisor de una petici\u00f3n a su receptor, al dar a m\u00e1s de un objeto la posibilidad de responder a la petici\u00f3n. Crea una cadena con los objetos receptores y pasa la petici\u00f3n a trav\u00e9s de la cadena hasta que esta sea tratada por alg\u00fan objeto.","title":"Chain of Responsibility"},{"location":"patterns/comportamiento/#ejemplo","text":"# patron class Handler : def __init__ ( self ): self . __succesor__ = None def set_succesor ( self , succesor ): self . __succesor__ = succesor def handler_request ( self , opt ): pass class HandlerOptionOne ( Handler ): def handler_request ( self , opt ): if opt == 1 : print ( \"Domingo\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionTwo ( Handler ): def handler_request ( self , opt ): if opt == 2 : print ( \"Lunes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionThree ( Handler ): def handler_request ( self , opt ): if opt == 3 : print ( \"Martes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFour ( Handler ): def handler_request ( self , opt ): if opt == 4 : print ( \"Miercoles\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFive ( Handler ): def handler_request ( self , opt ): if opt == 5 : print ( \"Jueves\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSix ( Handler ): def handler_request ( self , opt ): if opt == 6 : print ( \"Viernes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSeven ( Handler ): def handler_request ( self , opt ): if opt == 7 : print ( \"Sabado\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionDefault ( Handler ): def handler_request ( self , opt ): print ( \"Opci\u00f3n no valida\" ) # ejemplo class EjemploCadena : def obtener_nombre ( self ): return \"Chain of responsability\" def operacion ( self , opcion = 5 ): cadena = [ HandlerOptionSix (), HandlerOptionTwo (), HandlerOptionThree (), HandlerOptionFour (), HandlerOptionFive (), HandlerOptionOne (), HandlerOptionSeven (), HandlerOptionDefault ()] for i in range ( len ( cadena ) - 1 ): cadena [ i ] . set_succesor ( cadena [ i + 1 ]) #opcion = int(input(\"ingrese un n\u00famero: \")) cadena [ 0 ] . handler_request ( opcion ) # resultado EjemploCadena () . operacion () Jueves","title":"Ejemplo"},{"location":"patterns/comportamiento/#command","text":"Encapsula una petici\u00f3n en un objeto, permitiendo as\u00ed parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer la operaciones. # patron class Command : def execute ( self , recivier ): pass class Recivier (): def show_message ( self , msg ): print ( msg ) class DomesticEngineer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take out the trash\" ) class Politician ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take the money from the rich, take the votes from poor\" ) class Programmer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"sell the bugs, charge extra for the fixes\" ) # ejemplo class EjemploCommand : def obtener_nombre ( self ): return \"Command\" def operacion ( self ): comandos = [ Politician (), DomesticEngineer (), Programmer ()] r = Recivier () for i in comandos : i . execute ( r ) # resultado EjemploCommand () . operacion () take the money from the rich, take the votes from poor take out the trash sell the bugs, charge extra for the fixes","title":"Command"},{"location":"patterns/comportamiento/#interpreter","text":"Dado un lenguaje, define una representaci\u00f3n de su gram\u00e1tica junto con un int\u00e9rprete que usa dicha representaci\u00f3n para interpretar las sentencias del lenguaje. # patron class Expresion : def __init__ ( self , value = None , left = None , right = None ): self . __value__ = value self . __left__ = left self . __right__ = right class ExpresionNumber ( Expresion ): def evaluate ( self ): return int ( self . __value__ ) class ExpresionPluss ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () + self . __right__ . evaluate () class ExpresionMinus ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () - self . __right__ . evaluate () # ejemplo class EjemploInterpreter : def obtener_nombre ( self ): return \"Interpreter\" def operacion ( self ): operacion = ExpresionPluss ( left = ExpresionNumber ( value = '15' ), right = ExpresionMinus ( left = ExpresionNumber ( value = '25' ), right = ExpresionNumber ( value = '5' ))) print ( operacion . evaluate ()) # resultado EjemploInterpreter () . operacion () 35","title":"Interpreter"},{"location":"patterns/comportamiento/#otros-patrones","text":"Iterator: Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representaci\u00f3n interna. Mediator: Define un objeto que encapsula c\u00f3mo interact\u00faan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros expl\u00edcitamente, y permite variar la interacci\u00f3n entre ellos de forma independiente. Memento: Representa y externaliza el estado interno de un objeto sin violar la encapsulaci\u00f3n, de forma que \u00e9ste puede volver a dicho estado m\u00e1s tarde. Observer: Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambia de estado se notifica y actualizan autom\u00e1ticamente todos los objetos. State: Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecer\u00e1 que cambia la clase del objeto. Strategy: Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo var\u00ede independientemente de los clientes que lo usan. Template Method: Define en una operaci\u00f3n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura. Visitor: Representa una operaci\u00f3n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci\u00f3n sin cambiar las clases de los elementos sobre los que opera.","title":"Otros Patrones"},{"location":"patterns/creacionales/","text":"Patrones de creaci\u00f3n Los patrones de creaci\u00f3n abstraen la forma en la que se crean los objetos, permitiendo tratar las clases a crear de forma gen\u00e9rica dejando para m\u00e1s tarde la decisi\u00f3n de qu\u00e9 clases crear o c\u00f3mo crearlas. Singleton Garantiza que una clase s\u00f3lo tenga una instancia, y proporciona un punto de acceso global a ella. # patron class Singleton (): _instance = None _value = 0 @classmethod def get_instance ( cls ): # Constructor alternativo que retorna una nueva instancia if not cls . _instance : cls . _instance = cls () return cls . _instance def get_value ( self ): return self . _value def set_value ( self , v ): self . _value = v # ejemplo class EjemploSingleton : def obtener_nombre ( self ): return \"Singleton\" def operacion ( self ): print ( \"Ejemplo Singleton\" ) x = Singleton . get_instance () y = Singleton . get_instance () print ( x is y ) y . set_value ( 10 ) print ( x . get_value ()) #resultado EjemploSingleton () . operacion () Ejemplo Singleton True 10 Prototype Especifica los tipos de objetos a crear por medio de una instancia protot\u00edpica, y crear nuevos objetos copiando este prototipo. # ejemplo from abc import ABC , abstractmethod from copy import copy , deepcopy class Animal ( ABC ): def __init__ ( self ): self . __description__ = \"\" self . __number_of_legs__ = 0 self . __name__ = \"\" self . __owner__ = None def hello_animal ( self ): return \"hi i am a \" + self . __name__ + \" and i have \" + str ( self . __number_of_legs__ ) + \" legs, property of: \" + self . __owner__ . get_name () def set_owner ( self , owner ): self . __owner__ = owner ; def get_owner ( self ): return self . __owner__ def change_owner ( self , name ): self . __owner__ . set_name ( name ) def set_description ( self , description ): self . __description__ = description ; def get_description ( self ): return self . __description__ def get_name ( self ): return self . __name__ def set_name ( self , name ): self . __name__ = name ; def get_number_of_legs ( self ): return self . __number_of_legs__ def set_number_of_legs ( self , number_of_legs ): self . __number_of_legs__ = number_of_legs def clone ( self ): return deepcopy ( self ) class Sheep ( Animal ): pass class Chicken ( Animal ): pass class Owner (): def __init__ ( self , name ): self . __name__ = name def get_name ( self ): return self . __name__ ; def set_name ( self , name ): self . __name__ = name ; class AnimalCreator (): def __init__ ( self ): self . __chicken__ = Chicken () self . __sheep__ = Sheep () self . __chicken__ . set_owner ( Owner ( \"Juan\" )) self . __chicken__ . set_description ( \"a litle chicken\" ) self . __chicken__ . set_name ( \"chicken\" ) self . __chicken__ . set_number_of_legs ( 2 ) self . __sheep__ . set_owner ( Owner ( \"Juan\" )) self . __sheep__ . set_description ( \"a litle sheep\" ) self . __sheep__ . set_name ( \"sheep\" ) self . __sheep__ . set_number_of_legs ( 4 ) def retrieve_animal ( self , kind_of_animal ): if \"Chicken\" == kind_of_animal : return self . __chicken__ . clone () elif \"Sheep\" == kind_of_animal : return self . __sheep__ . clone () return None # ejemplo class EjemploPrototype : def obtener_nombre ( self ): return \"Prototype\" def operacion ( self ): print ( \"Ejemplo prototype\" ) creator = AnimalCreator () animals = [] for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Chicken\" )) for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Sheep\" )) for i in animals : print ( i . hello_animal ()) animals [ 4 ] . change_owner ( \"Alejandro\" ) for i in animals : print ( i . hello_animal ()) # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan Abstract Factory Proporciona una interfaz para crear familias de objetos o que dependen entre s\u00ed, sin especificar sus clases concretas. # patron from abc import ABC , abstractmethod class Memoria ( ABC ): def implementacion ( self ): print ( \"instalando memoria\" ) @abstractmethod def operacion ( self ): pass class Board ( ABC ): def implementacion ( self ): print ( \"instalando board\" ) @abstractmethod def operacion ( self ): pass class Procesador ( ABC ): def implementacion ( self ): print ( \"instalando procesador\" ) @abstractmethod def operacion ( self ): pass class MemoriaAMD ( Memoria ): def operacion ( self ): print ( \"operando memoria AMD\" ) class BoardAMD ( Board ): def operacion ( self ): print ( \"operando board AMD\" ) class ProcesadorAMD ( Procesador ): def operacion ( self ): print ( \"operando procesador AMD\" ) class MemoriaIntel ( Memoria ): def operacion ( self ): print ( \"operando memoria Intel\" ) class BoardIntel ( Board ): def operacion ( self ): print ( \"operando board Intel\" ) class ProcesadorIntel ( Procesador ): def operacion ( self ): print ( \"operando procesador Intel\" ) class MemoriaAlien ( Memoria ): def operacion ( self ): print ( \"operando memoria Alien\" ) class BoardAlien ( Board ): def operacion ( self ): print ( \"operando board Alien\" ) class ProcesadorAlien ( Procesador ): def operacion ( self ): print ( \"operando procesador Alien\" ) class FabricaAbstracta ( ABC ): @abstractmethod def crearMemoria ( self ): pass @abstractmethod def crearProcesador ( self ): pass @abstractmethod def crearBoard ( self ): pass class FabricaAMD ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAMD () def crearProcesador ( self ): return ProcesadorAMD () def crearBoard ( self ): return BoardAMD () class FabricaIntel ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaIntel () def crearProcesador ( self ): return ProcesadorIntel () def crearBoard ( self ): return BoardIntel () class FabricaAlien ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAlien () def crearProcesador ( self ): return ProcesadorAlien () def crearBoard ( self ): return BoardAlien () # ejemplo class EjemploAbstractFactory : def obtener_nombre ( self ): return \"AbstractFactory\" def operacion ( self ): print ( \"Ejemplo Abstract Factory\" ) print ( \"seleccione una fabrica: \\n\\t 0 - AMD \\n\\t 1 - Intel \\n\\t 2 - Alien \" ) fabricas = [ FabricaAMD (), FabricaIntel (), FabricaAlien ()] fabrica = fabricas [ int ( input ())] partes = [ fabrica . crearMemoria (), fabrica . crearProcesador (), fabrica . crearBoard ()] for p in partes : p . implementacion () p . operacion () # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan Otros patrones Builder: Separa la construcci\u00f3n de un objeto complejo de su representaci\u00f3n, de forma que el mismo proceso de construcci\u00f3n pueda crear diferentes representaciones. Factory Method: Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qu\u00e9 clase instanciar. Permite que una clase delegue en sus subclases la creaci\u00f3n de objetos.","title":"Patrones de creaci\u00f3n"},{"location":"patterns/creacionales/#patrones-de-creacion","text":"Los patrones de creaci\u00f3n abstraen la forma en la que se crean los objetos, permitiendo tratar las clases a crear de forma gen\u00e9rica dejando para m\u00e1s tarde la decisi\u00f3n de qu\u00e9 clases crear o c\u00f3mo crearlas.","title":"Patrones de creaci\u00f3n"},{"location":"patterns/creacionales/#singleton","text":"Garantiza que una clase s\u00f3lo tenga una instancia, y proporciona un punto de acceso global a ella. # patron class Singleton (): _instance = None _value = 0 @classmethod def get_instance ( cls ): # Constructor alternativo que retorna una nueva instancia if not cls . _instance : cls . _instance = cls () return cls . _instance def get_value ( self ): return self . _value def set_value ( self , v ): self . _value = v # ejemplo class EjemploSingleton : def obtener_nombre ( self ): return \"Singleton\" def operacion ( self ): print ( \"Ejemplo Singleton\" ) x = Singleton . get_instance () y = Singleton . get_instance () print ( x is y ) y . set_value ( 10 ) print ( x . get_value ()) #resultado EjemploSingleton () . operacion () Ejemplo Singleton True 10","title":"Singleton"},{"location":"patterns/creacionales/#prototype","text":"Especifica los tipos de objetos a crear por medio de una instancia protot\u00edpica, y crear nuevos objetos copiando este prototipo. # ejemplo from abc import ABC , abstractmethod from copy import copy , deepcopy class Animal ( ABC ): def __init__ ( self ): self . __description__ = \"\" self . __number_of_legs__ = 0 self . __name__ = \"\" self . __owner__ = None def hello_animal ( self ): return \"hi i am a \" + self . __name__ + \" and i have \" + str ( self . __number_of_legs__ ) + \" legs, property of: \" + self . __owner__ . get_name () def set_owner ( self , owner ): self . __owner__ = owner ; def get_owner ( self ): return self . __owner__ def change_owner ( self , name ): self . __owner__ . set_name ( name ) def set_description ( self , description ): self . __description__ = description ; def get_description ( self ): return self . __description__ def get_name ( self ): return self . __name__ def set_name ( self , name ): self . __name__ = name ; def get_number_of_legs ( self ): return self . __number_of_legs__ def set_number_of_legs ( self , number_of_legs ): self . __number_of_legs__ = number_of_legs def clone ( self ): return deepcopy ( self ) class Sheep ( Animal ): pass class Chicken ( Animal ): pass class Owner (): def __init__ ( self , name ): self . __name__ = name def get_name ( self ): return self . __name__ ; def set_name ( self , name ): self . __name__ = name ; class AnimalCreator (): def __init__ ( self ): self . __chicken__ = Chicken () self . __sheep__ = Sheep () self . __chicken__ . set_owner ( Owner ( \"Juan\" )) self . __chicken__ . set_description ( \"a litle chicken\" ) self . __chicken__ . set_name ( \"chicken\" ) self . __chicken__ . set_number_of_legs ( 2 ) self . __sheep__ . set_owner ( Owner ( \"Juan\" )) self . __sheep__ . set_description ( \"a litle sheep\" ) self . __sheep__ . set_name ( \"sheep\" ) self . __sheep__ . set_number_of_legs ( 4 ) def retrieve_animal ( self , kind_of_animal ): if \"Chicken\" == kind_of_animal : return self . __chicken__ . clone () elif \"Sheep\" == kind_of_animal : return self . __sheep__ . clone () return None # ejemplo class EjemploPrototype : def obtener_nombre ( self ): return \"Prototype\" def operacion ( self ): print ( \"Ejemplo prototype\" ) creator = AnimalCreator () animals = [] for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Chicken\" )) for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Sheep\" )) for i in animals : print ( i . hello_animal ()) animals [ 4 ] . change_owner ( \"Alejandro\" ) for i in animals : print ( i . hello_animal ()) # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan","title":"Prototype"},{"location":"patterns/creacionales/#abstract-factory","text":"Proporciona una interfaz para crear familias de objetos o que dependen entre s\u00ed, sin especificar sus clases concretas. # patron from abc import ABC , abstractmethod class Memoria ( ABC ): def implementacion ( self ): print ( \"instalando memoria\" ) @abstractmethod def operacion ( self ): pass class Board ( ABC ): def implementacion ( self ): print ( \"instalando board\" ) @abstractmethod def operacion ( self ): pass class Procesador ( ABC ): def implementacion ( self ): print ( \"instalando procesador\" ) @abstractmethod def operacion ( self ): pass class MemoriaAMD ( Memoria ): def operacion ( self ): print ( \"operando memoria AMD\" ) class BoardAMD ( Board ): def operacion ( self ): print ( \"operando board AMD\" ) class ProcesadorAMD ( Procesador ): def operacion ( self ): print ( \"operando procesador AMD\" ) class MemoriaIntel ( Memoria ): def operacion ( self ): print ( \"operando memoria Intel\" ) class BoardIntel ( Board ): def operacion ( self ): print ( \"operando board Intel\" ) class ProcesadorIntel ( Procesador ): def operacion ( self ): print ( \"operando procesador Intel\" ) class MemoriaAlien ( Memoria ): def operacion ( self ): print ( \"operando memoria Alien\" ) class BoardAlien ( Board ): def operacion ( self ): print ( \"operando board Alien\" ) class ProcesadorAlien ( Procesador ): def operacion ( self ): print ( \"operando procesador Alien\" ) class FabricaAbstracta ( ABC ): @abstractmethod def crearMemoria ( self ): pass @abstractmethod def crearProcesador ( self ): pass @abstractmethod def crearBoard ( self ): pass class FabricaAMD ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAMD () def crearProcesador ( self ): return ProcesadorAMD () def crearBoard ( self ): return BoardAMD () class FabricaIntel ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaIntel () def crearProcesador ( self ): return ProcesadorIntel () def crearBoard ( self ): return BoardIntel () class FabricaAlien ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAlien () def crearProcesador ( self ): return ProcesadorAlien () def crearBoard ( self ): return BoardAlien () # ejemplo class EjemploAbstractFactory : def obtener_nombre ( self ): return \"AbstractFactory\" def operacion ( self ): print ( \"Ejemplo Abstract Factory\" ) print ( \"seleccione una fabrica: \\n\\t 0 - AMD \\n\\t 1 - Intel \\n\\t 2 - Alien \" ) fabricas = [ FabricaAMD (), FabricaIntel (), FabricaAlien ()] fabrica = fabricas [ int ( input ())] partes = [ fabrica . crearMemoria (), fabrica . crearProcesador (), fabrica . crearBoard ()] for p in partes : p . implementacion () p . operacion () # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan","title":"Abstract Factory"},{"location":"patterns/creacionales/#otros-patrones","text":"Builder: Separa la construcci\u00f3n de un objeto complejo de su representaci\u00f3n, de forma que el mismo proceso de construcci\u00f3n pueda crear diferentes representaciones. Factory Method: Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qu\u00e9 clase instanciar. Permite que una clase delegue en sus subclases la creaci\u00f3n de objetos.","title":"Otros patrones"},{"location":"patterns/estructurales/","text":"Patrones estructurales Tratan de conseguir que cambios en los requisitos de la aplicaci\u00f3n no ocasionen cambios en las relaciones entre los objetos. Lo fundamental son las relaciones de uso entre los objetos, y, \u00e9stas est\u00e1n determinadas por las interfaces que soportan los objetos. Estudian como se relacionan los objetos en tiempo de ejecuci\u00f3n. Sirven para dise\u00f1ar las interconexiones entre los objetos. Adapter Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permiten que cooperen clases que de otra manera no podr\u00edan por tener interfaces incompatibles. # patron class Adaptado (): def escribir_reves ( self ): return \"retpada ed olpmeje nU\" class Objetivo (): def escribir ( self ): pass class Original ( Objetivo ): def escribir ( self ): return \"Un ejemplo de adapter\" class Adaptador ( Objetivo ): def __init__ ( self ): self . __adaptado__ = Adaptado () def escribir ( self ): return \"(Traduccion) \" + (( self . __adaptado__ . escribir_reves ())[:: - 1 ]) # ejemplo class EjemploAdapter : def obtener_nombre ( self ): return \"Adapter\" def operacion ( self ): print ( \"Ejemplo adapter\" ) print ( \"Objeto original\" ) original = Original () print ( original . escribir ()) print ( \"Objeto a adaptar\" ) adaptado = Adaptado () print ( adaptado . escribir_reves ()) print ( \"Objeto adaptado\" ) adaptador = Adaptador () print ( adaptador . escribir ()) #resultado EjemploAdapter () . operacion () Ejemplo adapter Objeto original Un ejemplo de adapter Objeto a adaptar retpada ed olpmeje nU Objeto adaptado (Traduccion) Un ejemplo de adapter Bridge Desvincula una abstracci\u00f3n de su implementaci\u00f3n, de manera que ambas puedan variar de forma independiente. # patron class Abstraccion (): def __init__ ( self , implementador ): self . __imp__ = implementador def operacion ( self ): return self . __imp__ . operacion_implementada () class AbstraccionRefinada ( Abstraccion ): def operacion_refinada ( self ): return self . __imp__ . operacion_implementada_refinada () class Implementador (): def operacion_implementada ( self ): pass class ImplementadorRefinado ( Implementador ): def operacion_implementada_refinada ( self ): pass class ImplementadorConcretoA ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta A\" class ImplementadorConcretoB ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta B\" class ImpelmentadorConcretoC ( ImplementadorRefinado ): def operacion_implementada ( self ): return \"operacion concreta C\" def operacion_implementada_refinada ( self ): return \"operacion refinada C\" # ejemplo class EjemploBridge : def obtener_nombre ( self ): return \"Bridge\" def operacion ( self ): print ( \"Ejemplo bridge\" ) objeto = Abstraccion ( ImplementadorConcretoB ()) print ( objeto . operacion ()) objeto_refinado = AbstraccionRefinada ( ImpelmentadorConcretoC ()) print ( objeto_refinado . operacion ()) print ( objeto_refinado . operacion_refinada ()) # resultado EjemploBridge () . operacion () Ejemplo bridge operacion concreta B operacion concreta C operacion refinada C Composite Combina objetos en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos. # patron class Componente (): def operacion ( self ): pass class Compuesto ( Componente ): def __init__ ( self ): self . __elementos__ = [] def operacion ( self ): print ( \"operacion de compuesto\" ) for e in self . __elementos__ : e . operacion () def agregar_elemento ( self , elemento ): self . __elementos__ . append ( elemento ) class Simple ( Componente ): def operacion ( self ): print ( \"operacion simple\" ) # ejemplo class EjemploComposite : def obtener_nombre ( self ): return \"Composite\" def operacion ( self ): print ( \"Ejemplo composite\" ) elemento = Compuesto () for i in range ( 5 ): elemento . agregar_elemento ( Simple ()) elemento2 = Compuesto () elemento2 . agregar_elemento ( Simple ()) elemento . agregar_elemento ( elemento2 ) elemento . operacion () # resultado EjemploComposite () . operacion () Ejemplo composite operacion de compuesto operacion simple operacion simple operacion simple operacion simple operacion simple operacion de compuesto operacion simple Decorator A\u00f1ade din\u00e1micamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad. # patron class Componente (): def operacion ( self ): pass class ComponenteConcreto ( Componente ): def operacion ( self ): print ( \"operacion concreta\" ) class Decorador ( Componente ): def __init__ ( self , componente ): self . __comp__ = componente def operacion ( self ): pass class DecoradorConcretoA ( Decorador ): def operacion ( self ): print ( \"operacion decorada por A\" ) self . __comp__ . operacion () class DecoradorConcretoB ( Decorador ): def operacion ( self ): print ( \"operacion decorada por B\" ) self . __comp__ . operacion () # ejemplo class EjemploDecorator : def obtener_nombre ( self ): return \"Decorator\" def operacion ( self ): print ( \"Ejemplo decorator\" ) objeto = ComponenteConcreto () objeto . operacion () print ( \"-\" * 10 ) decorador1 = DecoradorConcretoA ( objeto ) decorador1 . operacion () print ( \"-\" * 10 ) decorador2 = DecoradorConcretoB ( decorador1 ) decorador2 . operacion () # resultado EjemploDecorator () . operacion () Ejemplo decorator operacion concreta ---------- operacion decorada por A operacion concreta ---------- operacion decorada por B operacion decorada por A operacion concreta Facade Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema se m\u00e1s f\u00e1cil de usar. # patron class BibliotecaLibros : def buscar_libros ( self ): return \"buscando libros\" class BibliotecaMusica : def buscar_musica ( self ): return \"buscando musica\" class BibliotecaVideos : def buscar_videos ( self ): return \"buscando videos\" class Fachada : def __init__ ( self ): self . biblioteca_libros = BibliotecaLibros () self . biblioteca_musica = BibliotecaMusica () self . biblioteca_videos = BibliotecaVideos () def buscar_libros ( self ): return self . biblioteca_libros . buscar_libros () def buscar_musica ( self ): return self . biblioteca_musica . buscar_musica () def buscar_videos ( self ): return self . biblioteca_videos . buscar_videos () # ejemplo class EjemploFachada : def obtener_nombre ( self ): return \"Fachada\" def operacion ( self ): print ( \"Ejemplo fachada\" ) fachada = Fachada () print ( fachada . buscar_libros ()) print ( fachada . buscar_musica ()) print ( fachada . buscar_videos ()) # resultado EjemploFachada () . operacion () Ejemplo fachada buscando libros buscando musica buscando videos Flyweight Usa el compartimiento para permitir un gran n\u00famero de objetos de grano fino de forma eficiente. # patron class Flyweight : def operacion ( self ): pass class ConcreteFlyweight ( Flyweight ): def operacion ( self ): return \"Operaci\u00f3n del peso ligero concreto clear\" class UnshareFlyweight ( Flyweight ): def __init__ ( self , concreto , contador ): self . concreto = concreto self . contador = contador def operacion ( self ): return self . concreto . operacion () + str ( self . contador ) class FlyweightFactory : def __init__ ( self ): self . concreto = None self . contador = 0 def entregar_flyweight ( self ): if self . concreto == None : self . concreto = ConcreteFlyweight () self . contador += 1 return UnshareFlyweight ( self . concreto , self . contador ) # ejemplo class EjemploFlyweight : def obtener_nombre ( self ): return \"Flyweight\" def operacion ( self ): print ( \"Ejemplo flyweight\" ) factoria = FlyweightFactory () flyweights = [] for i in range ( 10 ): flyweights . append ( factoria . entregar_flyweight ()) print ( flyweights [ 0 ] . concreto == flyweights [ 2 ] . concreto ) for f in flyweights : print ( f . operacion ()) # resultado EjemploFlyweight () . operacion () Ejemplo flyweight True Operaci\u00f3n del peso ligero concreto clear1 Operaci\u00f3n del peso ligero concreto clear2 Operaci\u00f3n del peso ligero concreto clear3 Operaci\u00f3n del peso ligero concreto clear4 Operaci\u00f3n del peso ligero concreto clear5 Operaci\u00f3n del peso ligero concreto clear6 Operaci\u00f3n del peso ligero concreto clear7 Operaci\u00f3n del peso ligero concreto clear8 Operaci\u00f3n del peso ligero concreto clear9 Operaci\u00f3n del peso ligero concreto clear10 Proxy Proporciona un sustituto o representante de otro objeto para controlar el acceso a \u00e9ste. # patron class Subject : def peticion ( self ): pass class RealSubject ( Subject ): def peticion ( self ): return \"operaci\u00f3n del objeto real\" class Proxy ( Subject ): def __init__ ( self , objeto ): self . objeto = objeto def peticion ( self ): return \"Mediante el proxy -> \" + self . objeto . peticion () # ejemplo class EjemploProxy : def obtener_nombre ( self ): return \"Proxy\" def operacion ( self ): print ( \"Ejemplo proxy\" ) proxy = Proxy ( RealSubject ()) print ( proxy . peticion ()) # resultado EjemploProxy () . operacion () Ejemplo proxy Mediante el proxy -> operaci\u00f3n del objeto real","title":"Patrones estructurales"},{"location":"patterns/estructurales/#patrones-estructurales","text":"Tratan de conseguir que cambios en los requisitos de la aplicaci\u00f3n no ocasionen cambios en las relaciones entre los objetos. Lo fundamental son las relaciones de uso entre los objetos, y, \u00e9stas est\u00e1n determinadas por las interfaces que soportan los objetos. Estudian como se relacionan los objetos en tiempo de ejecuci\u00f3n. Sirven para dise\u00f1ar las interconexiones entre los objetos.","title":"Patrones estructurales"},{"location":"patterns/estructurales/#adapter","text":"Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permiten que cooperen clases que de otra manera no podr\u00edan por tener interfaces incompatibles. # patron class Adaptado (): def escribir_reves ( self ): return \"retpada ed olpmeje nU\" class Objetivo (): def escribir ( self ): pass class Original ( Objetivo ): def escribir ( self ): return \"Un ejemplo de adapter\" class Adaptador ( Objetivo ): def __init__ ( self ): self . __adaptado__ = Adaptado () def escribir ( self ): return \"(Traduccion) \" + (( self . __adaptado__ . escribir_reves ())[:: - 1 ]) # ejemplo class EjemploAdapter : def obtener_nombre ( self ): return \"Adapter\" def operacion ( self ): print ( \"Ejemplo adapter\" ) print ( \"Objeto original\" ) original = Original () print ( original . escribir ()) print ( \"Objeto a adaptar\" ) adaptado = Adaptado () print ( adaptado . escribir_reves ()) print ( \"Objeto adaptado\" ) adaptador = Adaptador () print ( adaptador . escribir ()) #resultado EjemploAdapter () . operacion () Ejemplo adapter Objeto original Un ejemplo de adapter Objeto a adaptar retpada ed olpmeje nU Objeto adaptado (Traduccion) Un ejemplo de adapter","title":"Adapter"},{"location":"patterns/estructurales/#bridge","text":"Desvincula una abstracci\u00f3n de su implementaci\u00f3n, de manera que ambas puedan variar de forma independiente. # patron class Abstraccion (): def __init__ ( self , implementador ): self . __imp__ = implementador def operacion ( self ): return self . __imp__ . operacion_implementada () class AbstraccionRefinada ( Abstraccion ): def operacion_refinada ( self ): return self . __imp__ . operacion_implementada_refinada () class Implementador (): def operacion_implementada ( self ): pass class ImplementadorRefinado ( Implementador ): def operacion_implementada_refinada ( self ): pass class ImplementadorConcretoA ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta A\" class ImplementadorConcretoB ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta B\" class ImpelmentadorConcretoC ( ImplementadorRefinado ): def operacion_implementada ( self ): return \"operacion concreta C\" def operacion_implementada_refinada ( self ): return \"operacion refinada C\" # ejemplo class EjemploBridge : def obtener_nombre ( self ): return \"Bridge\" def operacion ( self ): print ( \"Ejemplo bridge\" ) objeto = Abstraccion ( ImplementadorConcretoB ()) print ( objeto . operacion ()) objeto_refinado = AbstraccionRefinada ( ImpelmentadorConcretoC ()) print ( objeto_refinado . operacion ()) print ( objeto_refinado . operacion_refinada ()) # resultado EjemploBridge () . operacion () Ejemplo bridge operacion concreta B operacion concreta C operacion refinada C","title":"Bridge"},{"location":"patterns/estructurales/#composite","text":"Combina objetos en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos. # patron class Componente (): def operacion ( self ): pass class Compuesto ( Componente ): def __init__ ( self ): self . __elementos__ = [] def operacion ( self ): print ( \"operacion de compuesto\" ) for e in self . __elementos__ : e . operacion () def agregar_elemento ( self , elemento ): self . __elementos__ . append ( elemento ) class Simple ( Componente ): def operacion ( self ): print ( \"operacion simple\" ) # ejemplo class EjemploComposite : def obtener_nombre ( self ): return \"Composite\" def operacion ( self ): print ( \"Ejemplo composite\" ) elemento = Compuesto () for i in range ( 5 ): elemento . agregar_elemento ( Simple ()) elemento2 = Compuesto () elemento2 . agregar_elemento ( Simple ()) elemento . agregar_elemento ( elemento2 ) elemento . operacion () # resultado EjemploComposite () . operacion () Ejemplo composite operacion de compuesto operacion simple operacion simple operacion simple operacion simple operacion simple operacion de compuesto operacion simple","title":"Composite"},{"location":"patterns/estructurales/#decorator","text":"A\u00f1ade din\u00e1micamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad. # patron class Componente (): def operacion ( self ): pass class ComponenteConcreto ( Componente ): def operacion ( self ): print ( \"operacion concreta\" ) class Decorador ( Componente ): def __init__ ( self , componente ): self . __comp__ = componente def operacion ( self ): pass class DecoradorConcretoA ( Decorador ): def operacion ( self ): print ( \"operacion decorada por A\" ) self . __comp__ . operacion () class DecoradorConcretoB ( Decorador ): def operacion ( self ): print ( \"operacion decorada por B\" ) self . __comp__ . operacion () # ejemplo class EjemploDecorator : def obtener_nombre ( self ): return \"Decorator\" def operacion ( self ): print ( \"Ejemplo decorator\" ) objeto = ComponenteConcreto () objeto . operacion () print ( \"-\" * 10 ) decorador1 = DecoradorConcretoA ( objeto ) decorador1 . operacion () print ( \"-\" * 10 ) decorador2 = DecoradorConcretoB ( decorador1 ) decorador2 . operacion () # resultado EjemploDecorator () . operacion () Ejemplo decorator operacion concreta ---------- operacion decorada por A operacion concreta ---------- operacion decorada por B operacion decorada por A operacion concreta","title":"Decorator"},{"location":"patterns/estructurales/#facade","text":"Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema se m\u00e1s f\u00e1cil de usar. # patron class BibliotecaLibros : def buscar_libros ( self ): return \"buscando libros\" class BibliotecaMusica : def buscar_musica ( self ): return \"buscando musica\" class BibliotecaVideos : def buscar_videos ( self ): return \"buscando videos\" class Fachada : def __init__ ( self ): self . biblioteca_libros = BibliotecaLibros () self . biblioteca_musica = BibliotecaMusica () self . biblioteca_videos = BibliotecaVideos () def buscar_libros ( self ): return self . biblioteca_libros . buscar_libros () def buscar_musica ( self ): return self . biblioteca_musica . buscar_musica () def buscar_videos ( self ): return self . biblioteca_videos . buscar_videos () # ejemplo class EjemploFachada : def obtener_nombre ( self ): return \"Fachada\" def operacion ( self ): print ( \"Ejemplo fachada\" ) fachada = Fachada () print ( fachada . buscar_libros ()) print ( fachada . buscar_musica ()) print ( fachada . buscar_videos ()) # resultado EjemploFachada () . operacion () Ejemplo fachada buscando libros buscando musica buscando videos","title":"Facade"},{"location":"patterns/estructurales/#flyweight","text":"Usa el compartimiento para permitir un gran n\u00famero de objetos de grano fino de forma eficiente. # patron class Flyweight : def operacion ( self ): pass class ConcreteFlyweight ( Flyweight ): def operacion ( self ): return \"Operaci\u00f3n del peso ligero concreto clear\" class UnshareFlyweight ( Flyweight ): def __init__ ( self , concreto , contador ): self . concreto = concreto self . contador = contador def operacion ( self ): return self . concreto . operacion () + str ( self . contador ) class FlyweightFactory : def __init__ ( self ): self . concreto = None self . contador = 0 def entregar_flyweight ( self ): if self . concreto == None : self . concreto = ConcreteFlyweight () self . contador += 1 return UnshareFlyweight ( self . concreto , self . contador ) # ejemplo class EjemploFlyweight : def obtener_nombre ( self ): return \"Flyweight\" def operacion ( self ): print ( \"Ejemplo flyweight\" ) factoria = FlyweightFactory () flyweights = [] for i in range ( 10 ): flyweights . append ( factoria . entregar_flyweight ()) print ( flyweights [ 0 ] . concreto == flyweights [ 2 ] . concreto ) for f in flyweights : print ( f . operacion ()) # resultado EjemploFlyweight () . operacion () Ejemplo flyweight True Operaci\u00f3n del peso ligero concreto clear1 Operaci\u00f3n del peso ligero concreto clear2 Operaci\u00f3n del peso ligero concreto clear3 Operaci\u00f3n del peso ligero concreto clear4 Operaci\u00f3n del peso ligero concreto clear5 Operaci\u00f3n del peso ligero concreto clear6 Operaci\u00f3n del peso ligero concreto clear7 Operaci\u00f3n del peso ligero concreto clear8 Operaci\u00f3n del peso ligero concreto clear9 Operaci\u00f3n del peso ligero concreto clear10","title":"Flyweight"},{"location":"patterns/estructurales/#proxy","text":"Proporciona un sustituto o representante de otro objeto para controlar el acceso a \u00e9ste. # patron class Subject : def peticion ( self ): pass class RealSubject ( Subject ): def peticion ( self ): return \"operaci\u00f3n del objeto real\" class Proxy ( Subject ): def __init__ ( self , objeto ): self . objeto = objeto def peticion ( self ): return \"Mediante el proxy -> \" + self . objeto . peticion () # ejemplo class EjemploProxy : def obtener_nombre ( self ): return \"Proxy\" def operacion ( self ): print ( \"Ejemplo proxy\" ) proxy = Proxy ( RealSubject ()) print ( proxy . peticion ()) # resultado EjemploProxy () . operacion () Ejemplo proxy Mediante el proxy -> operaci\u00f3n del objeto real","title":"Proxy"},{"location":"patterns/intro/","text":"Introducci\u00f3n El dise\u00f1o de software orientado a objetos es, en cierta forma, dif\u00edcil, si a esta tarea sumamos que el software dise\u00f1ado debe tener ciertas caracter\u00edsticas deseables como la reusabilidad, flexibilidad y portabilidad entre otras, la tarea es aun m\u00e1s dif\u00edcil. Algo que conocen muy bien los dise\u00f1adores con cierta experiencia, es que no se puede afrontar cada problema desde cero, por lo general reutilizan soluciones que han trabajado en el pasado y que han representado buenas soluciones a los problemas planteados. Si estas soluciones les sirven de manera recurrente y estas les brindan las caracter\u00edsticas deseables en el software mencionadas arriba, probablemente se encuentran ante un patr\u00f3n de dise\u00f1o. \u00bfQu\u00e9 son los patrones de dise\u00f1o? Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Los patrones de dise\u00f1o son un conjunto de pr\u00e1cticas de \u00f3ptimo dise\u00f1o que se utilizan para abordar problemas recurrentes en la programaci\u00f3n orientada a objetos. El concepto de patrones de dise\u00f1o fue el resultado de un trabajo realizado por un grupo de 4 personas Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides, (Gang of four) que se public\u00f3 en los 90s en un libro titulado \"Design Patterns. Elements of Reusable Object-Oriented Software\" en el que se esbozaban 23 patrones de dise\u00f1o. Un patr\u00f3n de dise\u00f1o puede considerarse como un documento que define una estructura de clases que aborda una situaci\u00f3n particular. Para que una soluci\u00f3n sea considerada un patr\u00f3n debe poseer ciertas caracter\u00edsticas. Una de ellas es que debe haber comprobado su efectividad resolviendo problemas similares en ocasiones anteriores. Otra es que debe ser reusable, lo que significa que es aplicable a diferentes problemas de dise\u00f1o en distintas circunstancias. Los patrones de dise\u00f1o representa un nivel de abstracci\u00f3n un poco mas elevado de lo que hasta ahora el estudiante esta habituado a trabajar, pero una vez entendido su funcionamiento y utilidad, los dise\u00f1os ser\u00e1n mucho m\u00e1s flexibles, modulares y reutilizables. En esencia un patr\u00f3n tiene los siguientes 4 elementos: Nombre del patr\u00f3n: describe el problema de dise\u00f1o, su soluci\u00f3n y consecuencias en una o dos palabras. El problema: describe cuando aplicar el patr\u00f3n, explica el problema y su contexto. La soluci\u00f3n: describe los elementos del dise\u00f1o, sus relaciones, responsabilidades y colaboraciones. No describe la implementaci\u00f3n o un dise\u00f1o particular espec\u00edficamente ya que se adapta mas a una plantilla (template) que puede ser aplicada a varias situaciones. Las consecuencias: son los resultados de aplicar el patr\u00f3n, los pros y contras de su aplicaci\u00f3n. Las consecuencias de la aplicaci\u00f3n de un patr\u00f3n debe incluir el impacto en la flexibilidad, extensibilidad y/o portabilidad del sistema. Estructuras o plantillas de patrones Para describir un patr\u00f3n se utilizan plantillas m\u00e1s o menos estandarizadas, de forma que se expresen uniformemente y puedan constituir efectivamente un medio de comunicaci\u00f3n uniforme entre dise\u00f1adores. La plantilla m\u00e1s com\u00fan es la utilizada precisamente por el \u201cGang of Four\u201d y consta de los siguientes apartados: Nombre del patr\u00f3n: nombre est\u00e1ndar del patr\u00f3n por el cual ser\u00e1 reconocido en la comunidad (normalmente se expresan en ingl\u00e9s). Clasificaci\u00f3n del patr\u00f3n: creacional, estructural o de comportamiento. Intenci\u00f3n: \u00bfQu\u00e9 problema pretende resolver el patr\u00f3n? Tambi\u00e9n conocido como: Otros nombres de uso com\u00fan para el patr\u00f3n. Motivaci\u00f3n: Escenario de ejemplo para la aplicaci\u00f3n del patr\u00f3n. Aplicabilidad: Usos comunes y criterios de aplicabilidad del patr\u00f3n. Estructura: Diagramas de clases oportunos para describir las clases que intervienen en el patr\u00f3n. Participantes: Enumeraci\u00f3n y descripci\u00f3n de las entidades abstractas (y sus roles) que participan en el patr\u00f3n. Colaboraciones: Explicaci\u00f3n de las interrelaciones que se dan entre los participantes. Consecuencias: Consecuencias positivas y negativas en el dise\u00f1o derivadas de la aplicaci\u00f3n del patr\u00f3n. Implementaci\u00f3n: T\u00e9cnicas o comentarios oportunos de cara a la implementaci\u00f3n del patr\u00f3n. C\u00f3digo de ejemplo: C\u00f3digo fuente ejemplo de implementaci\u00f3n del patr\u00f3n. Usos conocidos: Ejemplos de sistemas reales que usan el patr\u00f3n. Patrones relacionados: Referencias cruzadas con otros patrones. Referencias bibliogr\u00e1ficas Design Patterns. Elements of Reusable Object-Oriented Software - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides - Addison Wesley (GoF- Gang of Four) Patrones de Dise\u00f1o, Dise\u00f1o de Software Orientado a Objetos - Joaquin Garcia. http://www.ingenierosoftware.com/analisisydiseno/patrones-diseno.php. Patrones de dise\u00f1o - http://es.kioskea.net/contents/genie-logiciel/design-patterns.php3. Introducci\u00f3n al dise\u00f1o con patrones \u2013 Miguel Lagos Torres. http://www.elrincondelprogramador.com/default.asp?pag=articulos/leer.asp&id=29. Object Oriented Desing \u201cSoftware Desing Principles and Design Patters, http://www.oodesing.com","title":"Introduccion"},{"location":"patterns/intro/#introduccion","text":"El dise\u00f1o de software orientado a objetos es, en cierta forma, dif\u00edcil, si a esta tarea sumamos que el software dise\u00f1ado debe tener ciertas caracter\u00edsticas deseables como la reusabilidad, flexibilidad y portabilidad entre otras, la tarea es aun m\u00e1s dif\u00edcil. Algo que conocen muy bien los dise\u00f1adores con cierta experiencia, es que no se puede afrontar cada problema desde cero, por lo general reutilizan soluciones que han trabajado en el pasado y que han representado buenas soluciones a los problemas planteados. Si estas soluciones les sirven de manera recurrente y estas les brindan las caracter\u00edsticas deseables en el software mencionadas arriba, probablemente se encuentran ante un patr\u00f3n de dise\u00f1o.","title":"Introducci\u00f3n"},{"location":"patterns/intro/#que-son-los-patrones-de-diseno","text":"Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Los patrones de dise\u00f1o son un conjunto de pr\u00e1cticas de \u00f3ptimo dise\u00f1o que se utilizan para abordar problemas recurrentes en la programaci\u00f3n orientada a objetos. El concepto de patrones de dise\u00f1o fue el resultado de un trabajo realizado por un grupo de 4 personas Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides, (Gang of four) que se public\u00f3 en los 90s en un libro titulado \"Design Patterns. Elements of Reusable Object-Oriented Software\" en el que se esbozaban 23 patrones de dise\u00f1o. Un patr\u00f3n de dise\u00f1o puede considerarse como un documento que define una estructura de clases que aborda una situaci\u00f3n particular. Para que una soluci\u00f3n sea considerada un patr\u00f3n debe poseer ciertas caracter\u00edsticas. Una de ellas es que debe haber comprobado su efectividad resolviendo problemas similares en ocasiones anteriores. Otra es que debe ser reusable, lo que significa que es aplicable a diferentes problemas de dise\u00f1o en distintas circunstancias. Los patrones de dise\u00f1o representa un nivel de abstracci\u00f3n un poco mas elevado de lo que hasta ahora el estudiante esta habituado a trabajar, pero una vez entendido su funcionamiento y utilidad, los dise\u00f1os ser\u00e1n mucho m\u00e1s flexibles, modulares y reutilizables. En esencia un patr\u00f3n tiene los siguientes 4 elementos: Nombre del patr\u00f3n: describe el problema de dise\u00f1o, su soluci\u00f3n y consecuencias en una o dos palabras. El problema: describe cuando aplicar el patr\u00f3n, explica el problema y su contexto. La soluci\u00f3n: describe los elementos del dise\u00f1o, sus relaciones, responsabilidades y colaboraciones. No describe la implementaci\u00f3n o un dise\u00f1o particular espec\u00edficamente ya que se adapta mas a una plantilla (template) que puede ser aplicada a varias situaciones. Las consecuencias: son los resultados de aplicar el patr\u00f3n, los pros y contras de su aplicaci\u00f3n. Las consecuencias de la aplicaci\u00f3n de un patr\u00f3n debe incluir el impacto en la flexibilidad, extensibilidad y/o portabilidad del sistema.","title":"\u00bfQu\u00e9 son los patrones de dise\u00f1o?"},{"location":"patterns/intro/#estructuras-o-plantillas-de-patrones","text":"Para describir un patr\u00f3n se utilizan plantillas m\u00e1s o menos estandarizadas, de forma que se expresen uniformemente y puedan constituir efectivamente un medio de comunicaci\u00f3n uniforme entre dise\u00f1adores. La plantilla m\u00e1s com\u00fan es la utilizada precisamente por el \u201cGang of Four\u201d y consta de los siguientes apartados: Nombre del patr\u00f3n: nombre est\u00e1ndar del patr\u00f3n por el cual ser\u00e1 reconocido en la comunidad (normalmente se expresan en ingl\u00e9s). Clasificaci\u00f3n del patr\u00f3n: creacional, estructural o de comportamiento. Intenci\u00f3n: \u00bfQu\u00e9 problema pretende resolver el patr\u00f3n? Tambi\u00e9n conocido como: Otros nombres de uso com\u00fan para el patr\u00f3n. Motivaci\u00f3n: Escenario de ejemplo para la aplicaci\u00f3n del patr\u00f3n. Aplicabilidad: Usos comunes y criterios de aplicabilidad del patr\u00f3n. Estructura: Diagramas de clases oportunos para describir las clases que intervienen en el patr\u00f3n. Participantes: Enumeraci\u00f3n y descripci\u00f3n de las entidades abstractas (y sus roles) que participan en el patr\u00f3n. Colaboraciones: Explicaci\u00f3n de las interrelaciones que se dan entre los participantes. Consecuencias: Consecuencias positivas y negativas en el dise\u00f1o derivadas de la aplicaci\u00f3n del patr\u00f3n. Implementaci\u00f3n: T\u00e9cnicas o comentarios oportunos de cara a la implementaci\u00f3n del patr\u00f3n. C\u00f3digo de ejemplo: C\u00f3digo fuente ejemplo de implementaci\u00f3n del patr\u00f3n. Usos conocidos: Ejemplos de sistemas reales que usan el patr\u00f3n. Patrones relacionados: Referencias cruzadas con otros patrones.","title":"Estructuras o plantillas de patrones"},{"location":"patterns/intro/#referencias-bibliograficas","text":"Design Patterns. Elements of Reusable Object-Oriented Software - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides - Addison Wesley (GoF- Gang of Four) Patrones de Dise\u00f1o, Dise\u00f1o de Software Orientado a Objetos - Joaquin Garcia. http://www.ingenierosoftware.com/analisisydiseno/patrones-diseno.php. Patrones de dise\u00f1o - http://es.kioskea.net/contents/genie-logiciel/design-patterns.php3. Introducci\u00f3n al dise\u00f1o con patrones \u2013 Miguel Lagos Torres. http://www.elrincondelprogramador.com/default.asp?pag=articulos/leer.asp&id=29. Object Oriented Desing \u201cSoftware Desing Principles and Design Patters, http://www.oodesing.com","title":"Referencias bibliogr\u00e1ficas"},{"location":"setup/poetry/","text":"Poetry Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted. Instalaci\u00f3n Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda. osx / linux / bashonwindows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python - windows powershell (Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python - Crear un proyecto con poetry Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml . Una configuraci\u00f3n para manejar todo Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite. Poetry CLI La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml . Instalaci\u00f3n y gesti\u00f3n de dependencias poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Poetry"},{"location":"setup/poetry/#poetry","text":"Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted.","title":"Poetry"},{"location":"setup/poetry/#instalacion","text":"Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda.","title":"Instalaci\u00f3n"},{"location":"setup/poetry/#osx-linux-bashonwindows","text":"curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -","title":"osx / linux / bashonwindows"},{"location":"setup/poetry/#windows-powershell","text":"(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python -","title":"windows powershell"},{"location":"setup/poetry/#crear-un-proyecto-con-poetry","text":"Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml .","title":"Crear un proyecto con poetry"},{"location":"setup/poetry/#una-configuracion-para-manejar-todo","text":"Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite.","title":"Una configuraci\u00f3n para manejar todo"},{"location":"setup/poetry/#poetry-cli","text":"La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml .","title":"Poetry CLI"},{"location":"setup/poetry/#instalacion-y-gestion-de-dependencias","text":"poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Instalaci\u00f3n y gesti\u00f3n de dependencias"},{"location":"setup/pyenv/","text":"Pyenv Introducci\u00f3n Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables. Instalaci\u00f3n Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer Uso Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta. Recomendaciones Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Pyenv"},{"location":"setup/pyenv/#pyenv","text":"","title":"Pyenv"},{"location":"setup/pyenv/#introduccion","text":"Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables.","title":"Introducci\u00f3n"},{"location":"setup/pyenv/#instalacion","text":"Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer","title":"Instalaci\u00f3n"},{"location":"setup/pyenv/#uso","text":"Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta.","title":"Uso"},{"location":"setup/pyenv/#recomendaciones","text":"Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Recomendaciones"},{"location":"setup/virtualenv/","text":"Venv Introducci\u00f3n Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas: \u00bfPara qu\u00e9 se usan los entornos virtuales? Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios. \u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python? No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js \u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3? Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI . Creando ambientes virtuales Forma tradicional La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt Referencias venv \u2014 Creation of virtual environments","title":"Venv"},{"location":"setup/virtualenv/#venv","text":"","title":"Venv"},{"location":"setup/virtualenv/#introduccion","text":"Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas:","title":"Introducci\u00f3n"},{"location":"setup/virtualenv/#para-que-se-usan-los-entornos-virtuales","text":"Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios.","title":"\u00bfPara qu\u00e9 se usan los entornos virtuales?"},{"location":"setup/virtualenv/#los-entornos-virtuales-son-propios-solo-del-lenguaje-python","text":"No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js","title":"\u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python?"},{"location":"setup/virtualenv/#que-programa-necesito-para-crear-un-entorno-virtual-con-python-3","text":"Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI .","title":"\u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3?"},{"location":"setup/virtualenv/#creando-ambientes-virtuales","text":"","title":"Creando ambientes virtuales"},{"location":"setup/virtualenv/#forma-tradicional","text":"La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt","title":"Forma tradicional"},{"location":"setup/virtualenv/#referencias","text":"venv \u2014 Creation of virtual environments","title":"Referencias"},{"location":"solid/1_srp/","text":"Single Responsibility Principle \"... Ten\u00edas un trabajo\" - Loki a Skurge en Thor: Ragnarok. Una clase debe tener un solo trabajo. Si una clase tiene m\u00e1s de una responsabilidad, se acopla. Un cambio a una responsabilidad resulta en la modificaci\u00f3n de la otra responsabilidad. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def save ( self , animal : Animal ): pass La clase Animal viola el SRP. \u00bfC\u00f3mo viola SRP? SRP establece que las clases deben tener una responsabilidad, aqu\u00ed podemos establecer dos responsabilidades: gesti\u00f3n de bases de datos de animales y gesti\u00f3n de animales. El constructor y get_name administran las propiedades de la clase Animal mientras que el guardado administra el almacenamiento de la clase Animal en una base de datos. \u00bfC\u00f3mo causar\u00e1 problemas este dise\u00f1o en el futuro? Si la aplicaci\u00f3n cambia de una manera que afecta las funciones de administraci\u00f3n de la base de datos. Las clases que hacen uso de las propiedades de los animales deber\u00e1n modificarse y recompilarse para compensar los nuevos cambios. Es como un efecto domin\u00f3, toca una carta y afecta a todas las dem\u00e1s cartas en l\u00ednea. Para que esto se ajuste a SRP, creamos otra clase que manejar\u00e1 la responsabilidad exclusiva de almacenar un animal en una base de datos: class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ): pass class AnimalDB : def get_animal ( self , id ) -> Animal : pass def save ( self , animal : Animal ): pass Al dise\u00f1ar nuestras clases, debemos apuntar a juntar caracter\u00edsticas relacionadas, de modo que siempre que tiendan a cambiar, cambien por la misma raz\u00f3n. Y deber\u00edamos intentar separar las caracter\u00edsticas si cambian por diferentes razones. - Steve Fenton La desventaja de esta soluci\u00f3n es que los clientes de este c\u00f3digo tienen que lidiar con dos clases. Una soluci\u00f3n com\u00fan a este dilema es aplicar el patr\u00f3n de dise\u00f1o Facade . La clase de animales ser\u00e1 la fachada para la gesti\u00f3n de bases de datos de animales y la gesti\u00f3n de propiedades animales. class Animal : def __init__ ( self , name : str ): self . name = name self . db = AnimalDB () def get_name ( self ): return self . name def get ( self , id ): return self . db . get_animal ( id ) def save ( self ): self . db . save ( animal = self ) Los m\u00e9todos m\u00e1s importantes se guardan en la clase Animal y se utilizan como fachada para las funciones menores.","title":"Single Responsibility Principle"},{"location":"solid/1_srp/#single-responsibility-principle","text":"\"... Ten\u00edas un trabajo\" - Loki a Skurge en Thor: Ragnarok. Una clase debe tener un solo trabajo. Si una clase tiene m\u00e1s de una responsabilidad, se acopla. Un cambio a una responsabilidad resulta en la modificaci\u00f3n de la otra responsabilidad. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def save ( self , animal : Animal ): pass La clase Animal viola el SRP. \u00bfC\u00f3mo viola SRP? SRP establece que las clases deben tener una responsabilidad, aqu\u00ed podemos establecer dos responsabilidades: gesti\u00f3n de bases de datos de animales y gesti\u00f3n de animales. El constructor y get_name administran las propiedades de la clase Animal mientras que el guardado administra el almacenamiento de la clase Animal en una base de datos. \u00bfC\u00f3mo causar\u00e1 problemas este dise\u00f1o en el futuro? Si la aplicaci\u00f3n cambia de una manera que afecta las funciones de administraci\u00f3n de la base de datos. Las clases que hacen uso de las propiedades de los animales deber\u00e1n modificarse y recompilarse para compensar los nuevos cambios. Es como un efecto domin\u00f3, toca una carta y afecta a todas las dem\u00e1s cartas en l\u00ednea. Para que esto se ajuste a SRP, creamos otra clase que manejar\u00e1 la responsabilidad exclusiva de almacenar un animal en una base de datos: class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ): pass class AnimalDB : def get_animal ( self , id ) -> Animal : pass def save ( self , animal : Animal ): pass Al dise\u00f1ar nuestras clases, debemos apuntar a juntar caracter\u00edsticas relacionadas, de modo que siempre que tiendan a cambiar, cambien por la misma raz\u00f3n. Y deber\u00edamos intentar separar las caracter\u00edsticas si cambian por diferentes razones. - Steve Fenton La desventaja de esta soluci\u00f3n es que los clientes de este c\u00f3digo tienen que lidiar con dos clases. Una soluci\u00f3n com\u00fan a este dilema es aplicar el patr\u00f3n de dise\u00f1o Facade . La clase de animales ser\u00e1 la fachada para la gesti\u00f3n de bases de datos de animales y la gesti\u00f3n de propiedades animales. class Animal : def __init__ ( self , name : str ): self . name = name self . db = AnimalDB () def get_name ( self ): return self . name def get ( self , id ): return self . db . get_animal ( id ) def save ( self ): self . db . save ( animal = self ) Los m\u00e9todos m\u00e1s importantes se guardan en la clase Animal y se utilizan como fachada para las funciones menores.","title":"Single Responsibility Principle"},{"location":"solid/2_ocp/","text":"Open-Closed Principle Las entidades de software (clases, m\u00f3dulos, funciones) deben estar abiertas para extensi\u00f3n, no modificaci\u00f3n. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass animals = [ Animal ( 'lion' ), Animal ( 'mouse' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) animal_sound ( animals ) roar squeak La funci\u00f3n animal_sound no se ajusta al principio ocp puesto que no puede cerrarse frente a nuevos tipos de animales. Si agregamos un nuevo animal, Snake , tenemos que modificar la funci\u00f3n animal_sound . Ver\u00e1, para cada nuevo animal, se agrega una nueva l\u00f3gica a la funci\u00f3n animal_sound. \u00c9ste es un ejemplo bastante simple. Cuando su aplicaci\u00f3n crezca y se vuelva compleja, ver\u00e1 que la instrucci\u00f3n if se repetir\u00e1 una y otra vez en la funci\u00f3n animal_sound cada vez que se agregue un nuevo animal, en toda la aplicaci\u00f3n. animals = [ Animal ( 'lion' ), Animal ( 'mouse' ), Animal ( 'snake' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) elif animal . name == 'snake' : print ( 'hiss' ) animal_sound ( animals ) roar squeak hiss \u00bfC\u00f3mo lo hacemos (animal_sound) conforme a OCP? class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def make_sound ( self ): pass class Lion ( Animal ): def make_sound ( self ): return 'roar' class Mouse ( Animal ): def make_sound ( self ): return 'squeak' class Snake ( Animal ): def make_sound ( self ): return 'hiss' def animal_sound ( animals : list ): for animal in animals : print ( animal . make_sound ()) animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Snake ( name = \"Snake\" ), ] animal_sound ( animals ) roar squeak hiss Animal ahora tiene un m\u00e9todo virtual make_sound . Hacemos que cada animal extienda la clase Animal e implementemos el m\u00e9todo virtual make_sound . Cada animal agrega su propia implementaci\u00f3n sobre c\u00f3mo hace un sonido en make_sound . animal_sound itera a trav\u00e9s de la matriz de animal y simplemente llama a su m\u00e9todo make_sound . Ahora, si agregamos un nuevo animal, animal_sound no necesita cambiar. Todo lo que tenemos que hacer es agregar el nuevo animal a la matriz de animales. animal_sound ahora se ajusta al principio OCP. Otro ejemplo: Imaginemos que tiene una tienda y ofrece un descuento del 20% a sus clientes favoritos que usan esta clase: cuando decide ofrecer el doble del 20% de descuento a los clientes VIP. Puede modificar la clase de esta manera: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def give_discount ( self ): if self . customer == 'fav' : return self . price * 0.2 if self . customer == 'vip' : return self . price * 0.4 No, esto no cumple con el principio OCP. OCP lo proh\u00edbe. Si queremos dar un nuevo porcentaje de descuento, tal vez, a un diferencial. tipo de clientes, ver\u00e1 que se agregar\u00e1 una nueva l\u00f3gica. Para que siga el principio OCP, agregaremos una nueva clase que extender\u00e1 el descuento. En esta nueva clase, implementar\u00edamos su nuevo comportamiento: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def get_discount ( self ): return self . price * 0.2 class VIPDiscount ( Discount ): def get_discount ( self ): return super () . get_discount () * 2 Si decide un 80% de descuento para clientes super VIP, deber\u00eda ser as\u00ed: Ver\u00e1, extensi\u00f3n sin modificaci\u00f3n. class SuperVIPDiscount ( VIPDiscount ): def get_discount ( self ): return super () . get_discount () * 2","title":"Single Responsibility Principle"},{"location":"solid/2_ocp/#open-closed-principle","text":"Las entidades de software (clases, m\u00f3dulos, funciones) deben estar abiertas para extensi\u00f3n, no modificaci\u00f3n. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass animals = [ Animal ( 'lion' ), Animal ( 'mouse' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) animal_sound ( animals ) roar squeak La funci\u00f3n animal_sound no se ajusta al principio ocp puesto que no puede cerrarse frente a nuevos tipos de animales. Si agregamos un nuevo animal, Snake , tenemos que modificar la funci\u00f3n animal_sound . Ver\u00e1, para cada nuevo animal, se agrega una nueva l\u00f3gica a la funci\u00f3n animal_sound. \u00c9ste es un ejemplo bastante simple. Cuando su aplicaci\u00f3n crezca y se vuelva compleja, ver\u00e1 que la instrucci\u00f3n if se repetir\u00e1 una y otra vez en la funci\u00f3n animal_sound cada vez que se agregue un nuevo animal, en toda la aplicaci\u00f3n. animals = [ Animal ( 'lion' ), Animal ( 'mouse' ), Animal ( 'snake' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) elif animal . name == 'snake' : print ( 'hiss' ) animal_sound ( animals ) roar squeak hiss \u00bfC\u00f3mo lo hacemos (animal_sound) conforme a OCP? class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def make_sound ( self ): pass class Lion ( Animal ): def make_sound ( self ): return 'roar' class Mouse ( Animal ): def make_sound ( self ): return 'squeak' class Snake ( Animal ): def make_sound ( self ): return 'hiss' def animal_sound ( animals : list ): for animal in animals : print ( animal . make_sound ()) animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Snake ( name = \"Snake\" ), ] animal_sound ( animals ) roar squeak hiss Animal ahora tiene un m\u00e9todo virtual make_sound . Hacemos que cada animal extienda la clase Animal e implementemos el m\u00e9todo virtual make_sound . Cada animal agrega su propia implementaci\u00f3n sobre c\u00f3mo hace un sonido en make_sound . animal_sound itera a trav\u00e9s de la matriz de animal y simplemente llama a su m\u00e9todo make_sound . Ahora, si agregamos un nuevo animal, animal_sound no necesita cambiar. Todo lo que tenemos que hacer es agregar el nuevo animal a la matriz de animales. animal_sound ahora se ajusta al principio OCP. Otro ejemplo: Imaginemos que tiene una tienda y ofrece un descuento del 20% a sus clientes favoritos que usan esta clase: cuando decide ofrecer el doble del 20% de descuento a los clientes VIP. Puede modificar la clase de esta manera: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def give_discount ( self ): if self . customer == 'fav' : return self . price * 0.2 if self . customer == 'vip' : return self . price * 0.4 No, esto no cumple con el principio OCP. OCP lo proh\u00edbe. Si queremos dar un nuevo porcentaje de descuento, tal vez, a un diferencial. tipo de clientes, ver\u00e1 que se agregar\u00e1 una nueva l\u00f3gica. Para que siga el principio OCP, agregaremos una nueva clase que extender\u00e1 el descuento. En esta nueva clase, implementar\u00edamos su nuevo comportamiento: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def get_discount ( self ): return self . price * 0.2 class VIPDiscount ( Discount ): def get_discount ( self ): return super () . get_discount () * 2 Si decide un 80% de descuento para clientes super VIP, deber\u00eda ser as\u00ed: Ver\u00e1, extensi\u00f3n sin modificaci\u00f3n. class SuperVIPDiscount ( VIPDiscount ): def get_discount ( self ): return super () . get_discount () * 2","title":"Open-Closed Principle"},{"location":"solid/3_lsp/","text":"Liskov Substitution Principle Una subclase debe ser sustituible por su superclase. El objetivo de este principio es determinar que una subclase pueda asumir el lugar de su superclase sin errores. Si el c\u00f3digo se encuentra comprobando el tipo de clase, entonces debe haber violado este principio. Usemos nuestro ejemplo Animal . class Animal : def __init__ ( self , name : str ): self . name = name class Lion ( Animal ): pass class Mouse ( Animal ): pass class Pigeon ( Animal ): pass animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Pigeon ( name = \"Pigeon\" ), ] def animal_leg_count ( animals : list ): for animal in animals : if isinstance ( animal , Lion ): print ( lion_leg_count ( animal )) elif isinstance ( animal , Mouse ): print ( mouse_leg_count ( animal )) elif isinstance ( animal , Pigeon ): print ( pigeon_leg_count ( animal )) animal_leg_count ( animals ) --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-19-aad1b5d27670> in <module> 8 print(pigeon_leg_count(animal)) 9 ---> 10 animal_leg_count(animals) <ipython-input-19-aad1b5d27670> in animal_leg_count(animals) 2 for animal in animals: 3 if isinstance(animal, Lion): ----> 4 print(lion_leg_count(animal)) 5 elif isinstance(animal, Mouse): 6 print(mouse_leg_count(animal)) NameError: name 'lion_leg_count' is not defined Para que esta funci\u00f3n siga el principio LSP, seguiremos estos requisitos LSP postulados por Steve Fenton: Si la superclase ( Animal ) tiene un m\u00e9todo que acepta un par\u00e1metro de tipo de superclase ( Animal ). Su subclase ( Pigeon ) debe aceptar como argumento un tipo de superclase (tipo Animal ) o un tipo de subclase (tipo Pigeon ). Si la superclase devuelve un tipo de superclase ( Animal ). Su subclase deber\u00eda devolver un tipo de superclase (tipo Animal ) o un tipo de subclase ( Pigeon ). Ahora, podemos volver a implementar la funci\u00f3n animal_leg_count : def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animal_leg_count ( animals ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-17-98b6adbc243d> in <module> 3 print(animal.leg_count()) 4 ----> 5 animal_leg_count(animals) <ipython-input-17-98b6adbc243d> in animal_leg_count(animals) 1 def animal_leg_count(animals: list): 2 for animal in animals: ----> 3 print(animal.leg_count()) 4 5 animal_leg_count(animals) AttributeError: 'Lion' object has no attribute 'leg_count' A la funci\u00f3n animal_leg_count le importa menos el tipo de Animal pasado, simplemente llama al m\u00e9todo leg_count . Todo lo que sabe es que el par\u00e1metro debe ser de un tipo Animal , ya sea la clase Animal o su subclase. La clase Animal ahora tiene que implementar/definir un m\u00e9todo leg_count . Y sus subclases deben implementar el m\u00e9todo leg_count : class Animal : def leg_count ( self ): pass class Lion ( Animal ): def leg_count ( self ): return 4 class Mouse ( Animal ): def leg_count ( self ): return 4 class Pigeon ( Animal ): def leg_count ( self ): return 2 def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animals = [ Lion (), Mouse (), Pigeon (), ] animal_leg_count ( animals ) 4 4 2 Cuando se pasa a la funci\u00f3n animal_leg_count , devuelve el n\u00famero de patas que tiene un le\u00f3n. Ver\u00e1, animal_leg_count no necesita saber el tipo de Animal para devolver su recuento de patas, solo llama al m\u00e9todo leg_count del tipo Animal porque por contrato una subclase de la clase Animal debe implementar la funci\u00f3n leg_count .","title":"Liskov Substitution Principle"},{"location":"solid/3_lsp/#liskov-substitution-principle","text":"Una subclase debe ser sustituible por su superclase. El objetivo de este principio es determinar que una subclase pueda asumir el lugar de su superclase sin errores. Si el c\u00f3digo se encuentra comprobando el tipo de clase, entonces debe haber violado este principio. Usemos nuestro ejemplo Animal . class Animal : def __init__ ( self , name : str ): self . name = name class Lion ( Animal ): pass class Mouse ( Animal ): pass class Pigeon ( Animal ): pass animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Pigeon ( name = \"Pigeon\" ), ] def animal_leg_count ( animals : list ): for animal in animals : if isinstance ( animal , Lion ): print ( lion_leg_count ( animal )) elif isinstance ( animal , Mouse ): print ( mouse_leg_count ( animal )) elif isinstance ( animal , Pigeon ): print ( pigeon_leg_count ( animal )) animal_leg_count ( animals ) --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-19-aad1b5d27670> in <module> 8 print(pigeon_leg_count(animal)) 9 ---> 10 animal_leg_count(animals) <ipython-input-19-aad1b5d27670> in animal_leg_count(animals) 2 for animal in animals: 3 if isinstance(animal, Lion): ----> 4 print(lion_leg_count(animal)) 5 elif isinstance(animal, Mouse): 6 print(mouse_leg_count(animal)) NameError: name 'lion_leg_count' is not defined Para que esta funci\u00f3n siga el principio LSP, seguiremos estos requisitos LSP postulados por Steve Fenton: Si la superclase ( Animal ) tiene un m\u00e9todo que acepta un par\u00e1metro de tipo de superclase ( Animal ). Su subclase ( Pigeon ) debe aceptar como argumento un tipo de superclase (tipo Animal ) o un tipo de subclase (tipo Pigeon ). Si la superclase devuelve un tipo de superclase ( Animal ). Su subclase deber\u00eda devolver un tipo de superclase (tipo Animal ) o un tipo de subclase ( Pigeon ). Ahora, podemos volver a implementar la funci\u00f3n animal_leg_count : def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animal_leg_count ( animals ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-17-98b6adbc243d> in <module> 3 print(animal.leg_count()) 4 ----> 5 animal_leg_count(animals) <ipython-input-17-98b6adbc243d> in animal_leg_count(animals) 1 def animal_leg_count(animals: list): 2 for animal in animals: ----> 3 print(animal.leg_count()) 4 5 animal_leg_count(animals) AttributeError: 'Lion' object has no attribute 'leg_count' A la funci\u00f3n animal_leg_count le importa menos el tipo de Animal pasado, simplemente llama al m\u00e9todo leg_count . Todo lo que sabe es que el par\u00e1metro debe ser de un tipo Animal , ya sea la clase Animal o su subclase. La clase Animal ahora tiene que implementar/definir un m\u00e9todo leg_count . Y sus subclases deben implementar el m\u00e9todo leg_count : class Animal : def leg_count ( self ): pass class Lion ( Animal ): def leg_count ( self ): return 4 class Mouse ( Animal ): def leg_count ( self ): return 4 class Pigeon ( Animal ): def leg_count ( self ): return 2 def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animals = [ Lion (), Mouse (), Pigeon (), ] animal_leg_count ( animals ) 4 4 2 Cuando se pasa a la funci\u00f3n animal_leg_count , devuelve el n\u00famero de patas que tiene un le\u00f3n. Ver\u00e1, animal_leg_count no necesita saber el tipo de Animal para devolver su recuento de patas, solo llama al m\u00e9todo leg_count del tipo Animal porque por contrato una subclase de la clase Animal debe implementar la funci\u00f3n leg_count .","title":"Liskov Substitution Principle"},{"location":"solid/4_isp/","text":"Interface Segregation Principle Cree interfaces de grano fino que sean espec\u00edficas del cliente. Los clientes no deben verse obligados a depender de interfaces que no utilizan. Este principio se ocupa de las desventajas de implementar grandes interfaces. Veamos la siguiente interfaz de IShape : class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError Esta interfaz dibuja cuadrados, c\u00edrculos, rect\u00e1ngulos. La clase Circle , Square o Rectangle que implementa la interfaz IShape debe definir los m\u00e9todos draw_square() , draw_rectangle() , draw_circle() . class Circle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Square ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Rectangle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass La clase Rectangle implementa m\u00e9todos ( draw_circle y draw_square ) de los que no tiene uso, del mismo modo que Square implementa draw_circle , y draw_rectangle , y la clase Circle ( draw_square , draw_rectangle ). Si agregamos otro m\u00e9todo a la interfaz IShape , como draw_triangle() , class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError def draw_triangle ( self ): raise NotImplementedError Las clases deben implementar el nuevo m\u00e9todo o se lanzar\u00e1 un error. Vemos que es imposible implementar una forma que pueda dibujar un c\u00edrculo pero no un rect\u00e1ngulo o un cuadrado o un tri\u00e1ngulo. Podemos simplemente implementar los m\u00e9todos para generar un error que muestre que la operaci\u00f3n no se puede realizar. ISP frunce el ce\u00f1o contra el dise\u00f1o de esta interfaz IShape. Los clientes (aqu\u00ed Circle , Square o Rectangle ) no deber\u00edan verse obligados a depender de m\u00e9todos que no necesitan o utilizan. Adem\u00e1s, el ISP establece que las interfaces deben realizar solo un trabajo (al igual que el principio SRP), cualquier agrupaci\u00f3n adicional de comportamiento debe abstraerse a otra interfaz. La interfaz IShape realiza acciones que deber\u00edan ser manejadas de forma independiente por otras interfaces. La interfaz IShape se ajuste al principio de ISP, segregamos las acciones en diferentes interfaces. Las clases ( Circle , Square , Rectangle , etc) pueden simplemente heredar de la interfaz IShape e implementar su propio comportamiento de dibujo. class IShape : def draw ( self ): raise NotImplementedError class Circle ( IShape ): def draw ( self ): pass class Square ( IShape ): def draw ( self ): pass class Rectangle ( IShape ): def draw ( self ): pass Luego podemos usar las I-interfaces para crear formas espec\u00edficas como semic\u00edrculo, tri\u00e1ngulo en \u00e1ngulo recto, tri\u00e1ngulo equil\u00e1tero, etc.","title":"Interface Segregation Principle"},{"location":"solid/4_isp/#interface-segregation-principle","text":"Cree interfaces de grano fino que sean espec\u00edficas del cliente. Los clientes no deben verse obligados a depender de interfaces que no utilizan. Este principio se ocupa de las desventajas de implementar grandes interfaces. Veamos la siguiente interfaz de IShape : class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError Esta interfaz dibuja cuadrados, c\u00edrculos, rect\u00e1ngulos. La clase Circle , Square o Rectangle que implementa la interfaz IShape debe definir los m\u00e9todos draw_square() , draw_rectangle() , draw_circle() . class Circle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Square ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Rectangle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass La clase Rectangle implementa m\u00e9todos ( draw_circle y draw_square ) de los que no tiene uso, del mismo modo que Square implementa draw_circle , y draw_rectangle , y la clase Circle ( draw_square , draw_rectangle ). Si agregamos otro m\u00e9todo a la interfaz IShape , como draw_triangle() , class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError def draw_triangle ( self ): raise NotImplementedError Las clases deben implementar el nuevo m\u00e9todo o se lanzar\u00e1 un error. Vemos que es imposible implementar una forma que pueda dibujar un c\u00edrculo pero no un rect\u00e1ngulo o un cuadrado o un tri\u00e1ngulo. Podemos simplemente implementar los m\u00e9todos para generar un error que muestre que la operaci\u00f3n no se puede realizar. ISP frunce el ce\u00f1o contra el dise\u00f1o de esta interfaz IShape. Los clientes (aqu\u00ed Circle , Square o Rectangle ) no deber\u00edan verse obligados a depender de m\u00e9todos que no necesitan o utilizan. Adem\u00e1s, el ISP establece que las interfaces deben realizar solo un trabajo (al igual que el principio SRP), cualquier agrupaci\u00f3n adicional de comportamiento debe abstraerse a otra interfaz. La interfaz IShape realiza acciones que deber\u00edan ser manejadas de forma independiente por otras interfaces. La interfaz IShape se ajuste al principio de ISP, segregamos las acciones en diferentes interfaces. Las clases ( Circle , Square , Rectangle , etc) pueden simplemente heredar de la interfaz IShape e implementar su propio comportamiento de dibujo. class IShape : def draw ( self ): raise NotImplementedError class Circle ( IShape ): def draw ( self ): pass class Square ( IShape ): def draw ( self ): pass class Rectangle ( IShape ): def draw ( self ): pass Luego podemos usar las I-interfaces para crear formas espec\u00edficas como semic\u00edrculo, tri\u00e1ngulo en \u00e1ngulo recto, tri\u00e1ngulo equil\u00e1tero, etc.","title":"Interface Segregation Principle"},{"location":"solid/5_dip/","text":"Dependency Inversion Principle La dependencia debe estar en abstracciones, no en concreciones. Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deber\u00edan depender de abstracciones. Las abstracciones no deben depender de los detalles. Los detalles deben depender de abstracciones. Llega un punto en el desarrollo de software en el que nuestra aplicaci\u00f3n estar\u00e1 compuesta en gran parte por m\u00f3dulos. Cuando esto sucede, tenemos que aclarar las cosas usando la inyecci\u00f3n de dependencia. Componentes de alto nivel dependiendo de los componentes de bajo nivel para funcionar. class XMLHttpService (): pass class Http : def __init__ ( self , xml_http_service : XMLHttpService ): self . xml_http_service = xml_http_service def get ( self , url : str , options : dict ): self . xml_http_service . request ( url , 'GET' ) def post ( self , url , options : dict ): self . xml_http_service . request ( url , 'POST' ) Aqu\u00ed, Http es el componente de alto nivel mientras que XMLHttpService es el componente de bajo nivel. Este dise\u00f1o viola DIP : los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Deber\u00eda depender de su abstracci\u00f3n. Esta clase Http est\u00e1 obligada a depender de la clase XMLHttpService . Si tuvi\u00e9ramos que cambiar el servicio de conexi\u00f3n Http, tal vez queramos conectarnos a Internet a trav\u00e9s de cURL o incluso simular el servicio http. Tendremos que movernos minuciosamente por todas las instancias de Http para editar el c\u00f3digo y esto viola el principio OCP . La clase Http deber\u00eda preocuparse menos por el tipo de servicio Http que est\u00e1 utilizando. Hacemos una interfaz de conexi\u00f3n: class Connection : def request ( self , url : str , options : dict ): raise NotImplementedError La interfaz Connection tiene un m\u00e9todo de solicitud. Con esto, pasamos un argumento de tipo Connection a nuestra clase Http : class Http : def __init__ ( self , http_connection : Connection ): self . http_connection = http_connection def get ( self , url : str , options : dict ): self . http_connection . request ( url , 'GET' ) def post ( self , url , options : dict ): self . http_connection . request ( url , 'POST' ) As\u00ed que ahora, sin importar el tipo de servicio de conexi\u00f3n Http pasado a Http , puede conectarse f\u00e1cilmente a una red sin molestarse en saber el tipo de conexi\u00f3n de red. Ahora podemos volver a implementar nuestra clase XMLHttpService para implementar la interfaz de conexi\u00f3n: class XMLHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Podemos crear muchos tipos de conexi\u00f3n Http y pasarlos a nuestra clase Http sin ning\u00fan problema por los errores. class NodeHttpService ( Connection ): def request ( self , url : str , options : dict ): pass class MockHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Ahora, podemos ver que tanto los m\u00f3dulos de alto nivel como los de bajo nivel dependen de abstracciones. La clase Http (m\u00f3dulo de alto nivel) depende de la interfaz de Connection (abstracci\u00f3n) y los tipos de servicio Http (m\u00f3dulos de bajo nivel), a su vez, depende de la interfaz de Connection (abstracci\u00f3n). Adem\u00e1s, este DIP nos obligar\u00e1 a no violar el principio de sustituci\u00f3n de Liskov : los tipos de conexi\u00f3n Node-XML-MockHttpService son sustituibles por su tipo de conexi\u00f3n principal.","title":"Dependency Inversion Principle"},{"location":"solid/5_dip/#dependency-inversion-principle","text":"La dependencia debe estar en abstracciones, no en concreciones. Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deber\u00edan depender de abstracciones. Las abstracciones no deben depender de los detalles. Los detalles deben depender de abstracciones. Llega un punto en el desarrollo de software en el que nuestra aplicaci\u00f3n estar\u00e1 compuesta en gran parte por m\u00f3dulos. Cuando esto sucede, tenemos que aclarar las cosas usando la inyecci\u00f3n de dependencia. Componentes de alto nivel dependiendo de los componentes de bajo nivel para funcionar. class XMLHttpService (): pass class Http : def __init__ ( self , xml_http_service : XMLHttpService ): self . xml_http_service = xml_http_service def get ( self , url : str , options : dict ): self . xml_http_service . request ( url , 'GET' ) def post ( self , url , options : dict ): self . xml_http_service . request ( url , 'POST' ) Aqu\u00ed, Http es el componente de alto nivel mientras que XMLHttpService es el componente de bajo nivel. Este dise\u00f1o viola DIP : los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Deber\u00eda depender de su abstracci\u00f3n. Esta clase Http est\u00e1 obligada a depender de la clase XMLHttpService . Si tuvi\u00e9ramos que cambiar el servicio de conexi\u00f3n Http, tal vez queramos conectarnos a Internet a trav\u00e9s de cURL o incluso simular el servicio http. Tendremos que movernos minuciosamente por todas las instancias de Http para editar el c\u00f3digo y esto viola el principio OCP . La clase Http deber\u00eda preocuparse menos por el tipo de servicio Http que est\u00e1 utilizando. Hacemos una interfaz de conexi\u00f3n: class Connection : def request ( self , url : str , options : dict ): raise NotImplementedError La interfaz Connection tiene un m\u00e9todo de solicitud. Con esto, pasamos un argumento de tipo Connection a nuestra clase Http : class Http : def __init__ ( self , http_connection : Connection ): self . http_connection = http_connection def get ( self , url : str , options : dict ): self . http_connection . request ( url , 'GET' ) def post ( self , url , options : dict ): self . http_connection . request ( url , 'POST' ) As\u00ed que ahora, sin importar el tipo de servicio de conexi\u00f3n Http pasado a Http , puede conectarse f\u00e1cilmente a una red sin molestarse en saber el tipo de conexi\u00f3n de red. Ahora podemos volver a implementar nuestra clase XMLHttpService para implementar la interfaz de conexi\u00f3n: class XMLHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Podemos crear muchos tipos de conexi\u00f3n Http y pasarlos a nuestra clase Http sin ning\u00fan problema por los errores. class NodeHttpService ( Connection ): def request ( self , url : str , options : dict ): pass class MockHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Ahora, podemos ver que tanto los m\u00f3dulos de alto nivel como los de bajo nivel dependen de abstracciones. La clase Http (m\u00f3dulo de alto nivel) depende de la interfaz de Connection (abstracci\u00f3n) y los tipos de servicio Http (m\u00f3dulos de bajo nivel), a su vez, depende de la interfaz de Connection (abstracci\u00f3n). Adem\u00e1s, este DIP nos obligar\u00e1 a no violar el principio de sustituci\u00f3n de Liskov : los tipos de conexi\u00f3n Node-XML-MockHttpService son sustituibles por su tipo de conexi\u00f3n principal.","title":"Dependency Inversion Principle"},{"location":"solid/intro/","text":"Introducci\u00f3n El objetivo de este art\u00edculo es que el lector aprenda aplicar los principios SOLID con el lenguaje Python. SOLID es un acro\u0301nimo creado por Michael Feathers para los principios publicados por Robert C. Martin , en su libro Agile Software Development: Principles, Patterns, and Practices . Se trata de cinco principios de dise\u00f1o orientado a objetos que nos ayudar\u00e1n a crear mejor c\u00f3digo, m\u00e1s estructurado, con clases de responsabilidad m\u00e1s definida y m\u00e1s desacopladas entre s\u00ed: Single Responsibility : Responsabilidad u\u0301nica. Open/Closed : Abierto/Cerrado. Liskov substitution : Sustitucio\u0301n de Liskov. Interface segregation : Segregacio\u0301n de interfaz. Dependency Inversion : Inversio\u0301n de dependencia. Es importante resaltar que se trata de principios, no de reglas. Una regla es de obligatorio cumplimiento, en cambio, los principios son recomendaciones que pueden ayudar a hacer las cosas mejor. Adem\u00e1s, siempre puedes encontrar alg\u00fan contexto en el que te los puedas saltar, lo importante es hacerlo de forma consciente.","title":"Introduccion"},{"location":"solid/intro/#introduccion","text":"El objetivo de este art\u00edculo es que el lector aprenda aplicar los principios SOLID con el lenguaje Python. SOLID es un acro\u0301nimo creado por Michael Feathers para los principios publicados por Robert C. Martin , en su libro Agile Software Development: Principles, Patterns, and Practices . Se trata de cinco principios de dise\u00f1o orientado a objetos que nos ayudar\u00e1n a crear mejor c\u00f3digo, m\u00e1s estructurado, con clases de responsabilidad m\u00e1s definida y m\u00e1s desacopladas entre s\u00ed: Single Responsibility : Responsabilidad u\u0301nica. Open/Closed : Abierto/Cerrado. Liskov substitution : Sustitucio\u0301n de Liskov. Interface segregation : Segregacio\u0301n de interfaz. Dependency Inversion : Inversio\u0301n de dependencia. Es importante resaltar que se trata de principios, no de reglas. Una regla es de obligatorio cumplimiento, en cambio, los principios son recomendaciones que pueden ayudar a hacer las cosas mejor. Adem\u00e1s, siempre puedes encontrar alg\u00fan contexto en el que te los puedas saltar, lo importante es hacerlo de forma consciente.","title":"Introducci\u00f3n"}]}