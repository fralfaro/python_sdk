{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Conceptos b\u00e1sicos sobre el dise\u00f1o de software Material El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk Contenidos tem\u00e1ticos Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Home"},{"location":"#home","text":"Conceptos b\u00e1sicos sobre el dise\u00f1o de software","title":"Home"},{"location":"#material","text":"El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk","title":"Material"},{"location":"#contenidos-tematicos","text":"Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Contenidos tem\u00e1ticos"},{"location":"oop/oop/","text":"Introducci\u00f3n La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop/#introduccion","text":"La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop_abstraccion/","text":"Abstracci\u00f3n La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430> M\u00e9todos en las subclases Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come Ejercicios Ejercicio 01 Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Abstracci\u00f3n"},{"location":"oop/oop_abstraccion/#abstraccion","text":"La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430>","title":"Abstracci\u00f3n"},{"location":"oop/oop_abstraccion/#metodos-en-las-subclases","text":"Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come","title":"M\u00e9todos en las subclases"},{"location":"oop/oop_abstraccion/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_abstraccion/#ejercicio-01","text":"Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Ejercicio 01"},{"location":"oop/oop_acoplamiento/","text":"Acoplamiento en programaci\u00f3n El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte. Ejercicios Ejercicio 01 Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Acoplamiento en programaci\u00f3n"},{"location":"oop/oop_acoplamiento/#acoplamiento-en-programacion","text":"El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte.","title":"Acoplamiento en programaci\u00f3n"},{"location":"oop/oop_acoplamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_acoplamiento/#ejercicio-01","text":"Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Ejercicio 01"},{"location":"oop/oop_cohesion/","text":"Cohesi\u00f3n La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesi\u00f3n"},{"location":"oop/oop_cohesion/#cohesion","text":"La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesi\u00f3n"},{"location":"oop/oop_conceptos_basicos/","text":"Conceptos b\u00e1sicos Clases y objetos Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro). Definiendo atributos A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma. Definiendo m\u00e9todos Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments Tipos de m\u00e9todos Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" M\u00e9todos de instancia Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase M\u00e9todos de clase A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase. M\u00e9todos est\u00e1ticos Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta. Ejercicios Ejercicio 01 Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Conceptos b\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#conceptos-basicos","text":"","title":"Conceptos b\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#clases-y-objetos","text":"Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro).","title":"Clases y objetos"},{"location":"oop/oop_conceptos_basicos/#definiendo-atributos","text":"A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma.","title":"Definiendo atributos"},{"location":"oop/oop_conceptos_basicos/#definiendo-metodos","text":"Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments","title":"Definiendo m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#tipos-de-metodos","text":"Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\"","title":"Tipos de m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#metodos-de-instancia","text":"Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase","title":"M\u00e9todos de instancia"},{"location":"oop/oop_conceptos_basicos/#metodos-de-clase","text":"A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase.","title":"M\u00e9todos de clase"},{"location":"oop/oop_conceptos_basicos/#metodos-estaticos","text":"Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta.","title":"M\u00e9todos est\u00e1ticos"},{"location":"oop/oop_conceptos_basicos/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_conceptos_basicos/#ejercicio-01","text":"Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Ejercicio 01"},{"location":"oop/oop_encapsulamiento/","text":"Encapsulamiento El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo Decoradores Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d. Ejercicios Ejercicio 01 Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#encapsulamiento","text":"El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#decoradores","text":"Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d.","title":"Decoradores"},{"location":"oop/oop_encapsulamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_encapsulamiento/#ejercicio-01","text":"Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Ejercicio 01"},{"location":"oop/oop_herencia/","text":"Herencia La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n. Extendiendo y modificando m\u00e9todos Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar! Uso de super() En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis' Herencia m\u00faltiple Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>) Ejercicios Ejercicio 01 Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Herencia"},{"location":"oop/oop_herencia/#herencia","text":"La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n.","title":"Herencia"},{"location":"oop/oop_herencia/#extendiendo-y-modificando-metodos","text":"Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar!","title":"Extendiendo y modificando m\u00e9todos"},{"location":"oop/oop_herencia/#uso-de-super","text":"En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis'","title":"Uso de super()"},{"location":"oop/oop_herencia/#herencia-multiple","text":"Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>)","title":"Herencia m\u00faltiple"},{"location":"oop/oop_herencia/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_herencia/#ejercicio-01","text":"Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Ejercicio 01"},{"location":"oop/oop_polimorfismo/","text":"Polimorfismo en programaci\u00f3n El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu! Ejercicios Ejercicio 01 Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Polimorfismo en programaci\u00f3n"},{"location":"oop/oop_polimorfismo/#polimorfismo-en-programacion","text":"El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu!","title":"Polimorfismo en programaci\u00f3n"},{"location":"oop/oop_polimorfismo/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_polimorfismo/#ejercicio-01","text":"Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Ejercicio 01"},{"location":"setup/poetry/","text":"Poetry Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted. Instalaci\u00f3n Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda. osx / linux / bashonwindows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python - windows powershell (Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python - Crear un proyecto con poetry Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml . Una configuraci\u00f3n para manejar todo Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite. Poetry CLI La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml . Instalaci\u00f3n y gesti\u00f3n de dependencias poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Poetry"},{"location":"setup/poetry/#poetry","text":"Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted.","title":"Poetry"},{"location":"setup/poetry/#instalacion","text":"Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda.","title":"Instalaci\u00f3n"},{"location":"setup/poetry/#osx-linux-bashonwindows","text":"curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -","title":"osx / linux / bashonwindows"},{"location":"setup/poetry/#windows-powershell","text":"(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python -","title":"windows powershell"},{"location":"setup/poetry/#crear-un-proyecto-con-poetry","text":"Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml .","title":"Crear un proyecto con poetry"},{"location":"setup/poetry/#una-configuracion-para-manejar-todo","text":"Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite.","title":"Una configuraci\u00f3n para manejar todo"},{"location":"setup/poetry/#poetry-cli","text":"La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml .","title":"Poetry CLI"},{"location":"setup/poetry/#instalacion-y-gestion-de-dependencias","text":"poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Instalaci\u00f3n y gesti\u00f3n de dependencias"},{"location":"setup/pyenv/","text":"Pyenv Introducci\u00f3n Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables. Instalaci\u00f3n Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer Uso Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta. Recomendaciones Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Pyenv"},{"location":"setup/pyenv/#pyenv","text":"","title":"Pyenv"},{"location":"setup/pyenv/#introduccion","text":"Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables.","title":"Introducci\u00f3n"},{"location":"setup/pyenv/#instalacion","text":"Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer","title":"Instalaci\u00f3n"},{"location":"setup/pyenv/#uso","text":"Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta.","title":"Uso"},{"location":"setup/pyenv/#recomendaciones","text":"Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Recomendaciones"},{"location":"setup/virtualenv/","text":"Venv Introducci\u00f3n Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas: \u00bfPara qu\u00e9 se usan los entornos virtuales? Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios. \u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python? No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js \u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3? Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI . Creando ambientes virtuales Forma tradicional La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt Referencias venv \u2014 Creation of virtual environments","title":"Venv"},{"location":"setup/virtualenv/#venv","text":"","title":"Venv"},{"location":"setup/virtualenv/#introduccion","text":"Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas:","title":"Introducci\u00f3n"},{"location":"setup/virtualenv/#para-que-se-usan-los-entornos-virtuales","text":"Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios.","title":"\u00bfPara qu\u00e9 se usan los entornos virtuales?"},{"location":"setup/virtualenv/#los-entornos-virtuales-son-propios-solo-del-lenguaje-python","text":"No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js","title":"\u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python?"},{"location":"setup/virtualenv/#que-programa-necesito-para-crear-un-entorno-virtual-con-python-3","text":"Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI .","title":"\u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3?"},{"location":"setup/virtualenv/#creando-ambientes-virtuales","text":"","title":"Creando ambientes virtuales"},{"location":"setup/virtualenv/#forma-tradicional","text":"La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt","title":"Forma tradicional"},{"location":"setup/virtualenv/#referencias","text":"venv \u2014 Creation of virtual environments","title":"Referencias"}]}