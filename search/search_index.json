{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Conceptos b\u00e1sicos sobre el dise\u00f1o de software Material El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk Contenidos tem\u00e1ticos Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Home"},{"location":"#home","text":"Conceptos b\u00e1sicos sobre el dise\u00f1o de software","title":"Home"},{"location":"#material","text":"El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk","title":"Material"},{"location":"#contenidos-tematicos","text":"Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Contenidos tem\u00e1ticos"},{"location":"setup/poetry/","text":"Poetry Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted. Instalaci\u00f3n Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda. osx / linux / bashonwindows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python - windows powershell (Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python - Crear un proyecto con poetry Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml . Una configuraci\u00f3n para manejar todo Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite. Poetry CLI La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml . Instalaci\u00f3n y gesti\u00f3n de dependencias poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Poetry"},{"location":"setup/poetry/#poetry","text":"Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted.","title":"Poetry"},{"location":"setup/poetry/#instalacion","text":"Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda.","title":"Instalaci\u00f3n"},{"location":"setup/poetry/#osx-linux-bashonwindows","text":"curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -","title":"osx / linux / bashonwindows"},{"location":"setup/poetry/#windows-powershell","text":"(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python -","title":"windows powershell"},{"location":"setup/poetry/#crear-un-proyecto-con-poetry","text":"Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml .","title":"Crear un proyecto con poetry"},{"location":"setup/poetry/#una-configuracion-para-manejar-todo","text":"Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite.","title":"Una configuraci\u00f3n para manejar todo"},{"location":"setup/poetry/#poetry-cli","text":"La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml .","title":"Poetry CLI"},{"location":"setup/poetry/#instalacion-y-gestion-de-dependencias","text":"poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Instalaci\u00f3n y gesti\u00f3n de dependencias"},{"location":"setup/pyenv/","text":"Pyenv Introducci\u00f3n Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables. Instalaci\u00f3n Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer Uso Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta. Recomendaciones Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Pyenv"},{"location":"setup/pyenv/#pyenv","text":"","title":"Pyenv"},{"location":"setup/pyenv/#introduccion","text":"Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables.","title":"Introducci\u00f3n"},{"location":"setup/pyenv/#instalacion","text":"Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer","title":"Instalaci\u00f3n"},{"location":"setup/pyenv/#uso","text":"Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta.","title":"Uso"},{"location":"setup/pyenv/#recomendaciones","text":"Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Recomendaciones"},{"location":"setup/virtualenv/","text":"Venv Introducci\u00f3n Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas: \u00bfPara qu\u00e9 se usan los entornos virtuales? Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios. \u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python? No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js \u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3? Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI . Creando ambientes virtuales Forma tradicional La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt Referencias venv \u2014 Creation of virtual environments","title":"Venv"},{"location":"setup/virtualenv/#venv","text":"","title":"Venv"},{"location":"setup/virtualenv/#introduccion","text":"Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas:","title":"Introducci\u00f3n"},{"location":"setup/virtualenv/#para-que-se-usan-los-entornos-virtuales","text":"Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios.","title":"\u00bfPara qu\u00e9 se usan los entornos virtuales?"},{"location":"setup/virtualenv/#los-entornos-virtuales-son-propios-solo-del-lenguaje-python","text":"No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js","title":"\u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python?"},{"location":"setup/virtualenv/#que-programa-necesito-para-crear-un-entorno-virtual-con-python-3","text":"Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI .","title":"\u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3?"},{"location":"setup/virtualenv/#creando-ambientes-virtuales","text":"","title":"Creando ambientes virtuales"},{"location":"setup/virtualenv/#forma-tradicional","text":"La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt","title":"Forma tradicional"},{"location":"setup/virtualenv/#referencias","text":"venv \u2014 Creation of virtual environments","title":"Referencias"}]}