{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Conceptos b\u00e1sicos sobre el dise\u00f1o de software Material El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk Contenidos tem\u00e1ticos Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Home"},{"location":"#home","text":"Conceptos b\u00e1sicos sobre el dise\u00f1o de software","title":"Home"},{"location":"#material","text":"El material est\u00e1 disponible en el siguiente repositorio , para obtener el c\u00f3digo de fuente basta con que ejecutes el siguiente comando: https://github.com/fralfaro/python_sdk","title":"Material"},{"location":"#contenidos-tematicos","text":"Terminal Git/Github OOP Ecosistema Code Quality Testing Documentaci\u00f3n","title":"Contenidos tem\u00e1ticos"},{"location":"code_quality/black/","text":"Black El formateador de c\u00f3digo black en Python es una herramienta obstinada que formatea su c\u00f3digo de la mejor manera posible. Puede consultar sus decisiones de dise\u00f1o en el propio repositorio. Algunas decisiones de formato notables, en mi opini\u00f3n: A diferencia de PEP8 , la longitud del c\u00f3digo es de 88 caracteres, no de 79. Uso de comillas dobles que comillas simples en cadenas. Si hay muchos argumentos de funci\u00f3n, cada argumento se ajustar\u00e1 por l\u00ednea. Prefiero mantener la longitud recomendada de 79 caracteres. Menos mal, tienen la opci\u00f3n de hacerlo. Solo necesito configurar mi pyproject.toml a line-length = 79 y todo est\u00e1 listo. Aqu\u00ed un ejemplo: [tool.black] line-length = 79 include = '\\.pyi?$' exclude = ''' /( \\.git | \\.hg | \\.mypy_cache | \\.tox | \\.venv | _build | buck-out | build | dist )/ ''' Si no eres fan\u00e1tico de black , existe autopep8 , un formateador m\u00e1s fiel a PEP8 . Lo bueno es que el marco de pre-commit ya tiene un hook en esta herramienta, por lo que no es necesario buscarlo en otro repositorio. Instalaci\u00f3n Requiere Python 3.6.0+ para ejecutarse, pero tambi\u00e9n puede reformatear el c\u00f3digo Python 2 con \u00e9l. # using pip (pip3) $ pip install black # using pipenv $ pipenv install black # using poetry $ poetry add black Uso Veamos un ejemplo sencillo: %% writefile example_01 . py def is_unique ( s ): s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ()) ) Overwriting example_01.py Ocupemos black para formatear nuestro c\u00f3digo: ! python - m black example_01 . py \u001b[1mreformatted example_01.py\u001b[0m \u001b[1mAll done! \u2728 \ud83c\udf70 \u2728\u001b[0m \u001b[1m1 file reformatted\u001b[0m.\u001b[0m Veamos los resultados del c\u00f3digo formateado: ! cat example_01 . py def is_unique(s): s = list(s) s.sort() for i in range(len(s) - 1): if s[i] == s[i + 1]: return 0 else: return 1 if __name__ == \"__main__\": print(is_unique(input())) Si usted quiere ver m\u00e1s opciones de black (mediante l\u00ednea de comando), ejecute: ! python - m black -- help Usage: __main__.py [OPTIONS] [SRC]... The uncompromising code formatter. Options: -c, --code TEXT Format the code passed in as a string. -l, --line-length INTEGER How many characters per line to allow. [default: 88] -t, --target-version [py27|py33|py34|py35|py36|py37|py38] Python versions that should be supported by Black's output. [default: per-file auto- detection] --pyi Format all input files like typing stubs regardless of file extension (useful when piping source on standard input). -S, --skip-string-normalization Don't normalize string quotes or prefixes. --check Don't write the files back, just return the status. Return code 0 means nothing would change. Return code 1 means some files would be reformatted. Return code 123 means there was an internal error. --diff Don't write the files back, just output a diff for each file on stdout. --color / --no-color Show colored diff. Only applies when `--diff` is given. --fast / --safe If --fast given, skip temporary sanity checks. [default: --safe] --include TEXT A regular expression that matches files and directories that should be included on recursive searches. An empty value means all files are included regardless of the name. Use forward slashes for directories on all platforms (Windows, too). Exclusions are calculated first, inclusions later. [default: \\.pyi?$] --exclude TEXT A regular expression that matches files and directories that should be excluded on recursive searches. An empty value means no paths are excluded. Use forward slashes for directories on all platforms (Windows, too). Exclusions are calculated first, inclusions later. [default: /(\\.direnv|\\.eggs|\\.git|\\. hg|\\.mypy_cache|\\.nox|\\.tox|\\.venv|\\.svn|_bu ild|buck-out|build|dist)/] --force-exclude TEXT Like --exclude, but files and directories matching this regex will be excluded even when they are passed explicitly as arguments -q, --quiet Don't emit non-error messages to stderr. Errors are still emitted; silence those with 2>/dev/null. -v, --verbose Also emit messages to stderr about files that were not changed or were ignored due to --exclude=. --version Show the version and exit. --config FILE Read configuration from FILE path. -h, --help Show this message and exit. Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Black"},{"location":"code_quality/black/#black","text":"El formateador de c\u00f3digo black en Python es una herramienta obstinada que formatea su c\u00f3digo de la mejor manera posible. Puede consultar sus decisiones de dise\u00f1o en el propio repositorio. Algunas decisiones de formato notables, en mi opini\u00f3n: A diferencia de PEP8 , la longitud del c\u00f3digo es de 88 caracteres, no de 79. Uso de comillas dobles que comillas simples en cadenas. Si hay muchos argumentos de funci\u00f3n, cada argumento se ajustar\u00e1 por l\u00ednea. Prefiero mantener la longitud recomendada de 79 caracteres. Menos mal, tienen la opci\u00f3n de hacerlo. Solo necesito configurar mi pyproject.toml a line-length = 79 y todo est\u00e1 listo. Aqu\u00ed un ejemplo: [tool.black] line-length = 79 include = '\\.pyi?$' exclude = ''' /( \\.git | \\.hg | \\.mypy_cache | \\.tox | \\.venv | _build | buck-out | build | dist )/ ''' Si no eres fan\u00e1tico de black , existe autopep8 , un formateador m\u00e1s fiel a PEP8 . Lo bueno es que el marco de pre-commit ya tiene un hook en esta herramienta, por lo que no es necesario buscarlo en otro repositorio.","title":"Black"},{"location":"code_quality/black/#instalacion","text":"Requiere Python 3.6.0+ para ejecutarse, pero tambi\u00e9n puede reformatear el c\u00f3digo Python 2 con \u00e9l. # using pip (pip3) $ pip install black # using pipenv $ pipenv install black # using poetry $ poetry add black","title":"Instalaci\u00f3n"},{"location":"code_quality/black/#uso","text":"Veamos un ejemplo sencillo: %% writefile example_01 . py def is_unique ( s ): s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ()) ) Overwriting example_01.py Ocupemos black para formatear nuestro c\u00f3digo: ! python - m black example_01 . py \u001b[1mreformatted example_01.py\u001b[0m \u001b[1mAll done! \u2728 \ud83c\udf70 \u2728\u001b[0m \u001b[1m1 file reformatted\u001b[0m.\u001b[0m Veamos los resultados del c\u00f3digo formateado: ! cat example_01 . py def is_unique(s): s = list(s) s.sort() for i in range(len(s) - 1): if s[i] == s[i + 1]: return 0 else: return 1 if __name__ == \"__main__\": print(is_unique(input())) Si usted quiere ver m\u00e1s opciones de black (mediante l\u00ednea de comando), ejecute: ! python - m black -- help Usage: __main__.py [OPTIONS] [SRC]... The uncompromising code formatter. Options: -c, --code TEXT Format the code passed in as a string. -l, --line-length INTEGER How many characters per line to allow. [default: 88] -t, --target-version [py27|py33|py34|py35|py36|py37|py38] Python versions that should be supported by Black's output. [default: per-file auto- detection] --pyi Format all input files like typing stubs regardless of file extension (useful when piping source on standard input). -S, --skip-string-normalization Don't normalize string quotes or prefixes. --check Don't write the files back, just return the status. Return code 0 means nothing would change. Return code 1 means some files would be reformatted. Return code 123 means there was an internal error. --diff Don't write the files back, just output a diff for each file on stdout. --color / --no-color Show colored diff. Only applies when `--diff` is given. --fast / --safe If --fast given, skip temporary sanity checks. [default: --safe] --include TEXT A regular expression that matches files and directories that should be included on recursive searches. An empty value means all files are included regardless of the name. Use forward slashes for directories on all platforms (Windows, too). Exclusions are calculated first, inclusions later. [default: \\.pyi?$] --exclude TEXT A regular expression that matches files and directories that should be excluded on recursive searches. An empty value means no paths are excluded. Use forward slashes for directories on all platforms (Windows, too). Exclusions are calculated first, inclusions later. [default: /(\\.direnv|\\.eggs|\\.git|\\. hg|\\.mypy_cache|\\.nox|\\.tox|\\.venv|\\.svn|_bu ild|buck-out|build|dist)/] --force-exclude TEXT Like --exclude, but files and directories matching this regex will be excluded even when they are passed explicitly as arguments -q, --quiet Don't emit non-error messages to stderr. Errors are still emitted; silence those with 2>/dev/null. -v, --verbose Also emit messages to stderr about files that were not changed or were ignored due to --exclude=. --version Show the version and exit. --config FILE Read configuration from FILE path. -h, --help Show this message and exit. Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Uso"},{"location":"code_quality/code_quality/","text":"Introducci\u00f3n Por supuesto que desea un c\u00f3digo de calidad, \u00bfqui\u00e9n no?, pero para mejorar la calidad del c\u00f3digo, tenemos que definir qu\u00e9 es. Una b\u00fasqueda r\u00e1pida en Google produce muchos resultados que definen la calidad del c\u00f3digo. Resulta que el t\u00e9rmino puede significar muchas cosas diferentes para las personas. Una forma de intentar definir la calidad del c\u00f3digo es observar un extremo del espectro: el c\u00f3digo de alta calidad. Con suerte, puede aceptar los siguientes identificadores de c\u00f3digo de alta calidad: Hace lo que se supone que debe hacer. No contiene defectos ni problemas. Es f\u00e1cil de leer, mantener y ampliar. Estos tres identificadores, aunque simplistas, parecen estar de acuerdo en general. En un esfuerzo por expandir estas ideas a\u00fan m\u00e1s, profundicemos en por qu\u00e9 cada una es importante en el \u00e1mbito del software. \u00bfPor qu\u00e9 importa la calidad del c\u00f3digo? No hace lo que se supone que debe hacer El cumplimiento de los requisitos es la base de cualquier producto, software o de otro tipo. Creamos software para hacer algo. Si al final, no funciona ... bueno, definitivamente no es de alta calidad. Si no cumple con los requisitos b\u00e1sicos, es dif\u00edcil incluso llamarlo de baja calidad. Contiene defectos y problemas. Si algo que est\u00e1 usando tiene problemas o le causa problemas, probablemente no lo llamar\u00eda de alta calidad. De hecho, si es lo suficientemente malo, puede dejar de usarlo por completo. Por el bien de no usar software como ejemplo, digamos que su aspiradora funciona muy bien en una alfombra normal. Limpia todo el polvo y el pelo de gato. Una noche fat\u00eddica, el gato derriba una planta y derrama tierra por todas partes. Cuando intentas usar la aspiradora para limpiar la pila de suciedad, se rompe y arroja suciedad por todas partes. Si bien la aspiradora funcion\u00f3 en algunas circunstancias, no manej\u00f3 de manera eficiente la carga adicional ocasional. Por lo tanto, no lo llamar\u00eda una aspiradora de alta calidad. Ese es un problema que queremos evitar en nuestro c\u00f3digo. Si las cosas se rompen en los casos extremos y los defectos causan un comportamiento no deseado, no tenemos un producto de alta calidad. Es dif\u00edcil de leer, mantener o ampliar Imag\u00ednese esto: un cliente solicita una nueva funci\u00f3n. La persona que escribi\u00f3 el c\u00f3digo original ya no est\u00e1. La persona que los ha reemplazado ahora tiene que entender el c\u00f3digo que ya est\u00e1 all\u00ed. Esa persona eres t\u00fa. Si el c\u00f3digo es f\u00e1cil de comprender, podr\u00e1 analizar el problema y encontrar una soluci\u00f3n mucho m\u00e1s r\u00e1pido. Si el c\u00f3digo es complejo y enrevesado, probablemente tardar\u00e1 m\u00e1s y posiblemente haga algunas suposiciones incorrectas. Tambi\u00e9n es bueno si es f\u00e1cil agregar la nueva funci\u00f3n sin interrumpir las funciones anteriores. Si el c\u00f3digo no es f\u00e1cil de extender, su nueva caracter\u00edstica podr\u00eda romper otras cosas. Nadie quiere estar en la posici\u00f3n de tener que leer, mantener o ampliar c\u00f3digo de baja calidad. Significa m\u00e1s dolores de cabeza y m\u00e1s trabajo para todos. Ya es bastante malo que tengas que lidiar con c\u00f3digo de baja calidad, pero no pongas a otra persona en la misma situaci\u00f3n. Puede mejorar la calidad del c\u00f3digo que escribe. Si trabaja con un equipo de desarrolladores, puede comenzar a implementar m\u00e9todos para garantizar una mejor calidad general del c\u00f3digo. Suponiendo que cuente con su apoyo, por supuesto. Puede que tengas que convencer a algunas personas (no dudes en enviarles este art\u00edculo \ud83d\ude03). C\u00f3mo mejorar la calidad del c\u00f3digo Python Hay algunas cosas a considerar en nuestro viaje hacia un c\u00f3digo de alta calidad. Primero, este viaje no es de pura objetividad. Hay algunas sensaciones fuertes sobre el aspecto del c\u00f3digo de alta calidad. Si bien es de esperar que todos puedan estar de acuerdo con los identificadores mencionados anteriormente, la forma en que se logran es un camino subjetivo. Los temas m\u00e1s obstinados suelen surgir cuando se habla de lograr legibilidad, mantenimiento y extensibilidad. As\u00ed que tenga en cuenta que, si bien este art\u00edculo intentar\u00e1 ser objetivo en todo momento, hay un mundo muy obstinado cuando se trata de c\u00f3digo. Entonces, comencemos con el tema m\u00e1s obstinado: el estilo del c\u00f3digo. Gu\u00edas de estilo (Style Guides) La vieja pregunta: \u00bfespacios o tabulaciones?. Independientemente de su opini\u00f3n personal sobre c\u00f3mo representar los espacios en blanco, es seguro asumir que al menos desea coherencia en el c\u00f3digo. Una gu\u00eda de estilo sirve para definir una forma coherente de escribir su c\u00f3digo. Por lo general, todo esto es cosm\u00e9tico, lo que significa que no cambia el resultado l\u00f3gico del c\u00f3digo. Aunque, algunas elecciones estil\u00edsticas evitan errores l\u00f3gicos comunes. Las gu\u00edas de estilo sirven para ayudar a facilitar el objetivo de hacer que el c\u00f3digo sea f\u00e1cil de leer, mantener y ampliar. En lo que respecta a Python, existe un est\u00e1ndar bien aceptado. Fue escrito, en parte, por el autor del propio lenguaje de programaci\u00f3n Python. PEP 8 proporciona convenciones de codificaci\u00f3n para el c\u00f3digo Python. Es bastante com\u00fan que el c\u00f3digo Python siga esta gu\u00eda de estilo. Es un gran lugar para comenzar, ya que est\u00e1 bien definido. Una propuesta hermana de Python Enhancement, PEP 257 describe las convenciones para las cadenas de documentos de Python, que son cadenas destinadas a documentar m\u00f3dulos, clases, funciones y m\u00e9todos. Como beneficio adicional, si las cadenas de documentos son consistentes, existen herramientas capaces de generar documentaci\u00f3n directamente desde el c\u00f3digo. Todo lo que hacen estas gu\u00edas es definir una forma de dise\u00f1ar el c\u00f3digo. Pero, \u00bfc\u00f3mo lo haces cumplir? \u00bfY qu\u00e9 pasa con los defectos y problemas en el c\u00f3digo, c\u00f3mo se pueden detectar? Ah\u00ed es donde entran en juego los linters. Linters Primero, hablemos de Linter. Esos peque\u00f1os y molestos defectos que de alguna manera manchan tu ropa. La ropa se ve y se siente mucho mejor sin toda esas pelusa. Tu c\u00f3digo no es diferente. Peque\u00f1os errores, inconsistencias estil\u00edsticas y l\u00f3gica peligrosa no hacen que su c\u00f3digo se sienta bien. Pero todos cometemos errores. No puede esperar que los atrape siempre a tiempo. Nombres de variables mal escritos, olvidar un corchete de cierre, tabulaci\u00f3n incorrecta en Python, llamar a una funci\u00f3n con el n\u00famero incorrecto de argumentos, la lista sigue y sigue. Linters ayudan a identificar esas \u00e1reas problem\u00e1ticas. Adem\u00e1s, la mayor\u00eda de los editores e IDE tienen la capacidad de ejecutar linters en segundo plano mientras escribe. Esto da como resultado un entorno capaz de resaltar, subrayar o identificar \u00e1reas problem\u00e1ticas en el c\u00f3digo antes de ejecutarlo. Es como un corrector ortogr\u00e1fico avanzado para el c\u00f3digo. Subraya los problemas con l\u00edneas rojas onduladas, como lo hace su procesador de texto favorito. Linters analiza el c\u00f3digo para detectar varias categor\u00edas de linters. Esas categor\u00edas pueden definirse ampliamente como las siguientes: Logical Lint Errores de c\u00f3digo C\u00f3digo con resultados potencialmente no deseados Patrones de c\u00f3digo peligrosos Stylistic Lint C\u00f3digo que no se ajusta a las convenciones definidas Tambi\u00e9n hay herramientas de an\u00e1lisis de c\u00f3digo que brindan otros conocimientos sobre su c\u00f3digo. Aunque tal vez no sean linters por definici\u00f3n, estas herramientas generalmente se usan junto con linters. Ellos tambi\u00e9n esperan mejorar la calidad del c\u00f3digo. Finalmente, existen herramientas que formatean autom\u00e1ticamente el c\u00f3digo seg\u00fan alguna especificaci\u00f3n. Estas herramientas automatizadas garantizan que nuestras mentes humanas inferiores no estropeen las convenciones Linters para Python Antes de profundizar en sus opciones, es importante reconocer que algunos \"linters\" son solo varios linters empaquetados muy bien juntos. Algunos ejemplos populares de esos combo-linters son los siguientes: Flake8 : Capaz de detectar pelusa tanto l\u00f3gica como estil\u00edstica. Agrega las comprobaciones de estilo y complejidad de pycodestyle a la detecci\u00f3n l\u00f3gica de pelusa de PyFlakes. Combina los siguientes linters: PyFlakes pycodestyle (anteriormente pep8) Mccabe Pylama : una herramienta de auditor\u00eda de c\u00f3digo compuesta por una gran cantidad de linters y otras herramientas para analizar c\u00f3digo. Combina lo siguiente: pycodestyle (anteriormente pep8) pydocstyle (anteriormente pep257) PyFlakes Mccabe Pylint Rad\u00f3n gjslint Aqu\u00ed hay algunos linters independientes categorizados con breves descripciones: Linter Category Description Pylint Logical & Stylistic Checks for errors, tries to enforce a coding standard, looks for code smells PyFlakes Logical Analyzes programs and detects various errors pycodestyle Stylistic Checks against some of the style conventions in PEP 8 pydocstyle Stylistic Checks compliance with Python docstring conventions Bandit Logical Analyzes code to find common security issues MyPy Logical Checks for optionally-enforced static types Y aqu\u00ed hay algunas herramientas de formato y an\u00e1lisis de c\u00f3digo: Tool Category Description Mccabe Analytical Checks McCabe complexity Radon Analytical Analyzes code for various metrics (lines of code, complexity, and so on) Black Formatter Formats Python code without compromise Isort Formatter Formats imports by sorting alphabetically and separating into sections","title":"Introducci\u00f3n"},{"location":"code_quality/code_quality/#introduccion","text":"Por supuesto que desea un c\u00f3digo de calidad, \u00bfqui\u00e9n no?, pero para mejorar la calidad del c\u00f3digo, tenemos que definir qu\u00e9 es. Una b\u00fasqueda r\u00e1pida en Google produce muchos resultados que definen la calidad del c\u00f3digo. Resulta que el t\u00e9rmino puede significar muchas cosas diferentes para las personas. Una forma de intentar definir la calidad del c\u00f3digo es observar un extremo del espectro: el c\u00f3digo de alta calidad. Con suerte, puede aceptar los siguientes identificadores de c\u00f3digo de alta calidad: Hace lo que se supone que debe hacer. No contiene defectos ni problemas. Es f\u00e1cil de leer, mantener y ampliar. Estos tres identificadores, aunque simplistas, parecen estar de acuerdo en general. En un esfuerzo por expandir estas ideas a\u00fan m\u00e1s, profundicemos en por qu\u00e9 cada una es importante en el \u00e1mbito del software.","title":"Introducci\u00f3n"},{"location":"code_quality/code_quality/#por-que-importa-la-calidad-del-codigo","text":"","title":"\u00bfPor qu\u00e9 importa la calidad del c\u00f3digo?"},{"location":"code_quality/code_quality/#no-hace-lo-que-se-supone-que-debe-hacer","text":"El cumplimiento de los requisitos es la base de cualquier producto, software o de otro tipo. Creamos software para hacer algo. Si al final, no funciona ... bueno, definitivamente no es de alta calidad. Si no cumple con los requisitos b\u00e1sicos, es dif\u00edcil incluso llamarlo de baja calidad.","title":"No hace lo que se supone que debe hacer"},{"location":"code_quality/code_quality/#contiene-defectos-y-problemas","text":"Si algo que est\u00e1 usando tiene problemas o le causa problemas, probablemente no lo llamar\u00eda de alta calidad. De hecho, si es lo suficientemente malo, puede dejar de usarlo por completo. Por el bien de no usar software como ejemplo, digamos que su aspiradora funciona muy bien en una alfombra normal. Limpia todo el polvo y el pelo de gato. Una noche fat\u00eddica, el gato derriba una planta y derrama tierra por todas partes. Cuando intentas usar la aspiradora para limpiar la pila de suciedad, se rompe y arroja suciedad por todas partes. Si bien la aspiradora funcion\u00f3 en algunas circunstancias, no manej\u00f3 de manera eficiente la carga adicional ocasional. Por lo tanto, no lo llamar\u00eda una aspiradora de alta calidad. Ese es un problema que queremos evitar en nuestro c\u00f3digo. Si las cosas se rompen en los casos extremos y los defectos causan un comportamiento no deseado, no tenemos un producto de alta calidad.","title":"Contiene defectos y problemas."},{"location":"code_quality/code_quality/#es-dificil-de-leer-mantener-o-ampliar","text":"Imag\u00ednese esto: un cliente solicita una nueva funci\u00f3n. La persona que escribi\u00f3 el c\u00f3digo original ya no est\u00e1. La persona que los ha reemplazado ahora tiene que entender el c\u00f3digo que ya est\u00e1 all\u00ed. Esa persona eres t\u00fa. Si el c\u00f3digo es f\u00e1cil de comprender, podr\u00e1 analizar el problema y encontrar una soluci\u00f3n mucho m\u00e1s r\u00e1pido. Si el c\u00f3digo es complejo y enrevesado, probablemente tardar\u00e1 m\u00e1s y posiblemente haga algunas suposiciones incorrectas. Tambi\u00e9n es bueno si es f\u00e1cil agregar la nueva funci\u00f3n sin interrumpir las funciones anteriores. Si el c\u00f3digo no es f\u00e1cil de extender, su nueva caracter\u00edstica podr\u00eda romper otras cosas. Nadie quiere estar en la posici\u00f3n de tener que leer, mantener o ampliar c\u00f3digo de baja calidad. Significa m\u00e1s dolores de cabeza y m\u00e1s trabajo para todos. Ya es bastante malo que tengas que lidiar con c\u00f3digo de baja calidad, pero no pongas a otra persona en la misma situaci\u00f3n. Puede mejorar la calidad del c\u00f3digo que escribe. Si trabaja con un equipo de desarrolladores, puede comenzar a implementar m\u00e9todos para garantizar una mejor calidad general del c\u00f3digo. Suponiendo que cuente con su apoyo, por supuesto. Puede que tengas que convencer a algunas personas (no dudes en enviarles este art\u00edculo \ud83d\ude03).","title":"Es dif\u00edcil de leer, mantener o ampliar"},{"location":"code_quality/code_quality/#como-mejorar-la-calidad-del-codigo-python","text":"Hay algunas cosas a considerar en nuestro viaje hacia un c\u00f3digo de alta calidad. Primero, este viaje no es de pura objetividad. Hay algunas sensaciones fuertes sobre el aspecto del c\u00f3digo de alta calidad. Si bien es de esperar que todos puedan estar de acuerdo con los identificadores mencionados anteriormente, la forma en que se logran es un camino subjetivo. Los temas m\u00e1s obstinados suelen surgir cuando se habla de lograr legibilidad, mantenimiento y extensibilidad. As\u00ed que tenga en cuenta que, si bien este art\u00edculo intentar\u00e1 ser objetivo en todo momento, hay un mundo muy obstinado cuando se trata de c\u00f3digo. Entonces, comencemos con el tema m\u00e1s obstinado: el estilo del c\u00f3digo.","title":"C\u00f3mo mejorar la calidad del c\u00f3digo Python"},{"location":"code_quality/code_quality/#guias-de-estilo-style-guides","text":"La vieja pregunta: \u00bfespacios o tabulaciones?. Independientemente de su opini\u00f3n personal sobre c\u00f3mo representar los espacios en blanco, es seguro asumir que al menos desea coherencia en el c\u00f3digo. Una gu\u00eda de estilo sirve para definir una forma coherente de escribir su c\u00f3digo. Por lo general, todo esto es cosm\u00e9tico, lo que significa que no cambia el resultado l\u00f3gico del c\u00f3digo. Aunque, algunas elecciones estil\u00edsticas evitan errores l\u00f3gicos comunes. Las gu\u00edas de estilo sirven para ayudar a facilitar el objetivo de hacer que el c\u00f3digo sea f\u00e1cil de leer, mantener y ampliar. En lo que respecta a Python, existe un est\u00e1ndar bien aceptado. Fue escrito, en parte, por el autor del propio lenguaje de programaci\u00f3n Python. PEP 8 proporciona convenciones de codificaci\u00f3n para el c\u00f3digo Python. Es bastante com\u00fan que el c\u00f3digo Python siga esta gu\u00eda de estilo. Es un gran lugar para comenzar, ya que est\u00e1 bien definido. Una propuesta hermana de Python Enhancement, PEP 257 describe las convenciones para las cadenas de documentos de Python, que son cadenas destinadas a documentar m\u00f3dulos, clases, funciones y m\u00e9todos. Como beneficio adicional, si las cadenas de documentos son consistentes, existen herramientas capaces de generar documentaci\u00f3n directamente desde el c\u00f3digo. Todo lo que hacen estas gu\u00edas es definir una forma de dise\u00f1ar el c\u00f3digo. Pero, \u00bfc\u00f3mo lo haces cumplir? \u00bfY qu\u00e9 pasa con los defectos y problemas en el c\u00f3digo, c\u00f3mo se pueden detectar? Ah\u00ed es donde entran en juego los linters.","title":"Gu\u00edas de estilo (Style Guides)"},{"location":"code_quality/code_quality/#linters","text":"Primero, hablemos de Linter. Esos peque\u00f1os y molestos defectos que de alguna manera manchan tu ropa. La ropa se ve y se siente mucho mejor sin toda esas pelusa. Tu c\u00f3digo no es diferente. Peque\u00f1os errores, inconsistencias estil\u00edsticas y l\u00f3gica peligrosa no hacen que su c\u00f3digo se sienta bien. Pero todos cometemos errores. No puede esperar que los atrape siempre a tiempo. Nombres de variables mal escritos, olvidar un corchete de cierre, tabulaci\u00f3n incorrecta en Python, llamar a una funci\u00f3n con el n\u00famero incorrecto de argumentos, la lista sigue y sigue. Linters ayudan a identificar esas \u00e1reas problem\u00e1ticas. Adem\u00e1s, la mayor\u00eda de los editores e IDE tienen la capacidad de ejecutar linters en segundo plano mientras escribe. Esto da como resultado un entorno capaz de resaltar, subrayar o identificar \u00e1reas problem\u00e1ticas en el c\u00f3digo antes de ejecutarlo. Es como un corrector ortogr\u00e1fico avanzado para el c\u00f3digo. Subraya los problemas con l\u00edneas rojas onduladas, como lo hace su procesador de texto favorito. Linters analiza el c\u00f3digo para detectar varias categor\u00edas de linters. Esas categor\u00edas pueden definirse ampliamente como las siguientes: Logical Lint Errores de c\u00f3digo C\u00f3digo con resultados potencialmente no deseados Patrones de c\u00f3digo peligrosos Stylistic Lint C\u00f3digo que no se ajusta a las convenciones definidas Tambi\u00e9n hay herramientas de an\u00e1lisis de c\u00f3digo que brindan otros conocimientos sobre su c\u00f3digo. Aunque tal vez no sean linters por definici\u00f3n, estas herramientas generalmente se usan junto con linters. Ellos tambi\u00e9n esperan mejorar la calidad del c\u00f3digo. Finalmente, existen herramientas que formatean autom\u00e1ticamente el c\u00f3digo seg\u00fan alguna especificaci\u00f3n. Estas herramientas automatizadas garantizan que nuestras mentes humanas inferiores no estropeen las convenciones","title":"Linters"},{"location":"code_quality/code_quality/#linters-para-python","text":"Antes de profundizar en sus opciones, es importante reconocer que algunos \"linters\" son solo varios linters empaquetados muy bien juntos. Algunos ejemplos populares de esos combo-linters son los siguientes: Flake8 : Capaz de detectar pelusa tanto l\u00f3gica como estil\u00edstica. Agrega las comprobaciones de estilo y complejidad de pycodestyle a la detecci\u00f3n l\u00f3gica de pelusa de PyFlakes. Combina los siguientes linters: PyFlakes pycodestyle (anteriormente pep8) Mccabe Pylama : una herramienta de auditor\u00eda de c\u00f3digo compuesta por una gran cantidad de linters y otras herramientas para analizar c\u00f3digo. Combina lo siguiente: pycodestyle (anteriormente pep8) pydocstyle (anteriormente pep257) PyFlakes Mccabe Pylint Rad\u00f3n gjslint Aqu\u00ed hay algunos linters independientes categorizados con breves descripciones: Linter Category Description Pylint Logical & Stylistic Checks for errors, tries to enforce a coding standard, looks for code smells PyFlakes Logical Analyzes programs and detects various errors pycodestyle Stylistic Checks against some of the style conventions in PEP 8 pydocstyle Stylistic Checks compliance with Python docstring conventions Bandit Logical Analyzes code to find common security issues MyPy Logical Checks for optionally-enforced static types Y aqu\u00ed hay algunas herramientas de formato y an\u00e1lisis de c\u00f3digo: Tool Category Description Mccabe Analytical Checks McCabe complexity Radon Analytical Analyzes code for various metrics (lines of code, complexity, and so on) Black Formatter Formats Python code without compromise Isort Formatter Formats imports by sorting alphabetically and separating into sections","title":"Linters para Python"},{"location":"code_quality/flake8/","text":"Flake8 Flake8 es una herramienta poderosa que verifica el cumplimiento de nuestro c\u00f3digo con PEP8 . Flake8 es un wrapper de estas herramientas: PyFlakes pycodestyle El gui\u00f3n de McCabe de Ned Batchelder Flake8 ejecuta todas las herramientas ejecutando el \u00fanico comando flake8. Muestra las advertencias en una salida combinada por archivo. Instalaci\u00f3n Si desea que Flake8 se instale para su instalaci\u00f3n predeterminada de Python, puede usar: # using pip (pip3) $ pip install flake8 # using pipenv $ pipenv install flake8 # using poetry $ poetry add flake8 Uso Veamos un ejemplo sencillo: %% writefile example_01 . py def is_unique ( s ): \"\"\" Black is the uncompromising Python code formatter. By using it, you agree to cede control over minutiae of hand-formatting. \"\"\" s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ()) ) Overwriting example_01.py Ocupemos flake8 para analizar nuestro c\u00f3digo: ! python - m flake8 example_01 . py example_01.py:1:15: W291 trailing whitespace example_01.py:2:17: W291 trailing whitespace example_01.py:3:18: W291 trailing whitespace example_01.py:5:80: E501 line too long (127 > 79 characters) example_01.py:5:128: W291 trailing whitespace example_01.py:7:15: W291 trailing whitespace example_01.py:8:17: E124 closing bracket does not match visual indentation example_01.py:8:18: W291 trailing whitespace example_01.py:9:13: W291 trailing whitespace example_01.py:10:1: W293 blank line contains whitespace example_01.py:11:1: W293 blank line contains whitespace example_01.py:12:5: E303 too many blank lines (2) example_01.py:12:32: W291 trailing whitespace example_01.py:13:29: W291 trailing whitespace example_01.py:15:10: W291 trailing whitespace example_01.py:17:1: W293 blank line contains whitespace example_01.py:18:1: W293 blank line contains whitespace example_01.py:19:27: W291 trailing whitespace example_01.py:20:11: W291 trailing whitespace example_01.py:21:29: W291 trailing whitespace example_01.py:22:11: W291 trailing whitespace flake8 nos muestra una lista detallada de: nombre del c\u00f3digo que no esta cumpliendo alguna pol\u00edtica de flake8 l\u00ednea que no esta cumpliendo alguna de las pol\u00edticas de flake8 regla o pol\u00edtica de flake8 que se esta rompiendo ( Para ver algunas de las reglas de flake8 conculte el siguiente link ) Veamos qu\u00e9 sucede si el c\u00f3digo est\u00e1 escrito correctamente: %% writefile example_01 . py def is_unique ( s ): \"\"\" Black is the uncompromising Python code formatter. By using it, you agree to cede control over minutiae of hand-formatting. \"\"\" s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ())) Overwriting example_01.py ! python - m flake8 example_01 . py Cuando el c\u00f3digo est\u00e1 escrito correctamente, flake8 no arroja ning\u00fan mensaje, dondo a entender al usuario que su c\u00f3digo cumple con todas las pol\u00edticas del PEP8. Si usted quiere ver m\u00e1s opciones de flake8 (mediante l\u00ednea de comando), ejecute: ! python - m flake8 -- help usage: flake8 [options] file file ... positional arguments: filename optional arguments: -h, --help show this help message and exit -v, --verbose Print more information about what is happening in flake8. This option is repeatable and will increase verbosity each time it is repeated. --output-file OUTPUT_FILE Redirect report to a file. --append-config APPEND_CONFIG Provide extra config files to parse in addition to the files found by Flake8 by default. These files are the last ones read and so they take the highest precedence when multiple files provide the same option. --config CONFIG Path to the config file that will be the authoritative config source. This will cause Flake8 to ignore all other configuration files. --isolated Ignore all configuration files. --version show program's version number and exit -q, --quiet Report only file names, or nothing. This option is repeatable. --count Print total number of errors and warnings to standard error and set the exit code to 1 if total is not empty. --diff Report changes only within line number ranges in the unified diff provided on standard in by the user. --exclude patterns Comma-separated list of files or directories to exclude. (Default: ['.svn', 'CVS', '.bzr', '.hg', '.git', '__pycache__', '.tox', '.eggs', '*.egg']) --extend-exclude patterns Comma-separated list of files or directories to add to the list of excluded ones. --filename patterns Only check for filenames matching the patterns in this comma-separated list. (Default: ['*.py']) --stdin-display-name STDIN_DISPLAY_NAME The name used when reporting errors from code passed via stdin. This is useful for editors piping the file contents to flake8. (Default: stdin) --format format Format errors according to the chosen formatter. --hang-closing Hang closing bracket instead of matching indentation of opening bracket's line. --ignore errors Comma-separated list of errors and warnings to ignore (or skip). For example, ``--ignore=E4,E51,W234``. (Default: ['E704', 'E123', 'W503', 'E126', 'E24', 'W504', 'E226', 'E121']) --extend-ignore errors Comma-separated list of errors and warnings to add to the list of ignored ones. For example, ``--extend- ignore=E4,E51,W234``. --per-file-ignores PER_FILE_IGNORES A pairing of filenames and violation codes that defines which violations to ignore in a particular file. The filenames can be specified in a manner similar to the ``--exclude`` option and the violations work similarly to the ``--ignore`` and ``--select`` options. --max-line-length n Maximum allowed line length for the entirety of this run. (Default: 79) --max-doc-length n Maximum allowed doc line length for the entirety of this run. (Default: None) --select errors Comma-separated list of errors and warnings to enable. For example, ``--select=E4,E51,W234``. (Default: ['E', 'F', 'W', 'C90']) --disable-noqa Disable the effect of \"# noqa\". This will report errors on lines with \"# noqa\" at the end. --show-source Show the source generate each error or warning. --statistics Count errors and warnings. --enable-extensions ENABLE_EXTENSIONS Enable plugins and extensions that are otherwise disabled by default --exit-zero Exit with status code \"0\" even if there are errors. --install-hook {git,mercurial} Install a hook that is run prior to a commit for the supported version control system. -j JOBS, --jobs JOBS Number of subprocesses to use to run checks in parallel. This is ignored on Windows. The default, \"auto\", will auto-detect the number of processors available to use. (Default: auto) --tee Write to stdout and output-file. --benchmark Print benchmark information about this run of Flake8 --bug-report Print information necessary when preparing a bug report mccabe: --max-complexity MAX_COMPLEXITY McCabe complexity threshold pyflakes: --builtins BUILTINS define more built-ins, comma separated --doctests also check syntax of the doctests --include-in-doctest INCLUDE_IN_DOCTEST Run doctests only on these files --exclude-from-doctest EXCLUDE_FROM_DOCTEST Skip these files when running doctests Installed plugins: mccabe: 0.6.1, pycodestyle: 2.6.0, pyflakes: 2.2.0 Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Flake8"},{"location":"code_quality/flake8/#flake8","text":"Flake8 es una herramienta poderosa que verifica el cumplimiento de nuestro c\u00f3digo con PEP8 . Flake8 es un wrapper de estas herramientas: PyFlakes pycodestyle El gui\u00f3n de McCabe de Ned Batchelder Flake8 ejecuta todas las herramientas ejecutando el \u00fanico comando flake8. Muestra las advertencias en una salida combinada por archivo.","title":"Flake8"},{"location":"code_quality/flake8/#instalacion","text":"Si desea que Flake8 se instale para su instalaci\u00f3n predeterminada de Python, puede usar: # using pip (pip3) $ pip install flake8 # using pipenv $ pipenv install flake8 # using poetry $ poetry add flake8","title":"Instalaci\u00f3n"},{"location":"code_quality/flake8/#uso","text":"Veamos un ejemplo sencillo: %% writefile example_01 . py def is_unique ( s ): \"\"\" Black is the uncompromising Python code formatter. By using it, you agree to cede control over minutiae of hand-formatting. \"\"\" s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ()) ) Overwriting example_01.py Ocupemos flake8 para analizar nuestro c\u00f3digo: ! python - m flake8 example_01 . py example_01.py:1:15: W291 trailing whitespace example_01.py:2:17: W291 trailing whitespace example_01.py:3:18: W291 trailing whitespace example_01.py:5:80: E501 line too long (127 > 79 characters) example_01.py:5:128: W291 trailing whitespace example_01.py:7:15: W291 trailing whitespace example_01.py:8:17: E124 closing bracket does not match visual indentation example_01.py:8:18: W291 trailing whitespace example_01.py:9:13: W291 trailing whitespace example_01.py:10:1: W293 blank line contains whitespace example_01.py:11:1: W293 blank line contains whitespace example_01.py:12:5: E303 too many blank lines (2) example_01.py:12:32: W291 trailing whitespace example_01.py:13:29: W291 trailing whitespace example_01.py:15:10: W291 trailing whitespace example_01.py:17:1: W293 blank line contains whitespace example_01.py:18:1: W293 blank line contains whitespace example_01.py:19:27: W291 trailing whitespace example_01.py:20:11: W291 trailing whitespace example_01.py:21:29: W291 trailing whitespace example_01.py:22:11: W291 trailing whitespace flake8 nos muestra una lista detallada de: nombre del c\u00f3digo que no esta cumpliendo alguna pol\u00edtica de flake8 l\u00ednea que no esta cumpliendo alguna de las pol\u00edticas de flake8 regla o pol\u00edtica de flake8 que se esta rompiendo ( Para ver algunas de las reglas de flake8 conculte el siguiente link ) Veamos qu\u00e9 sucede si el c\u00f3digo est\u00e1 escrito correctamente: %% writefile example_01 . py def is_unique ( s ): \"\"\" Black is the uncompromising Python code formatter. By using it, you agree to cede control over minutiae of hand-formatting. \"\"\" s = list ( s ) s . sort () for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: return 0 else : return 1 if __name__ == \"__main__\" : print ( is_unique ( input ())) Overwriting example_01.py ! python - m flake8 example_01 . py Cuando el c\u00f3digo est\u00e1 escrito correctamente, flake8 no arroja ning\u00fan mensaje, dondo a entender al usuario que su c\u00f3digo cumple con todas las pol\u00edticas del PEP8. Si usted quiere ver m\u00e1s opciones de flake8 (mediante l\u00ednea de comando), ejecute: ! python - m flake8 -- help usage: flake8 [options] file file ... positional arguments: filename optional arguments: -h, --help show this help message and exit -v, --verbose Print more information about what is happening in flake8. This option is repeatable and will increase verbosity each time it is repeated. --output-file OUTPUT_FILE Redirect report to a file. --append-config APPEND_CONFIG Provide extra config files to parse in addition to the files found by Flake8 by default. These files are the last ones read and so they take the highest precedence when multiple files provide the same option. --config CONFIG Path to the config file that will be the authoritative config source. This will cause Flake8 to ignore all other configuration files. --isolated Ignore all configuration files. --version show program's version number and exit -q, --quiet Report only file names, or nothing. This option is repeatable. --count Print total number of errors and warnings to standard error and set the exit code to 1 if total is not empty. --diff Report changes only within line number ranges in the unified diff provided on standard in by the user. --exclude patterns Comma-separated list of files or directories to exclude. (Default: ['.svn', 'CVS', '.bzr', '.hg', '.git', '__pycache__', '.tox', '.eggs', '*.egg']) --extend-exclude patterns Comma-separated list of files or directories to add to the list of excluded ones. --filename patterns Only check for filenames matching the patterns in this comma-separated list. (Default: ['*.py']) --stdin-display-name STDIN_DISPLAY_NAME The name used when reporting errors from code passed via stdin. This is useful for editors piping the file contents to flake8. (Default: stdin) --format format Format errors according to the chosen formatter. --hang-closing Hang closing bracket instead of matching indentation of opening bracket's line. --ignore errors Comma-separated list of errors and warnings to ignore (or skip). For example, ``--ignore=E4,E51,W234``. (Default: ['E704', 'E123', 'W503', 'E126', 'E24', 'W504', 'E226', 'E121']) --extend-ignore errors Comma-separated list of errors and warnings to add to the list of ignored ones. For example, ``--extend- ignore=E4,E51,W234``. --per-file-ignores PER_FILE_IGNORES A pairing of filenames and violation codes that defines which violations to ignore in a particular file. The filenames can be specified in a manner similar to the ``--exclude`` option and the violations work similarly to the ``--ignore`` and ``--select`` options. --max-line-length n Maximum allowed line length for the entirety of this run. (Default: 79) --max-doc-length n Maximum allowed doc line length for the entirety of this run. (Default: None) --select errors Comma-separated list of errors and warnings to enable. For example, ``--select=E4,E51,W234``. (Default: ['E', 'F', 'W', 'C90']) --disable-noqa Disable the effect of \"# noqa\". This will report errors on lines with \"# noqa\" at the end. --show-source Show the source generate each error or warning. --statistics Count errors and warnings. --enable-extensions ENABLE_EXTENSIONS Enable plugins and extensions that are otherwise disabled by default --exit-zero Exit with status code \"0\" even if there are errors. --install-hook {git,mercurial} Install a hook that is run prior to a commit for the supported version control system. -j JOBS, --jobs JOBS Number of subprocesses to use to run checks in parallel. This is ignored on Windows. The default, \"auto\", will auto-detect the number of processors available to use. (Default: auto) --tee Write to stdout and output-file. --benchmark Print benchmark information about this run of Flake8 --bug-report Print information necessary when preparing a bug report mccabe: --max-complexity MAX_COMPLEXITY McCabe complexity threshold pyflakes: --builtins BUILTINS define more built-ins, comma separated --doctests also check syntax of the doctests --include-in-doctest INCLUDE_IN_DOCTEST Run doctests only on these files --exclude-from-doctest EXCLUDE_FROM_DOCTEST Skip these files when running doctests Installed plugins: mccabe: 0.6.1, pycodestyle: 2.6.0, pyflakes: 2.2.0 Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Uso"},{"location":"code_quality/mypy/","text":"Mypy Introducci\u00f3n Mypy es un verificador de tipo est\u00e1tico opcional para Python que tiene como objetivo combinar los beneficios de la escritura din\u00e1mica y la escritura est\u00e1tica. Mypy combina el poder expresivo y la conveniencia de Python con un poderoso sistema de tipos y verificaci\u00f3n de tipos en tiempo de compilaci\u00f3n. El tipo Mypy comprueba los programas est\u00e1ndar de Python; ejec\u00fatelos usando cualquier m\u00e1quina virtual de Python sin b\u00e1sicamente una sobrecarga de tiempo de ejecuci\u00f3n. Escritura din\u00e1mica y est\u00e1tica Migre el c\u00f3digo existente a escritura est\u00e1tica, una funci\u00f3n a la vez. Puede mezclar libremente la escritura est\u00e1tica y din\u00e1mica dentro de un programa, dentro de un m\u00f3dulo o dentro de una expresi\u00f3n. No es necesario renunciar a la escritura din\u00e1mica: utilice la escritura est\u00e1tica cuando tenga sentido. A menudo, el simple hecho de agregar firmas de funciones le proporciona un c\u00f3digo escrito est\u00e1ticamente. Mypy puede inferir los tipos de otras variables. Sintaxis de Python El tipo Mypy comprueba los programas que tienen anotaciones de tipo que cumplen con PEP 484 . Empezar es f\u00e1cil si conoce Python. El objetivo es admitir casi todas las construcciones del lenguaje Python en mypy. Instalaci\u00f3n Mypy requiere Python 3.5 o una versi\u00f3n superior para ejecutarse. Para instalar Mypy se debe ejecutar por terminal: # using pip (pip3) $ pip install mypy # using pipenv $ pipenv install mypy # using poetry $ poetry add mypy Uso Para archivos de manera individual (ejemplo algo.py ), se debe ejecutar por terminal la sentencia: $ mypy algo.py Formas de uso Aqu\u00ed hay algunos programas de ejemplo de mypy. Cada ejemplo tiene c\u00f3digo Python/mypy escrito din\u00e1micamente y c\u00f3digo mypy escrito est\u00e1ticamente equivalente lado a lado. Todos los programas siguen siendo v\u00e1lidos en Python 3.x. Se destacan todas las diferencias entre las variantes. Frecuencias de palabras con un diccionario En este ejemplo, agregamos una declaraci\u00f3n de tipo expl\u00edcita para la variable d , ya que no es obvio en el contexto local. Mypy with static typing %% writefile example_01 . py # Display the frequencies of words in a file. import sys import re if not sys . argv [ 1 :]: raise RuntimeError ( 'Usage: wordfreq FILE' ) d = {} with open ( sys . argv [ 1 ]) as f : for s in f : for word in re . sub ( '\\W' , ' ' , s ) . split (): d [ word ] = d . get ( word , 0 ) + 1 # Use list comprehension l = [( freq , word ) for word , freq in d . items ()] for freq , word in sorted ( l ): print ( ' %-6d %s ' % ( freq , word )) Overwriting example_01.py ! mypy ./ example_01 . py example_01.py:9: \u001b[1m\u001b[31merror:\u001b[m Need type annotation for 'd' (hint: \u001b[m\u001b[1m\"d: Dict[<type>, <type>] = ...\"\u001b[m)\u001b[m \u001b[1m\u001b[31mFound 1 error in 1 file (checked 1 source file)\u001b[m Mypy with dynamic typing %% writefile example_02 . py # Display the frequencies of words in a file. import sys import re from typing import Dict if not sys . argv [ 1 :]: raise RuntimeError ( 'Usage: wordfreq FILE' ) d = {} # type: Dict[str, int] with open ( sys . argv [ 1 ]) as f : for s in f : for word in re . sub ( '\\W' , ' ' , s ) . split (): d [ word ] = d . get ( word , 0 ) + 1 # Use list comprehension l = [( freq , word ) for word , freq in d . items ()] for freq , word in sorted ( l ): print ( ' %-6d %s ' % ( freq , word )) Writing example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m Clase simple En este ejemplo, elegimos usar n\u00fameros enteros para representar el balance. Esto estar\u00eda bien en un juego, por ejemplo, pero en otras aplicaciones, un tipo diferente tendr\u00eda m\u00e1s sentido. Mypy with static typing %% writefile example_01 . py class BankAccount : def __init__ ( self , initial_balance = 0 ): self . balance = initial_balance def deposit ( self , amount ): self . balance += amount def withdraw ( self , amount ): self . balance -= amount def overdrawn ( self ): return self . balance < 0 my_account = BankAccount ( 15 ) my_account . withdraw ( 5 ) print ( my_account . balance ) Overwriting example_01.py ! mypy example_01 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m Mypy with dynamic typing %% writefile example_02 . py class BankAccount : def __init__ ( self , initial_balance : int = 0 ) -> None : self . balance = initial_balance def deposit ( self , amount : int ) -> None : self . balance += amount def withdraw ( self , amount : int ) -> None : self . balance -= amount def overdrawn ( self ) -> bool : return self . balance < 0 my_account = BankAccount ( 15 ) my_account . withdraw ( 5 ) print ( my_account . balance ) Overwriting example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m N\u00fameros primos con generadores Como el ejemplo de la cuenta bancaria, esto fue adaptado de la wiki de Python. Mypy with static typing %% writefile example_01 . py import itertools def iter_primes (): # An iterator of all numbers between 2 and # +infinity numbers = itertools . count ( 2 ) # Generate primes forever while True : # Get the first number from the iterator # (always a prime) prime = next ( numbers ) yield prime # This code iteratively builds up a chain # of filters... numbers = filter ( prime . __rmod__ , numbers ) for p in iter_primes (): if p > 1000 : break print ( p ) Overwriting example_01.py ! mypy ./ example_01 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m Mypy with dynamic typing %% writefile example_02 . py import itertools from typing import Iterator def iter_primes () -> Iterator [ int ]: # An iterator of all numbers between 2 and # +infinity numbers = itertools . count ( 2 ) # Generate primes forever while True : # Get the first number from the iterator # (always a prime) prime = next ( numbers ) yield prime # This code iteratively builds up a chain # of filters... numbers = filter ( prime . __rmod__ , numbers ) for p in iter_primes (): if p > 1000 : break print ( p ) Overwriting example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. ! rm - r example_01 . py example_02 . py","title":"Mypy"},{"location":"code_quality/mypy/#mypy","text":"","title":"Mypy"},{"location":"code_quality/mypy/#introduccion","text":"Mypy es un verificador de tipo est\u00e1tico opcional para Python que tiene como objetivo combinar los beneficios de la escritura din\u00e1mica y la escritura est\u00e1tica. Mypy combina el poder expresivo y la conveniencia de Python con un poderoso sistema de tipos y verificaci\u00f3n de tipos en tiempo de compilaci\u00f3n. El tipo Mypy comprueba los programas est\u00e1ndar de Python; ejec\u00fatelos usando cualquier m\u00e1quina virtual de Python sin b\u00e1sicamente una sobrecarga de tiempo de ejecuci\u00f3n.","title":"Introducci\u00f3n"},{"location":"code_quality/mypy/#escritura-dinamica-y-estatica","text":"Migre el c\u00f3digo existente a escritura est\u00e1tica, una funci\u00f3n a la vez. Puede mezclar libremente la escritura est\u00e1tica y din\u00e1mica dentro de un programa, dentro de un m\u00f3dulo o dentro de una expresi\u00f3n. No es necesario renunciar a la escritura din\u00e1mica: utilice la escritura est\u00e1tica cuando tenga sentido. A menudo, el simple hecho de agregar firmas de funciones le proporciona un c\u00f3digo escrito est\u00e1ticamente. Mypy puede inferir los tipos de otras variables.","title":"Escritura din\u00e1mica y est\u00e1tica"},{"location":"code_quality/mypy/#sintaxis-de-python","text":"El tipo Mypy comprueba los programas que tienen anotaciones de tipo que cumplen con PEP 484 . Empezar es f\u00e1cil si conoce Python. El objetivo es admitir casi todas las construcciones del lenguaje Python en mypy.","title":"Sintaxis de Python"},{"location":"code_quality/mypy/#instalacion","text":"Mypy requiere Python 3.5 o una versi\u00f3n superior para ejecutarse. Para instalar Mypy se debe ejecutar por terminal: # using pip (pip3) $ pip install mypy # using pipenv $ pipenv install mypy # using poetry $ poetry add mypy","title":"Instalaci\u00f3n"},{"location":"code_quality/mypy/#uso","text":"Para archivos de manera individual (ejemplo algo.py ), se debe ejecutar por terminal la sentencia: $ mypy algo.py","title":"Uso"},{"location":"code_quality/mypy/#formas-de-uso","text":"Aqu\u00ed hay algunos programas de ejemplo de mypy. Cada ejemplo tiene c\u00f3digo Python/mypy escrito din\u00e1micamente y c\u00f3digo mypy escrito est\u00e1ticamente equivalente lado a lado. Todos los programas siguen siendo v\u00e1lidos en Python 3.x. Se destacan todas las diferencias entre las variantes.","title":"Formas de uso"},{"location":"code_quality/mypy/#frecuencias-de-palabras-con-un-diccionario","text":"En este ejemplo, agregamos una declaraci\u00f3n de tipo expl\u00edcita para la variable d , ya que no es obvio en el contexto local.","title":"Frecuencias de palabras con un diccionario"},{"location":"code_quality/mypy/#mypy-with-static-typing","text":"%% writefile example_01 . py # Display the frequencies of words in a file. import sys import re if not sys . argv [ 1 :]: raise RuntimeError ( 'Usage: wordfreq FILE' ) d = {} with open ( sys . argv [ 1 ]) as f : for s in f : for word in re . sub ( '\\W' , ' ' , s ) . split (): d [ word ] = d . get ( word , 0 ) + 1 # Use list comprehension l = [( freq , word ) for word , freq in d . items ()] for freq , word in sorted ( l ): print ( ' %-6d %s ' % ( freq , word )) Overwriting example_01.py ! mypy ./ example_01 . py example_01.py:9: \u001b[1m\u001b[31merror:\u001b[m Need type annotation for 'd' (hint: \u001b[m\u001b[1m\"d: Dict[<type>, <type>] = ...\"\u001b[m)\u001b[m \u001b[1m\u001b[31mFound 1 error in 1 file (checked 1 source file)\u001b[m","title":"Mypy with static typing"},{"location":"code_quality/mypy/#mypy-with-dynamic-typing","text":"%% writefile example_02 . py # Display the frequencies of words in a file. import sys import re from typing import Dict if not sys . argv [ 1 :]: raise RuntimeError ( 'Usage: wordfreq FILE' ) d = {} # type: Dict[str, int] with open ( sys . argv [ 1 ]) as f : for s in f : for word in re . sub ( '\\W' , ' ' , s ) . split (): d [ word ] = d . get ( word , 0 ) + 1 # Use list comprehension l = [( freq , word ) for word , freq in d . items ()] for freq , word in sorted ( l ): print ( ' %-6d %s ' % ( freq , word )) Writing example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m","title":"Mypy with dynamic typing"},{"location":"code_quality/mypy/#clase-simple","text":"En este ejemplo, elegimos usar n\u00fameros enteros para representar el balance. Esto estar\u00eda bien en un juego, por ejemplo, pero en otras aplicaciones, un tipo diferente tendr\u00eda m\u00e1s sentido.","title":"Clase simple"},{"location":"code_quality/mypy/#mypy-with-static-typing_1","text":"%% writefile example_01 . py class BankAccount : def __init__ ( self , initial_balance = 0 ): self . balance = initial_balance def deposit ( self , amount ): self . balance += amount def withdraw ( self , amount ): self . balance -= amount def overdrawn ( self ): return self . balance < 0 my_account = BankAccount ( 15 ) my_account . withdraw ( 5 ) print ( my_account . balance ) Overwriting example_01.py ! mypy example_01 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m","title":"Mypy with static typing"},{"location":"code_quality/mypy/#mypy-with-dynamic-typing_1","text":"%% writefile example_02 . py class BankAccount : def __init__ ( self , initial_balance : int = 0 ) -> None : self . balance = initial_balance def deposit ( self , amount : int ) -> None : self . balance += amount def withdraw ( self , amount : int ) -> None : self . balance -= amount def overdrawn ( self ) -> bool : return self . balance < 0 my_account = BankAccount ( 15 ) my_account . withdraw ( 5 ) print ( my_account . balance ) Overwriting example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m","title":"Mypy with dynamic typing"},{"location":"code_quality/mypy/#numeros-primos-con-generadores","text":"Como el ejemplo de la cuenta bancaria, esto fue adaptado de la wiki de Python.","title":"N\u00fameros primos con generadores"},{"location":"code_quality/mypy/#mypy-with-static-typing_2","text":"%% writefile example_01 . py import itertools def iter_primes (): # An iterator of all numbers between 2 and # +infinity numbers = itertools . count ( 2 ) # Generate primes forever while True : # Get the first number from the iterator # (always a prime) prime = next ( numbers ) yield prime # This code iteratively builds up a chain # of filters... numbers = filter ( prime . __rmod__ , numbers ) for p in iter_primes (): if p > 1000 : break print ( p ) Overwriting example_01.py ! mypy ./ example_01 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m","title":"Mypy with static typing"},{"location":"code_quality/mypy/#mypy-with-dynamic-typing_2","text":"%% writefile example_02 . py import itertools from typing import Iterator def iter_primes () -> Iterator [ int ]: # An iterator of all numbers between 2 and # +infinity numbers = itertools . count ( 2 ) # Generate primes forever while True : # Get the first number from the iterator # (always a prime) prime = next ( numbers ) yield prime # This code iteratively builds up a chain # of filters... numbers = filter ( prime . __rmod__ , numbers ) for p in iter_primes (): if p > 1000 : break print ( p ) Overwriting example_02.py ! mypy ./ example_02 . py \u001b[1m\u001b[32mSuccess: no issues found in 1 source file\u001b[m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. ! rm - r example_01 . py example_02 . py","title":"Mypy with dynamic typing"},{"location":"code_quality/precommit/","text":"Pre-commit Introducci\u00f3n La revisi\u00f3n de c\u00f3digo es una etapa importante en los proyectos de desarrollo de software, puesto que es en ella donde vamos aprendiendo de la forma de programar de otros integrantes del equipo. No obstante, existen algunos inconvenientes al momento de la revisi\u00f3n que nos gustar\u00eda mejorar: Menos tiempo comentando el formato del c\u00f3digo y m\u00e1s tiempo discutiendo la l\u00f3gica del c\u00f3digo Menos problemas para detectar errores de formato (\"\u00bfrealmente puede ver ese espacio en blanco al final de la l\u00ednea 76?\") Deja de parecer quisquilloso (\"Pon dos l\u00edneas en blanco entre las definiciones de funciones\") Si pudiera automatizar los procesos anteriores y eliminar el humano en el ciclo, podr\u00edamos centrarnos m\u00e1s en la l\u00f3gica y la implementaci\u00f3n del c\u00f3digo. Para ello existen los Git hooks , espec\u00edficamente los pre-commit hook . Estos les permite ejecutar autom\u00e1ticamente un breve script antes del commit . Antes de enviar mis archivos de Python preparados, black formatea mi c\u00f3digo y flake8 verifica mi cumplimiento con PEP8. Si todo pasa, se realiza el commit . Si no es as\u00ed, realizo las ediciones necesarias y se hace un commit de nuevo. Se dedica menos tiempo al formateo del c\u00f3digo, por lo que puedo centrarme m\u00e1s en la l\u00f3gica del c\u00f3digo. The pre-commit Python framework Para adoptar el pre-commit en nuestro sistema, simplemente realizamos las siguientes acciones: Instalar pre-commit : pip install pre-commit Agregue pre-commit a requirements.txt (o requirements-dev.txt) Defina .pre-commit-config.yaml con los hooks que desea incluir. Ejecute pre-commit install para instalar git hooks en su directorio .git /. El archivo YAML configura las fuentes de donde se tomar\u00e1n los hooks . En nuestro caso, flake8 ya se ha incluido en este marco, por lo que solo necesitamos especificar su id. Por otro lado, necesitamos definir d\u00f3nde obtener black usando pocas l\u00edneas de c\u00f3digo. A continuaci\u00f3n se muestra un archivo .pre-commit-config.yaml de ejemplo: repos : - repo : https://github.com/ambv/black rev : stable hooks : - id : black language_version : python3.6 - repo : https://gitlab.com/pycqa/flake8 rev : 3.7.9 hooks : - id : flake8 [flake8] ignore = E203 , E266 , E501 , W503 , F403 , F401 max-line-length = 79 max-complexity = 18 select = B , C , E , F , W , T4 , B9 Resultado Ahora que tenemos un marco de trabajo previo a la confirmaci\u00f3n con black y flake8 , \u00a1ve\u00e1moslo en acci\u00f3n!","title":"Pre-commit"},{"location":"code_quality/precommit/#pre-commit","text":"","title":"Pre-commit"},{"location":"code_quality/precommit/#introduccion","text":"La revisi\u00f3n de c\u00f3digo es una etapa importante en los proyectos de desarrollo de software, puesto que es en ella donde vamos aprendiendo de la forma de programar de otros integrantes del equipo. No obstante, existen algunos inconvenientes al momento de la revisi\u00f3n que nos gustar\u00eda mejorar: Menos tiempo comentando el formato del c\u00f3digo y m\u00e1s tiempo discutiendo la l\u00f3gica del c\u00f3digo Menos problemas para detectar errores de formato (\"\u00bfrealmente puede ver ese espacio en blanco al final de la l\u00ednea 76?\") Deja de parecer quisquilloso (\"Pon dos l\u00edneas en blanco entre las definiciones de funciones\") Si pudiera automatizar los procesos anteriores y eliminar el humano en el ciclo, podr\u00edamos centrarnos m\u00e1s en la l\u00f3gica y la implementaci\u00f3n del c\u00f3digo. Para ello existen los Git hooks , espec\u00edficamente los pre-commit hook . Estos les permite ejecutar autom\u00e1ticamente un breve script antes del commit . Antes de enviar mis archivos de Python preparados, black formatea mi c\u00f3digo y flake8 verifica mi cumplimiento con PEP8. Si todo pasa, se realiza el commit . Si no es as\u00ed, realizo las ediciones necesarias y se hace un commit de nuevo. Se dedica menos tiempo al formateo del c\u00f3digo, por lo que puedo centrarme m\u00e1s en la l\u00f3gica del c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"code_quality/precommit/#the-pre-commit-python-framework","text":"Para adoptar el pre-commit en nuestro sistema, simplemente realizamos las siguientes acciones: Instalar pre-commit : pip install pre-commit Agregue pre-commit a requirements.txt (o requirements-dev.txt) Defina .pre-commit-config.yaml con los hooks que desea incluir. Ejecute pre-commit install para instalar git hooks en su directorio .git /. El archivo YAML configura las fuentes de donde se tomar\u00e1n los hooks . En nuestro caso, flake8 ya se ha incluido en este marco, por lo que solo necesitamos especificar su id. Por otro lado, necesitamos definir d\u00f3nde obtener black usando pocas l\u00edneas de c\u00f3digo. A continuaci\u00f3n se muestra un archivo .pre-commit-config.yaml de ejemplo: repos : - repo : https://github.com/ambv/black rev : stable hooks : - id : black language_version : python3.6 - repo : https://gitlab.com/pycqa/flake8 rev : 3.7.9 hooks : - id : flake8 [flake8] ignore = E203 , E266 , E501 , W503 , F403 , F401 max-line-length = 79 max-complexity = 18 select = B , C , E , F , W , T4 , B9","title":"The pre-commit Python framework"},{"location":"code_quality/precommit/#resultado","text":"Ahora que tenemos un marco de trabajo previo a la confirmaci\u00f3n con black y flake8 , \u00a1ve\u00e1moslo en acci\u00f3n!","title":"Resultado"},{"location":"documentation/commenting/","text":"Comentar vs documentar Antes de que podamos profundizar en c\u00f3mo documentar su c\u00f3digo Python, debemos distinguir entre documentar y comentar. En general, comentar es describir su c\u00f3digo a / para desarrolladores. La audiencia principal prevista son los mantenedores y desarrolladores del c\u00f3digo Python. Junto con un c\u00f3digo bien escrito, los comentarios ayudan a guiar al lector a comprender mejor su c\u00f3digo y su prop\u00f3sito y dise\u00f1o: Code tells you how; Comments tell you why \u2014 Jeff Atwood (aka Coding Horror) Documentar c\u00f3digo es describir su uso y funcionalidad a sus usuarios. Si bien puede ser \u00fatil en el proceso de desarrollo, el p\u00fablico objetivo principal son los usuarios. La siguiente secci\u00f3n describe c\u00f3mo y cu\u00e1ndo comentar su c\u00f3digo. Conceptos b\u00e1sicos del c\u00f3digo de comentarios Los comentarios se crean en Python usando el signo de almohadilla (#) y deben ser declaraciones breves de no m\u00e1s de unas pocas oraciones. A continuaci\u00f3n, se muestra un ejemplo sencillo: def hello_world(): # A simple comment preceding a simple print statement print(\"Hello World\") Seg\u00fan PEP 8 , los comentarios deben tener una longitud m\u00e1xima de 72 caracteres. Esto es cierto incluso si su proyecto cambia la longitud m\u00e1xima de la l\u00ednea para que sea mayor que los 80 caracteres recomendados. Si un comentario va a ser mayor que el l\u00edmite de caracteres del comentario, es apropiado usar varias l\u00edneas para el comentario: def hello_long_world(): # A very long statement that just goes on and on and on and on and # never ends until after it's reached the 80 char limit print(\"Hellooooooooooooooooooooooooooooooooooooooooooooooooooooooo World\") Comentar su c\u00f3digo tiene varios prop\u00f3sitos, que incluyen: Planificaci\u00f3n y revisi\u00f3n : cuando est\u00e1 desarrollando nuevas partes de su c\u00f3digo, puede ser apropiado utilizar primero los comentarios como una forma de planificar o delinear esa secci\u00f3n de c\u00f3digo. Recuerde eliminar estos comentarios una vez que se haya implementado y revisado / probado la codificaci\u00f3n real: # First step # Second step # Third step Descripci\u00f3n del c\u00f3digo : los comentarios se pueden utilizar para explicar la intenci\u00f3n de secciones espec\u00edficas del c\u00f3digo: # Attempt a connection based on previous settings. If unsuccessful, # prompt user for new settings. Descripci\u00f3n algor\u00edtmica : cuando se utilizan algoritmos, especialmente los complicados, puede ser \u00fatil explicar c\u00f3mo funciona el algoritmo o c\u00f3mo se implementa dentro de su c\u00f3digo. Tambi\u00e9n puede ser apropiado describir por qu\u00e9 se seleccion\u00f3 un algoritmo espec\u00edfico sobre otro. # Using quick sort for performance gains Tagging : el uso de etiquetado se puede utilizar para etiquetar secciones espec\u00edficas de c\u00f3digo donde se encuentran problemas conocidos o \u00e1reas de mejora. Algunos ejemplos son: BUG, FIXME y TODO. # TODO: Add condition for when val is None Los comentarios a su c\u00f3digo deben ser breves y enfocados. Evite el uso de comentarios largos cuando sea posible. Adem\u00e1s, debe utilizar las siguientes cuatro reglas esenciales sugeridas por Jeff Atwood : Mantenga los comentarios lo m\u00e1s cerca posible del c\u00f3digo que se describe. Los comentarios que no est\u00e1n cerca de su c\u00f3digo descriptivo son frustrantes para el lector y se pierden f\u00e1cilmente cuando se realizan actualizaciones. No utilice formatos complejos (como tablas o figuras ASCII). El formato complejo genera contenido que distrae y puede ser dif\u00edcil de mantener con el tiempo. No incluya informaci\u00f3n redundante. Suponga que el lector del c\u00f3digo tiene un conocimiento b\u00e1sico de los principios de programaci\u00f3n y la sintaxis del lenguaje. Dise\u00f1a tu c\u00f3digo para comentarlo. La forma m\u00e1s f\u00e1cil de entender el c\u00f3digo es ley\u00e9ndolo. Cuando dise\u00f1e su c\u00f3digo utilizando conceptos claros y f\u00e1ciles de entender, el lector podr\u00e1 conceptualizar r\u00e1pidamente su intenci\u00f3n. Recuerde que los comentarios est\u00e1n dise\u00f1ados para el lector, incluido usted mismo, para ayudarlo a guiarlo en la comprensi\u00f3n del prop\u00f3sito y el dise\u00f1o del software. Comentario de c\u00f3digo a trav\u00e9s de sugerencias de tipo La sugerencia de tipo se agreg\u00f3 a Python 3.5 y es un formulario adicional para ayudar a los lectores de su c\u00f3digo. De hecho, lleva la cuarta sugerencia de Jeff de arriba al siguiente nivel. Permite al desarrollador dise\u00f1ar y explicar partes de su c\u00f3digo sin comentar. A continuaci\u00f3n, se muestra un ejemplo r\u00e1pido: def hello_name(name: str) -> str: return(f\"Hello {name}\") Al examinar la sugerencia de tipo, puede saber inmediatamente que la funci\u00f3n espera que el nombre de entrada sea de un tipo str o string. Tambi\u00e9n puede decir que la salida esperada de la funci\u00f3n ser\u00e1 de tipo str, o string, tambi\u00e9n. Si bien las sugerencias de tipo ayudan a reducir los comentarios, tenga en cuenta que hacerlo tambi\u00e9n puede generar un trabajo adicional al crear o actualizar la documentaci\u00f3n de su proyecto. Puede obtener m\u00e1s informaci\u00f3n sobre las sugerencias de tipo y la verificaci\u00f3n de tipo en este video creado por Dan Bader .","title":"Comentar vs Documentar"},{"location":"documentation/commenting/#comentar-vs-documentar","text":"Antes de que podamos profundizar en c\u00f3mo documentar su c\u00f3digo Python, debemos distinguir entre documentar y comentar. En general, comentar es describir su c\u00f3digo a / para desarrolladores. La audiencia principal prevista son los mantenedores y desarrolladores del c\u00f3digo Python. Junto con un c\u00f3digo bien escrito, los comentarios ayudan a guiar al lector a comprender mejor su c\u00f3digo y su prop\u00f3sito y dise\u00f1o: Code tells you how; Comments tell you why \u2014 Jeff Atwood (aka Coding Horror) Documentar c\u00f3digo es describir su uso y funcionalidad a sus usuarios. Si bien puede ser \u00fatil en el proceso de desarrollo, el p\u00fablico objetivo principal son los usuarios. La siguiente secci\u00f3n describe c\u00f3mo y cu\u00e1ndo comentar su c\u00f3digo.","title":"Comentar vs documentar"},{"location":"documentation/commenting/#conceptos-basicos-del-codigo-de-comentarios","text":"Los comentarios se crean en Python usando el signo de almohadilla (#) y deben ser declaraciones breves de no m\u00e1s de unas pocas oraciones. A continuaci\u00f3n, se muestra un ejemplo sencillo: def hello_world(): # A simple comment preceding a simple print statement print(\"Hello World\") Seg\u00fan PEP 8 , los comentarios deben tener una longitud m\u00e1xima de 72 caracteres. Esto es cierto incluso si su proyecto cambia la longitud m\u00e1xima de la l\u00ednea para que sea mayor que los 80 caracteres recomendados. Si un comentario va a ser mayor que el l\u00edmite de caracteres del comentario, es apropiado usar varias l\u00edneas para el comentario: def hello_long_world(): # A very long statement that just goes on and on and on and on and # never ends until after it's reached the 80 char limit print(\"Hellooooooooooooooooooooooooooooooooooooooooooooooooooooooo World\") Comentar su c\u00f3digo tiene varios prop\u00f3sitos, que incluyen: Planificaci\u00f3n y revisi\u00f3n : cuando est\u00e1 desarrollando nuevas partes de su c\u00f3digo, puede ser apropiado utilizar primero los comentarios como una forma de planificar o delinear esa secci\u00f3n de c\u00f3digo. Recuerde eliminar estos comentarios una vez que se haya implementado y revisado / probado la codificaci\u00f3n real: # First step # Second step # Third step Descripci\u00f3n del c\u00f3digo : los comentarios se pueden utilizar para explicar la intenci\u00f3n de secciones espec\u00edficas del c\u00f3digo: # Attempt a connection based on previous settings. If unsuccessful, # prompt user for new settings. Descripci\u00f3n algor\u00edtmica : cuando se utilizan algoritmos, especialmente los complicados, puede ser \u00fatil explicar c\u00f3mo funciona el algoritmo o c\u00f3mo se implementa dentro de su c\u00f3digo. Tambi\u00e9n puede ser apropiado describir por qu\u00e9 se seleccion\u00f3 un algoritmo espec\u00edfico sobre otro. # Using quick sort for performance gains Tagging : el uso de etiquetado se puede utilizar para etiquetar secciones espec\u00edficas de c\u00f3digo donde se encuentran problemas conocidos o \u00e1reas de mejora. Algunos ejemplos son: BUG, FIXME y TODO. # TODO: Add condition for when val is None Los comentarios a su c\u00f3digo deben ser breves y enfocados. Evite el uso de comentarios largos cuando sea posible. Adem\u00e1s, debe utilizar las siguientes cuatro reglas esenciales sugeridas por Jeff Atwood : Mantenga los comentarios lo m\u00e1s cerca posible del c\u00f3digo que se describe. Los comentarios que no est\u00e1n cerca de su c\u00f3digo descriptivo son frustrantes para el lector y se pierden f\u00e1cilmente cuando se realizan actualizaciones. No utilice formatos complejos (como tablas o figuras ASCII). El formato complejo genera contenido que distrae y puede ser dif\u00edcil de mantener con el tiempo. No incluya informaci\u00f3n redundante. Suponga que el lector del c\u00f3digo tiene un conocimiento b\u00e1sico de los principios de programaci\u00f3n y la sintaxis del lenguaje. Dise\u00f1a tu c\u00f3digo para comentarlo. La forma m\u00e1s f\u00e1cil de entender el c\u00f3digo es ley\u00e9ndolo. Cuando dise\u00f1e su c\u00f3digo utilizando conceptos claros y f\u00e1ciles de entender, el lector podr\u00e1 conceptualizar r\u00e1pidamente su intenci\u00f3n. Recuerde que los comentarios est\u00e1n dise\u00f1ados para el lector, incluido usted mismo, para ayudarlo a guiarlo en la comprensi\u00f3n del prop\u00f3sito y el dise\u00f1o del software.","title":"Conceptos b\u00e1sicos del c\u00f3digo de comentarios"},{"location":"documentation/commenting/#comentario-de-codigo-a-traves-de-sugerencias-de-tipo","text":"La sugerencia de tipo se agreg\u00f3 a Python 3.5 y es un formulario adicional para ayudar a los lectores de su c\u00f3digo. De hecho, lleva la cuarta sugerencia de Jeff de arriba al siguiente nivel. Permite al desarrollador dise\u00f1ar y explicar partes de su c\u00f3digo sin comentar. A continuaci\u00f3n, se muestra un ejemplo r\u00e1pido: def hello_name(name: str) -> str: return(f\"Hello {name}\") Al examinar la sugerencia de tipo, puede saber inmediatamente que la funci\u00f3n espera que el nombre de entrada sea de un tipo str o string. Tambi\u00e9n puede decir que la salida esperada de la funci\u00f3n ser\u00e1 de tipo str, o string, tambi\u00e9n. Si bien las sugerencias de tipo ayudan a reducir los comentarios, tenga en cuenta que hacerlo tambi\u00e9n puede generar un trabajo adicional al crear o actualizar la documentaci\u00f3n de su proyecto. Puede obtener m\u00e1s informaci\u00f3n sobre las sugerencias de tipo y la verificaci\u00f3n de tipo en este video creado por Dan Bader .","title":"Comentario de c\u00f3digo a trav\u00e9s de sugerencias de tipo"},{"location":"documentation/documenting/","text":"Documentar mediante Docstrings Ahora que hemos aprendido a comentar, profundicemos en la documentaci\u00f3n de una base de c\u00f3digo Python. En esta secci\u00f3n, aprender\u00e1 acerca de las docstrings y c\u00f3mo usarlas para la documentaci\u00f3n. Esta secci\u00f3n se divide en las siguientes subsecciones: Docstrings Background : informaci\u00f3n b\u00e1sica sobre c\u00f3mo funcionan los docstrings internamente en Python Docstring Types : los distintos \"tipos\" de docstrings (funci\u00f3n, clase, m\u00e9todo de clase, m\u00f3dulo, paquete y secuencia de comandos) Docstring Formats : los diferentes \"formatos\" de docstrings (Google, NumPy / SciPy, reStructuredText y Epytext) Docstrings Background La documentaci\u00f3n de su c\u00f3digo Python se centra en docstrings. Estas son strings integradas que, cuando se configuran correctamente, pueden ayudar a sus usuarios y a usted mismo con la documentaci\u00f3n de su proyecto. Junto con los docstrings, Python tambi\u00e9n tiene la funci\u00f3n incorporada help() que imprime el docstrings de los objetos en la consola. A continuaci\u00f3n, se muestra un ejemplo r\u00e1pido: >>> help(str) Help on class str in module builtins: class str(object) | str(object='') -> str | str(bytes_or_buffer[, encoding[, errors]]) -> str | | Create a new string object from the given object. If encoding or | errors are specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) | or repr(object). | encoding defaults to sys.getdefaultencoding(). | errors defaults to 'strict'. # Truncated for readability \u00bfC\u00f3mo se genera esta salida? Dado que todo en Python es un objeto, puede examinar el directorio del objeto usando el comando dir() . Hag\u00e1moslo y veamos qu\u00e9 encontramos: >>> dir(str) ['__add__', ..., '__doc__', ..., 'zfill'] # Truncated for readability Dentro de la salida de ese directorio, hay una propiedad interesante, __doc__ . Si examina esa propiedad, descubrir\u00e1 esto: >>> print(str.__doc__) str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors are specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'. \u00a1Voil\u00e0! Descubri\u00f3 d\u00f3nde se almacenan las docstrings dentro del objeto. Esto significa que puede manipular directamente esa propiedad. Sin embargo, existen restricciones para las incorporaciones: >>> str.__doc__ = \"I'm a little string doc! Short and stout; here is my input and print me for my out\" Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't set attributes of built-in/extension type 'str' Se puede manipular cualquier otro objeto personalizado: def say_hello(name): print(f\"Hello {name}, is it me you're looking for?\") say_hello.__doc__ = \"A simple function that says hello... Richie style\" >>> help(say_hello) Help on function say_hello in module __main__: say_hello(name) A simple function that says hello... Richie style Python tiene una caracter\u00edstica m\u00e1s que simplifica la creaci\u00f3n de docstrings. En lugar de manipular directamente la propiedad __doc__ , la ubicaci\u00f3n estrat\u00e9gica del ddocstrings directamente debajo del objeto establecer\u00e1 autom\u00e1ticamente el valor __doc__ . Esto es lo que sucede con el mismo ejemplo anterior: def say_hello(name): \"\"\"A simple function that says hello... Richie style\"\"\" print(f\"Hello {name}, is it me you're looking for?\") >>> help(say_hello) Help on function say_hello in module __main__: say_hello(name) A simple function that says hello... Richie style \u00a1Ah\u00ed tienes! Ahora comprende el trasfondo de las docstrings. Ha llegado el momento de conocer los diferentes tipos de docstrings y la informaci\u00f3n que deben contener. Docstring Types Las convenciones de strings de documentos se describen en PEP 257 . Su prop\u00f3sito es proporcionar a los usuarios una breve descripci\u00f3n general del objeto. Deben mantenerse lo suficientemente concisos para que sean f\u00e1ciles de mantener, pero igualmente elaborados para que los nuevos usuarios comprendan su prop\u00f3sito y c\u00f3mo utilizar el objeto documentado. En todos los casos, las docstrings deben usar el formato de string de comillas triples y dobles (\"\" \"). Esto debe hacerse tanto si el docstrings tiene varias l\u00edneas como si no. Como m\u00ednimo, un docstrings debe ser un resumen r\u00e1pido de lo que sea lo que est\u00e1 describiendo y debe estar contenido en una sola l\u00ednea: \"\"\"This is a quick summary line used as a description of the object.\"\"\" Los docstrings de varias l\u00edneas se utilizan para desarrollar m\u00e1s el objeto m\u00e1s all\u00e1 del resumen. Todas los docstrings de varias l\u00edneas tienen las siguientes partes: Una l\u00ednea de resumen de una l\u00ednea Una l\u00ednea en blanco que precede al resumen Cualquier elaboraci\u00f3n adicional para el docstrings Otra linea en blanco \"\"\"This is the summary line This is the further elaboration of the docstring. Within this section, you can elaborate further on details as appropriate for the situation. Notice that the summary and the elaboration is separated by a blank new line. \"\"\" # Notice the blank line above. Code should continue on this line. Todas las docstrings deben tener la misma longitud m\u00e1xima de caracteres que los comentarios (72 caracteres). Las docstrings se pueden dividir en tres categor\u00edas principales: Class Docstrings : Clase y m\u00e9todos de clase Package and Module Docstrings : paquete, m\u00f3dulos y funciones Script Docstrings : Script y funciones Class Docstrings Las docstrings de clase se crean para la propia clase, as\u00ed como para cualquier m\u00e9todo de clase. Los docstrings se colocan inmediatamente despu\u00e9s de la clase o m\u00e9todo de clase con sangr\u00eda de un nivel: class SimpleClass: \"\"\"Class docstrings go here.\"\"\" def say_hello(self, name: str): \"\"\"Class method docstrings go here.\"\"\" print(f'Hello {name}') Los docstrings de la clase deben contener la siguiente informaci\u00f3n: Un breve resumen de su prop\u00f3sito y comportamiento. Cualquier m\u00e9todo p\u00fablico, junto con una breve descripci\u00f3n. Cualquier propiedad de clase (atributos) Cualquier cosa relacionada con la interfaz para subclases, si la clase est\u00e1 destinada a ser subclasificada. Los par\u00e1metros del constructor de la clase deben documentarse dentro del docstrings del m\u00e9todo de clase __init__ . Los m\u00e9todos individuales deben documentarse utilizando sus docstrings individuales. Los docstrings del m\u00e9todo de clase deben contener lo siguiente: Una breve descripci\u00f3n de qu\u00e9 es el m\u00e9todo y para qu\u00e9 se utiliza. Cualquier argumento (obligatorio y opcional) que se pase, incluidos los argumentos de palabras clave. Etiquete los argumentos que se consideren opcionales o que tengan un valor predeterminado Cualquier efecto secundario que se produzca al ejecutar el m\u00e9todo. Cualquier excepci\u00f3n que se plantee Cualquier restricci\u00f3n sobre cu\u00e1ndo se puede llamar al m\u00e9todo Tomemos un ejemplo simple de una clase de datos que representa un animal. Esta clase contendr\u00e1 algunas propiedades de clase, propiedades de instancia, un __init__ y un m\u00e9todo de instancia \u00fanico: class Animal: \"\"\" A class used to represent an Animal ... Attributes ---------- says_str : str a formatted string to print out what the animal says name : str the name of the animal sound : str the sound that the animal makes num_legs : int the number of legs the animal has (default 4) Methods ------- says(sound=None) Prints the animals name and what sound it makes \"\"\" says_str = \"A {name} says {sound}\" def __init__(self, name, sound, num_legs=4): \"\"\" Parameters ---------- name : str The name of the animal sound : str The sound the animal makes num_legs : int, optional The number of legs the animal (default is 4) \"\"\" self.name = name self.sound = sound self.num_legs = num_legs def says(self, sound=None): \"\"\"Prints what the animals name is and what sound it makes. If the argument `sound` isn't passed in, the default Animal sound is used. Parameters ---------- sound : str, optional The sound the animal makes (default is None) Raises ------ NotImplementedError If no sound is set for the animal or passed in as a parameter. \"\"\" if self.sound is None and sound is None: raise NotImplementedError(\"Silent Animals are not supported!\") out_sound = self.sound if sound is None else sound print(self.says_str.format(name=self.name, sound=out_sound)) Package and Module Docstrings Los docstrings del paquete deben colocarse en la parte superior del archivo __init__.py del paquete. Este docstrings debe enumerar los m\u00f3dulos y subpaquetes que exporta el paquete. Las docstrings del m\u00f3dulo son similares a las docstrings de la clase. En lugar de documentar las clases y los m\u00e9todos de clase, ahora es el m\u00f3dulo y las funciones que se encuentran dentro. Los docstrings del m\u00f3dulo se colocan en la parte superior del archivo incluso antes de cualquier importaci\u00f3n. Los docstrings del m\u00f3dulo deben incluir lo siguiente: Una breve descripci\u00f3n del m\u00f3dulo y su prop\u00f3sito. Una lista de las clases, excepciones, funciones y cualquier otro objeto exportado por el m\u00f3dulo. El docstrings de una funci\u00f3n de m\u00f3dulo debe incluir los mismos elementos que un m\u00e9todo de clase: Una breve descripci\u00f3n de qu\u00e9 es la funci\u00f3n y para qu\u00e9 se utiliza. Cualquier argumento (obligatorio y opcional) que se pase, incluidos los argumentos de palabras clave. Etiquete los argumentos que se consideren opcionales Cualquier efecto secundario que se produzca al ejecutar la funci\u00f3n. Cualquier excepci\u00f3n que se plantee Cualquier restricci\u00f3n sobre cu\u00e1ndo se puede llamar a la funci\u00f3n Script Docstrings Los scripts se consideran ejecutables de un solo archivo que se ejecutan desde la consola. Las docstrings para scripts se colocan en la parte superior del archivo y deben estar lo suficientemente bien documentadas para que los usuarios puedan tener una comprensi\u00f3n suficiente de c\u00f3mo usar el script. Deber\u00eda ser utilizable para su mensaje de \"uso\", cuando el usuario pasa incorrectamente un par\u00e1metro o usa la opci\u00f3n -h. Si usa argparse, puede omitir la documentaci\u00f3n espec\u00edfica del par\u00e1metro, suponiendo que se haya documentado correctamente en el par\u00e1metro de ayuda de la funci\u00f3n argparser.parser.add_argument. Se recomienda utilizar __doc__ para el par\u00e1metro de descripci\u00f3n dentro del constructor de argparse.ArgumentParser . Consulte nuestro tutorial sobre bibliotecas de an\u00e1lisis de l\u00ednea de comandos para obtener m\u00e1s detalles sobre c\u00f3mo usar argparse y otros analizadores de l\u00ednea de comando comunes. Finalmente, cualquier importaci\u00f3n personalizada o de terceros debe incluirse dentro de las docstrings para permitir a los usuarios saber qu\u00e9 paquetes pueden ser necesarios para ejecutar el script. A continuaci\u00f3n, se muestra un ejemplo de una secuencia de comandos que se usa para imprimir simplemente los encabezados de columna de una hoja de c\u00e1lculo: \"\"\"Spreadsheet Column Printer This script allows the user to print to the console all columns in the spreadsheet. It is assumed that the first row of the spreadsheet is the location of the columns. This tool accepts comma separated value files (.csv) as well as excel (.xls, .xlsx) files. This script requires that `pandas` be installed within the Python environment you are running this script in. This file can also be imported as a module and contains the following functions: * get_spreadsheet_cols - returns the column headers of the file * main - the main function of the script \"\"\" import argparse import pandas as pd def get_spreadsheet_cols(file_loc, print_cols=False): \"\"\"Gets and prints the spreadsheet's header columns Parameters ---------- file_loc : str The file location of the spreadsheet print_cols : bool, optional A flag used to print the columns to the console (default is False) Returns ------- list a list of strings used that are the header columns \"\"\" file_data = pd.read_excel(file_loc) col_headers = list(file_data.columns.values) if print_cols: print(\"\\n\".join(col_headers)) return col_headers def main(): parser = argparse.ArgumentParser(description=__doc__) parser.add_argument( 'input_file', type=str, help=\"The spreadsheet file to pring the columns of\" ) args = parser.parse_args() get_spreadsheet_cols(args.input_file, print_cols=True) if __name__ == \"__main__\": main() Docstring Formats Es posible que haya notado que, a lo largo de los ejemplos proporcionados en este tutorial, ha habido un formato espec\u00edfico con elementos comunes: argumentos, devoluciones y atributos. Hay formatos de docstrings espec\u00edficos que se pueden usar para ayudar a los usuarios y a los analizadores de docstrings a tener un formato familiar y conocido. El formato utilizado en los ejemplos de este tutorial son docstrings de estilo NumPy / SciPy. Algunos de los formatos m\u00e1s habituales son los siguientes: Formatting Type Description Supported by Sphynx Formal Specification Google docstrings Google\u2019s recommended form of documentation Yes No reStructuredText Official Python documentation standard; Not beginner friendly but feature rich Yes Yes NumPy/SciPy docstrings NumPy\u2019s combination of reStructuredText and Google Docstrings Yes Yes Epytext A Python adaptation of Epydoc; Great for Java developers Not officially Yes La selecci\u00f3n del formato de docstrings depende de usted, pero debe seguir con el mismo formato en todo su documento / proyecto. Los siguientes son ejemplos de cada tipo para darle una idea de c\u00f3mo se ve cada formato de documentaci\u00f3n. Google Docstrings Example \"\"\"Gets and prints the spreadsheet's header columns Args: file_loc (str): The file location of the spreadsheet print_cols (bool): A flag used to print the columns to the console (default is False) Returns: list: a list of strings representing the header columns \"\"\" reStructuredText Example \"\"\"Gets and prints the spreadsheet's header columns :param file_loc: The file location of the spreadsheet :type file_loc: str :param print_cols: A flag used to print the columns to the console (default is False) :type print_cols: bool :returns: a list of strings representing the header columns :rtype: list \"\"\" NumPy/SciPy Docstrings Example \"\"\"Gets and prints the spreadsheet's header columns Parameters ---------- file_loc : str The file location of the spreadsheet print_cols : bool, optional A flag used to print the columns to the console (default is False) Returns ------- list a list of strings representing the header columns \"\"\" Epytext Example \"\"\"Gets and prints the spreadsheet's header columns @type file_loc: str @param file_loc: The file location of the spreadsheet @type print_cols: bool @param print_cols: A flag used to print the columns to the console (default is False) @rtype: list @returns: a list of strings representing the header columns \"\"\"","title":"Docstrings"},{"location":"documentation/documenting/#documentar-mediante-docstrings","text":"Ahora que hemos aprendido a comentar, profundicemos en la documentaci\u00f3n de una base de c\u00f3digo Python. En esta secci\u00f3n, aprender\u00e1 acerca de las docstrings y c\u00f3mo usarlas para la documentaci\u00f3n. Esta secci\u00f3n se divide en las siguientes subsecciones: Docstrings Background : informaci\u00f3n b\u00e1sica sobre c\u00f3mo funcionan los docstrings internamente en Python Docstring Types : los distintos \"tipos\" de docstrings (funci\u00f3n, clase, m\u00e9todo de clase, m\u00f3dulo, paquete y secuencia de comandos) Docstring Formats : los diferentes \"formatos\" de docstrings (Google, NumPy / SciPy, reStructuredText y Epytext)","title":"Documentar mediante Docstrings"},{"location":"documentation/documenting/#docstrings-background","text":"La documentaci\u00f3n de su c\u00f3digo Python se centra en docstrings. Estas son strings integradas que, cuando se configuran correctamente, pueden ayudar a sus usuarios y a usted mismo con la documentaci\u00f3n de su proyecto. Junto con los docstrings, Python tambi\u00e9n tiene la funci\u00f3n incorporada help() que imprime el docstrings de los objetos en la consola. A continuaci\u00f3n, se muestra un ejemplo r\u00e1pido: >>> help(str) Help on class str in module builtins: class str(object) | str(object='') -> str | str(bytes_or_buffer[, encoding[, errors]]) -> str | | Create a new string object from the given object. If encoding or | errors are specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) | or repr(object). | encoding defaults to sys.getdefaultencoding(). | errors defaults to 'strict'. # Truncated for readability \u00bfC\u00f3mo se genera esta salida? Dado que todo en Python es un objeto, puede examinar el directorio del objeto usando el comando dir() . Hag\u00e1moslo y veamos qu\u00e9 encontramos: >>> dir(str) ['__add__', ..., '__doc__', ..., 'zfill'] # Truncated for readability Dentro de la salida de ese directorio, hay una propiedad interesante, __doc__ . Si examina esa propiedad, descubrir\u00e1 esto: >>> print(str.__doc__) str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors are specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'. \u00a1Voil\u00e0! Descubri\u00f3 d\u00f3nde se almacenan las docstrings dentro del objeto. Esto significa que puede manipular directamente esa propiedad. Sin embargo, existen restricciones para las incorporaciones: >>> str.__doc__ = \"I'm a little string doc! Short and stout; here is my input and print me for my out\" Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't set attributes of built-in/extension type 'str' Se puede manipular cualquier otro objeto personalizado: def say_hello(name): print(f\"Hello {name}, is it me you're looking for?\") say_hello.__doc__ = \"A simple function that says hello... Richie style\" >>> help(say_hello) Help on function say_hello in module __main__: say_hello(name) A simple function that says hello... Richie style Python tiene una caracter\u00edstica m\u00e1s que simplifica la creaci\u00f3n de docstrings. En lugar de manipular directamente la propiedad __doc__ , la ubicaci\u00f3n estrat\u00e9gica del ddocstrings directamente debajo del objeto establecer\u00e1 autom\u00e1ticamente el valor __doc__ . Esto es lo que sucede con el mismo ejemplo anterior: def say_hello(name): \"\"\"A simple function that says hello... Richie style\"\"\" print(f\"Hello {name}, is it me you're looking for?\") >>> help(say_hello) Help on function say_hello in module __main__: say_hello(name) A simple function that says hello... Richie style \u00a1Ah\u00ed tienes! Ahora comprende el trasfondo de las docstrings. Ha llegado el momento de conocer los diferentes tipos de docstrings y la informaci\u00f3n que deben contener.","title":"Docstrings Background"},{"location":"documentation/documenting/#docstring-types","text":"Las convenciones de strings de documentos se describen en PEP 257 . Su prop\u00f3sito es proporcionar a los usuarios una breve descripci\u00f3n general del objeto. Deben mantenerse lo suficientemente concisos para que sean f\u00e1ciles de mantener, pero igualmente elaborados para que los nuevos usuarios comprendan su prop\u00f3sito y c\u00f3mo utilizar el objeto documentado. En todos los casos, las docstrings deben usar el formato de string de comillas triples y dobles (\"\" \"). Esto debe hacerse tanto si el docstrings tiene varias l\u00edneas como si no. Como m\u00ednimo, un docstrings debe ser un resumen r\u00e1pido de lo que sea lo que est\u00e1 describiendo y debe estar contenido en una sola l\u00ednea: \"\"\"This is a quick summary line used as a description of the object.\"\"\" Los docstrings de varias l\u00edneas se utilizan para desarrollar m\u00e1s el objeto m\u00e1s all\u00e1 del resumen. Todas los docstrings de varias l\u00edneas tienen las siguientes partes: Una l\u00ednea de resumen de una l\u00ednea Una l\u00ednea en blanco que precede al resumen Cualquier elaboraci\u00f3n adicional para el docstrings Otra linea en blanco \"\"\"This is the summary line This is the further elaboration of the docstring. Within this section, you can elaborate further on details as appropriate for the situation. Notice that the summary and the elaboration is separated by a blank new line. \"\"\" # Notice the blank line above. Code should continue on this line. Todas las docstrings deben tener la misma longitud m\u00e1xima de caracteres que los comentarios (72 caracteres). Las docstrings se pueden dividir en tres categor\u00edas principales: Class Docstrings : Clase y m\u00e9todos de clase Package and Module Docstrings : paquete, m\u00f3dulos y funciones Script Docstrings : Script y funciones","title":"Docstring Types"},{"location":"documentation/documenting/#class-docstrings","text":"Las docstrings de clase se crean para la propia clase, as\u00ed como para cualquier m\u00e9todo de clase. Los docstrings se colocan inmediatamente despu\u00e9s de la clase o m\u00e9todo de clase con sangr\u00eda de un nivel: class SimpleClass: \"\"\"Class docstrings go here.\"\"\" def say_hello(self, name: str): \"\"\"Class method docstrings go here.\"\"\" print(f'Hello {name}') Los docstrings de la clase deben contener la siguiente informaci\u00f3n: Un breve resumen de su prop\u00f3sito y comportamiento. Cualquier m\u00e9todo p\u00fablico, junto con una breve descripci\u00f3n. Cualquier propiedad de clase (atributos) Cualquier cosa relacionada con la interfaz para subclases, si la clase est\u00e1 destinada a ser subclasificada. Los par\u00e1metros del constructor de la clase deben documentarse dentro del docstrings del m\u00e9todo de clase __init__ . Los m\u00e9todos individuales deben documentarse utilizando sus docstrings individuales. Los docstrings del m\u00e9todo de clase deben contener lo siguiente: Una breve descripci\u00f3n de qu\u00e9 es el m\u00e9todo y para qu\u00e9 se utiliza. Cualquier argumento (obligatorio y opcional) que se pase, incluidos los argumentos de palabras clave. Etiquete los argumentos que se consideren opcionales o que tengan un valor predeterminado Cualquier efecto secundario que se produzca al ejecutar el m\u00e9todo. Cualquier excepci\u00f3n que se plantee Cualquier restricci\u00f3n sobre cu\u00e1ndo se puede llamar al m\u00e9todo Tomemos un ejemplo simple de una clase de datos que representa un animal. Esta clase contendr\u00e1 algunas propiedades de clase, propiedades de instancia, un __init__ y un m\u00e9todo de instancia \u00fanico: class Animal: \"\"\" A class used to represent an Animal ... Attributes ---------- says_str : str a formatted string to print out what the animal says name : str the name of the animal sound : str the sound that the animal makes num_legs : int the number of legs the animal has (default 4) Methods ------- says(sound=None) Prints the animals name and what sound it makes \"\"\" says_str = \"A {name} says {sound}\" def __init__(self, name, sound, num_legs=4): \"\"\" Parameters ---------- name : str The name of the animal sound : str The sound the animal makes num_legs : int, optional The number of legs the animal (default is 4) \"\"\" self.name = name self.sound = sound self.num_legs = num_legs def says(self, sound=None): \"\"\"Prints what the animals name is and what sound it makes. If the argument `sound` isn't passed in, the default Animal sound is used. Parameters ---------- sound : str, optional The sound the animal makes (default is None) Raises ------ NotImplementedError If no sound is set for the animal or passed in as a parameter. \"\"\" if self.sound is None and sound is None: raise NotImplementedError(\"Silent Animals are not supported!\") out_sound = self.sound if sound is None else sound print(self.says_str.format(name=self.name, sound=out_sound))","title":"Class Docstrings"},{"location":"documentation/documenting/#package-and-module-docstrings","text":"Los docstrings del paquete deben colocarse en la parte superior del archivo __init__.py del paquete. Este docstrings debe enumerar los m\u00f3dulos y subpaquetes que exporta el paquete. Las docstrings del m\u00f3dulo son similares a las docstrings de la clase. En lugar de documentar las clases y los m\u00e9todos de clase, ahora es el m\u00f3dulo y las funciones que se encuentran dentro. Los docstrings del m\u00f3dulo se colocan en la parte superior del archivo incluso antes de cualquier importaci\u00f3n. Los docstrings del m\u00f3dulo deben incluir lo siguiente: Una breve descripci\u00f3n del m\u00f3dulo y su prop\u00f3sito. Una lista de las clases, excepciones, funciones y cualquier otro objeto exportado por el m\u00f3dulo. El docstrings de una funci\u00f3n de m\u00f3dulo debe incluir los mismos elementos que un m\u00e9todo de clase: Una breve descripci\u00f3n de qu\u00e9 es la funci\u00f3n y para qu\u00e9 se utiliza. Cualquier argumento (obligatorio y opcional) que se pase, incluidos los argumentos de palabras clave. Etiquete los argumentos que se consideren opcionales Cualquier efecto secundario que se produzca al ejecutar la funci\u00f3n. Cualquier excepci\u00f3n que se plantee Cualquier restricci\u00f3n sobre cu\u00e1ndo se puede llamar a la funci\u00f3n","title":"Package and Module Docstrings"},{"location":"documentation/documenting/#script-docstrings","text":"Los scripts se consideran ejecutables de un solo archivo que se ejecutan desde la consola. Las docstrings para scripts se colocan en la parte superior del archivo y deben estar lo suficientemente bien documentadas para que los usuarios puedan tener una comprensi\u00f3n suficiente de c\u00f3mo usar el script. Deber\u00eda ser utilizable para su mensaje de \"uso\", cuando el usuario pasa incorrectamente un par\u00e1metro o usa la opci\u00f3n -h. Si usa argparse, puede omitir la documentaci\u00f3n espec\u00edfica del par\u00e1metro, suponiendo que se haya documentado correctamente en el par\u00e1metro de ayuda de la funci\u00f3n argparser.parser.add_argument. Se recomienda utilizar __doc__ para el par\u00e1metro de descripci\u00f3n dentro del constructor de argparse.ArgumentParser . Consulte nuestro tutorial sobre bibliotecas de an\u00e1lisis de l\u00ednea de comandos para obtener m\u00e1s detalles sobre c\u00f3mo usar argparse y otros analizadores de l\u00ednea de comando comunes. Finalmente, cualquier importaci\u00f3n personalizada o de terceros debe incluirse dentro de las docstrings para permitir a los usuarios saber qu\u00e9 paquetes pueden ser necesarios para ejecutar el script. A continuaci\u00f3n, se muestra un ejemplo de una secuencia de comandos que se usa para imprimir simplemente los encabezados de columna de una hoja de c\u00e1lculo: \"\"\"Spreadsheet Column Printer This script allows the user to print to the console all columns in the spreadsheet. It is assumed that the first row of the spreadsheet is the location of the columns. This tool accepts comma separated value files (.csv) as well as excel (.xls, .xlsx) files. This script requires that `pandas` be installed within the Python environment you are running this script in. This file can also be imported as a module and contains the following functions: * get_spreadsheet_cols - returns the column headers of the file * main - the main function of the script \"\"\" import argparse import pandas as pd def get_spreadsheet_cols(file_loc, print_cols=False): \"\"\"Gets and prints the spreadsheet's header columns Parameters ---------- file_loc : str The file location of the spreadsheet print_cols : bool, optional A flag used to print the columns to the console (default is False) Returns ------- list a list of strings used that are the header columns \"\"\" file_data = pd.read_excel(file_loc) col_headers = list(file_data.columns.values) if print_cols: print(\"\\n\".join(col_headers)) return col_headers def main(): parser = argparse.ArgumentParser(description=__doc__) parser.add_argument( 'input_file', type=str, help=\"The spreadsheet file to pring the columns of\" ) args = parser.parse_args() get_spreadsheet_cols(args.input_file, print_cols=True) if __name__ == \"__main__\": main()","title":"Script Docstrings"},{"location":"documentation/documenting/#docstring-formats","text":"Es posible que haya notado que, a lo largo de los ejemplos proporcionados en este tutorial, ha habido un formato espec\u00edfico con elementos comunes: argumentos, devoluciones y atributos. Hay formatos de docstrings espec\u00edficos que se pueden usar para ayudar a los usuarios y a los analizadores de docstrings a tener un formato familiar y conocido. El formato utilizado en los ejemplos de este tutorial son docstrings de estilo NumPy / SciPy. Algunos de los formatos m\u00e1s habituales son los siguientes: Formatting Type Description Supported by Sphynx Formal Specification Google docstrings Google\u2019s recommended form of documentation Yes No reStructuredText Official Python documentation standard; Not beginner friendly but feature rich Yes Yes NumPy/SciPy docstrings NumPy\u2019s combination of reStructuredText and Google Docstrings Yes Yes Epytext A Python adaptation of Epydoc; Great for Java developers Not officially Yes La selecci\u00f3n del formato de docstrings depende de usted, pero debe seguir con el mismo formato en todo su documento / proyecto. Los siguientes son ejemplos de cada tipo para darle una idea de c\u00f3mo se ve cada formato de documentaci\u00f3n. Google Docstrings Example \"\"\"Gets and prints the spreadsheet's header columns Args: file_loc (str): The file location of the spreadsheet print_cols (bool): A flag used to print the columns to the console (default is False) Returns: list: a list of strings representing the header columns \"\"\" reStructuredText Example \"\"\"Gets and prints the spreadsheet's header columns :param file_loc: The file location of the spreadsheet :type file_loc: str :param print_cols: A flag used to print the columns to the console (default is False) :type print_cols: bool :returns: a list of strings representing the header columns :rtype: list \"\"\" NumPy/SciPy Docstrings Example \"\"\"Gets and prints the spreadsheet's header columns Parameters ---------- file_loc : str The file location of the spreadsheet print_cols : bool, optional A flag used to print the columns to the console (default is False) Returns ------- list a list of strings representing the header columns \"\"\" Epytext Example \"\"\"Gets and prints the spreadsheet's header columns @type file_loc: str @param file_loc: The file location of the spreadsheet @type print_cols: bool @param print_cols: A flag used to print the columns to the console (default is False) @rtype: list @returns: a list of strings representing the header columns \"\"\"","title":"Docstring Formats"},{"location":"documentation/intro/","text":"Introducci\u00f3n Bienvenido a su gu\u00eda completa para documentar el c\u00f3digo Python. Si est\u00e1 leyendo este tutorial, ya sabe la importancia de documentar su c\u00f3digo. Pero si no, perm\u00edtanme citar algo que Guido me mencion\u00f3 en una PyCon reciente: Code is more often read than written \u2014 Guido van Rossum Cuando escribe c\u00f3digo, lo escribe para dos p\u00fablicos principales: sus usuarios y sus desarrolladores (incluido usted mismo). Ambos p\u00fablicos son igualmente importantes. Si eres como yo, probablemente hayas abierto bases de c\u00f3digo antiguas y te hayas preguntado: \"\u00bfEn qu\u00e9 diablos estaba pensando?\" Si tiene problemas para leer su propio c\u00f3digo, imagine lo que est\u00e1n experimentando sus usuarios u otros desarrolladores cuando intentan utilizar o contribuir a su c\u00f3digo. Por el contrario, estoy seguro de que te has encontrado con una situaci\u00f3n en la que quer\u00edas hacer algo en Python y encontraste lo que parece una gran biblioteca que puede hacer el trabajo. Sin embargo, cuando comienza a usar la biblioteca, busca ejemplos, rese\u00f1as o incluso documentaci\u00f3n oficial sobre c\u00f3mo hacer algo espec\u00edfico y no puede encontrar la soluci\u00f3n de inmediato. Despu\u00e9s de buscar, se da cuenta de que falta la documentaci\u00f3n o, lo que es peor, falta por completo. Este es un sentimiento frustrante que lo disuade de usar la biblioteca, sin importar cu\u00e1n bueno o eficiente sea el c\u00f3digo. Daniele Procida resumi\u00f3 mejor esta situaci\u00f3n: It doesn\u2019t matter how good your software is, because if the documentation is not good enough, people will not use it \u2014 Daniele Procida En esta gu\u00eda, aprender\u00e1 desde cero c\u00f3mo documentar correctamente su c\u00f3digo Python, desde los scripts m\u00e1s peque\u00f1os hasta los proyectos Python m\u00e1s grandes, para ayudar a evitar que sus usuarios se sientan demasiado frustrados para usar o contribuir a su proyecto.","title":"Introducci\u00f3n"},{"location":"documentation/intro/#introduccion","text":"Bienvenido a su gu\u00eda completa para documentar el c\u00f3digo Python. Si est\u00e1 leyendo este tutorial, ya sabe la importancia de documentar su c\u00f3digo. Pero si no, perm\u00edtanme citar algo que Guido me mencion\u00f3 en una PyCon reciente: Code is more often read than written \u2014 Guido van Rossum Cuando escribe c\u00f3digo, lo escribe para dos p\u00fablicos principales: sus usuarios y sus desarrolladores (incluido usted mismo). Ambos p\u00fablicos son igualmente importantes. Si eres como yo, probablemente hayas abierto bases de c\u00f3digo antiguas y te hayas preguntado: \"\u00bfEn qu\u00e9 diablos estaba pensando?\" Si tiene problemas para leer su propio c\u00f3digo, imagine lo que est\u00e1n experimentando sus usuarios u otros desarrolladores cuando intentan utilizar o contribuir a su c\u00f3digo. Por el contrario, estoy seguro de que te has encontrado con una situaci\u00f3n en la que quer\u00edas hacer algo en Python y encontraste lo que parece una gran biblioteca que puede hacer el trabajo. Sin embargo, cuando comienza a usar la biblioteca, busca ejemplos, rese\u00f1as o incluso documentaci\u00f3n oficial sobre c\u00f3mo hacer algo espec\u00edfico y no puede encontrar la soluci\u00f3n de inmediato. Despu\u00e9s de buscar, se da cuenta de que falta la documentaci\u00f3n o, lo que es peor, falta por completo. Este es un sentimiento frustrante que lo disuade de usar la biblioteca, sin importar cu\u00e1n bueno o eficiente sea el c\u00f3digo. Daniele Procida resumi\u00f3 mejor esta situaci\u00f3n: It doesn\u2019t matter how good your software is, because if the documentation is not good enough, people will not use it \u2014 Daniele Procida En esta gu\u00eda, aprender\u00e1 desde cero c\u00f3mo documentar correctamente su c\u00f3digo Python, desde los scripts m\u00e1s peque\u00f1os hasta los proyectos Python m\u00e1s grandes, para ayudar a evitar que sus usuarios se sientan demasiado frustrados para usar o contribuir a su proyecto.","title":"Introducci\u00f3n"},{"location":"documentation/project/","text":"Documentar en Python Los proyectos de Python vienen en todo tipo de formas, tama\u00f1os y prop\u00f3sitos. La forma en que documente su proyecto debe adaptarse a su situaci\u00f3n espec\u00edfica. Ten en cuenta qui\u00e9nes ser\u00e1n los usuarios de tu proyecto y ad\u00e1ptate a sus necesidades. Dependiendo del tipo de proyecto, se recomiendan ciertos aspectos de la documentaci\u00f3n. El dise\u00f1o general del proyecto y su documentaci\u00f3n debe ser el siguiente: project_root/ \u2502 \u251c\u2500\u2500 project/ # Project source code \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 README \u251c\u2500\u2500 HOW_TO_CONTRIBUTE \u251c\u2500\u2500 CODE_OF_CONDUCT \u251c\u2500\u2500 examples.py Los proyectos se pueden subdividir generalmente en tres tipos principales: privados, compartidos y p\u00fablicos / de c\u00f3digo abierto. Proyectos privados Los proyectos privados son proyectos destinados solo para uso personal y, por lo general, no se comparten con otros usuarios o desarrolladores. La documentaci\u00f3n puede ser bastante liviana en este tipo de proyectos. Hay algunas partes recomendadas para agregar seg\u00fan sea necesario: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para la instalaci\u00f3n u operaci\u00f3n del proyecto. examples.py : un archivo de secuencia de comandos de Python que brinda ejemplos simples de c\u00f3mo usar el proyecto. Recuerde, aunque los proyectos privados est\u00e1n destinados a usted personalmente, tambi\u00e9n se le considera un usuario. Piense en cualquier cosa que pueda resultarle confusa en el futuro y aseg\u00farese de capturarla en comentarios, strings de documentos o el archivo Readme.md . Proyectos Compartidos Los proyectos compartidos son proyectos en los que colaboras con algunas otras personas en el desarrollo y / o uso del proyecto. El \"cliente\" o usuario del proyecto sigue siendo usted mismo y los pocos que utilizan el proyecto tambi\u00e9n. La documentaci\u00f3n debe ser un poco m\u00e1s rigurosa de lo necesario para un proyecto privado, principalmente para ayudar a incorporar nuevos miembros al proyecto o alertar a los contribuyentes / usuarios de nuevos cambios en el proyecto. Algunas de las partes recomendadas para agregar al proyecto son las siguientes: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para instalar u operar el proyecto. Adem\u00e1s, agregue los cambios importantes desde la versi\u00f3n anterior. examples.py : un archivo de secuencia de comandos de Python que brinda ejemplos simples de c\u00f3mo usar los proyectos. How to Contribute : esto debe incluir c\u00f3mo los nuevos contribuyentes al proyecto pueden comenzar a contribuir. Proyectos p\u00fablicos y de c\u00f3digo abierto Los proyectos p\u00fablicos y de c\u00f3digo abierto son proyectos que est\u00e1n destinados a ser compartidos con un gran grupo de usuarios y pueden involucrar a grandes equipos de desarrollo. Estos proyectos deben tener una prioridad tan alta en la documentaci\u00f3n del proyecto como el desarrollo real del proyecto en s\u00ed. Algunas de las partes recomendadas para agregar al proyecto son las siguientes: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para instalar u operar los proyectos. Adem\u00e1s, agregue los cambios importantes desde la versi\u00f3n anterior. Finalmente, agregue enlaces a m\u00e1s documentaci\u00f3n, informes de errores y cualquier otra informaci\u00f3n importante para el proyecto. Dan Bader ha elaborado un gran tutorial sobre todo lo que deber\u00eda incluirse en su archivo L\u00e9ame. How to Contribute : esto debe incluir c\u00f3mo pueden ayudar los nuevos contribuyentes al proyecto. Esto incluye desarrollar nuevas funciones, solucionar problemas conocidos, agregar documentaci\u00f3n, agregar nuevas pruebas o informar problemas. Code of Conduct : define c\u00f3mo los dem\u00e1s colaboradores deben tratarse entre s\u00ed al desarrollar o utilizar su software. Esto tambi\u00e9n indica lo que suceder\u00e1 si este c\u00f3digo se rompe. Si est\u00e1 utilizando Github, se puede generar una plantilla de C\u00f3digo de conducta con la redacci\u00f3n recomendada. Especialmente para proyectos de c\u00f3digo abierto, considere agregar esto. License : un archivo de texto sin formato que describe la licencia que est\u00e1 usando su proyecto. Especialmente para proyectos de c\u00f3digo abierto, considere agregar esto. docs : una carpeta que contiene m\u00e1s documentaci\u00f3n. La siguiente secci\u00f3n describe con m\u00e1s detalle qu\u00e9 se debe incluir y c\u00f3mo organizar el contenido de esta carpeta. Las cuatro secciones principales de la carpeta de documentos Daniele Procida dio una maravillosa charla de PyCon 2017 y una publicaci\u00f3n de blog posterior sobre la documentaci\u00f3n de proyectos de Python. \u00c9l menciona que todos los proyectos deben tener las siguientes cuatro secciones principales para ayudarlo a enfocar su trabajo: Tutorials : lecciones que llevan al lector de la mano a trav\u00e9s de una serie de pasos para completar un proyecto (o ejercicio significativo). Orientado al aprendizaje del usuario. How-To Guides : gu\u00edas que llevan al lector a trav\u00e9s de los pasos necesarios para resolver un problema com\u00fan (recetas orientadas a problemas). References : Explicaciones que aclaran e iluminan un tema en particular. Orientado a la comprensi\u00f3n. Explanations : descripciones t\u00e9cnicas de la maquinaria y c\u00f3mo operarla (clases clave, funciones, API, etc.). Piense en el art\u00edculo de la Enciclopedia. La siguiente tabla muestra c\u00f3mo todas estas secciones se relacionan entre s\u00ed, as\u00ed como su prop\u00f3sito general: Most Useful When We\u2019re Studying Most Useful When We\u2019re Coding Practical Step Tutorials How-To Guides Theoretical Knowledge Explanation Reference Al final, desea asegurarse de que sus usuarios tengan acceso a las respuestas a cualquier pregunta que puedan tener. Al organizar su proyecto de esta manera, podr\u00e1 responder esas preguntas f\u00e1cilmente y en un formato en el que podr\u00e1n navegar r\u00e1pidamente. Herramientas y recursos de documentaci\u00f3n Documentar su c\u00f3digo, especialmente los proyectos grandes, puede resultar abrumador. Afortunadamente, existen algunas herramientas y referencias para comenzar: Tool Description Sphinx A collection of tools to auto-generate documentation in multiple formats Epydoc A tool for generating API documentation for Python modules based on their docstrings Read The Docs Automatic building, versioning, and hosting of your docs for you Doxygen A tool for generating documentation that supports Python as well as multiple other languages MkDocs A static site generator to help build project documentation using the Markdown language pycco A \u201cquick and dirty\u201d documentation generator that displays code and documentation side by side. Check out our tutorial on how to use it for more info. Junto con estas herramientas, hay algunos tutoriales, videos y art\u00edculos adicionales que pueden ser \u00fatiles cuando est\u00e1 documentando su proyecto: Carol Willing - Esfinge pr\u00e1ctica - PyCon 2018 Daniele Procida - Desarrollo basado en documentaci\u00f3n - Lecciones del proyecto Django - PyCon 2016 Eric Holscher - Documentar su proyecto con Sphinx y leer los documentos - PyCon 2016 Titus Brown, Luiz Irber - Creaci\u00f3n, construcci\u00f3n, prueba y documentaci\u00f3n de un proyecto de Python: un C\u00d3MO pr\u00e1ctico - PyCon 2016 Documentaci\u00f3n oficial de reStructuredText Introducci\u00f3n al texto reestructurado de Sphinx A veces, la mejor forma de aprender es imitar a los dem\u00e1s. Aqu\u00ed hay algunos ejemplos excelentes de proyectos que usan bien la documentaci\u00f3n: Django : Docs ( Source ) Requests : Docs ( Source ) Click : Docs ( Source ) Pandas : Docs ( Source ) \u00bfD\u00f3nde empiezo? La documentaci\u00f3n de los proyectos tiene una progresi\u00f3n sencilla: Sin documentaci\u00f3n Alguna documentaci\u00f3n Documentaci\u00f3n completa Buena documentacion Gran documentaci\u00f3n Si no sabe a d\u00f3nde ir a continuaci\u00f3n con su documentaci\u00f3n, mire d\u00f3nde se encuentra su proyecto ahora en relaci\u00f3n con la progresi\u00f3n anterior. \u00bfTienes alguna documentaci\u00f3n? Si no es as\u00ed, empiece por ah\u00ed. Si tiene algo de documentaci\u00f3n pero le faltan algunos de los archivos clave del proyecto, comience agregando esos. Al final, no se desanime ni se abrume por la cantidad de trabajo requerido para documentar el c\u00f3digo. Una vez que comience a documentar su c\u00f3digo, ser\u00e1 m\u00e1s f\u00e1cil continuar. No dude en comentar si tiene preguntas o comun\u00edquese con el equipo de Real Python en las redes sociales y lo ayudaremos. Referencias Documenting Python Documenting Python Code: A Complete Guide","title":"Documentar en Python"},{"location":"documentation/project/#documentar-en-python","text":"Los proyectos de Python vienen en todo tipo de formas, tama\u00f1os y prop\u00f3sitos. La forma en que documente su proyecto debe adaptarse a su situaci\u00f3n espec\u00edfica. Ten en cuenta qui\u00e9nes ser\u00e1n los usuarios de tu proyecto y ad\u00e1ptate a sus necesidades. Dependiendo del tipo de proyecto, se recomiendan ciertos aspectos de la documentaci\u00f3n. El dise\u00f1o general del proyecto y su documentaci\u00f3n debe ser el siguiente: project_root/ \u2502 \u251c\u2500\u2500 project/ # Project source code \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 README \u251c\u2500\u2500 HOW_TO_CONTRIBUTE \u251c\u2500\u2500 CODE_OF_CONDUCT \u251c\u2500\u2500 examples.py Los proyectos se pueden subdividir generalmente en tres tipos principales: privados, compartidos y p\u00fablicos / de c\u00f3digo abierto.","title":"Documentar en Python"},{"location":"documentation/project/#proyectos-privados","text":"Los proyectos privados son proyectos destinados solo para uso personal y, por lo general, no se comparten con otros usuarios o desarrolladores. La documentaci\u00f3n puede ser bastante liviana en este tipo de proyectos. Hay algunas partes recomendadas para agregar seg\u00fan sea necesario: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para la instalaci\u00f3n u operaci\u00f3n del proyecto. examples.py : un archivo de secuencia de comandos de Python que brinda ejemplos simples de c\u00f3mo usar el proyecto. Recuerde, aunque los proyectos privados est\u00e1n destinados a usted personalmente, tambi\u00e9n se le considera un usuario. Piense en cualquier cosa que pueda resultarle confusa en el futuro y aseg\u00farese de capturarla en comentarios, strings de documentos o el archivo Readme.md .","title":"Proyectos privados"},{"location":"documentation/project/#proyectos-compartidos","text":"Los proyectos compartidos son proyectos en los que colaboras con algunas otras personas en el desarrollo y / o uso del proyecto. El \"cliente\" o usuario del proyecto sigue siendo usted mismo y los pocos que utilizan el proyecto tambi\u00e9n. La documentaci\u00f3n debe ser un poco m\u00e1s rigurosa de lo necesario para un proyecto privado, principalmente para ayudar a incorporar nuevos miembros al proyecto o alertar a los contribuyentes / usuarios de nuevos cambios en el proyecto. Algunas de las partes recomendadas para agregar al proyecto son las siguientes: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para instalar u operar el proyecto. Adem\u00e1s, agregue los cambios importantes desde la versi\u00f3n anterior. examples.py : un archivo de secuencia de comandos de Python que brinda ejemplos simples de c\u00f3mo usar los proyectos. How to Contribute : esto debe incluir c\u00f3mo los nuevos contribuyentes al proyecto pueden comenzar a contribuir.","title":"Proyectos Compartidos"},{"location":"documentation/project/#proyectos-publicos-y-de-codigo-abierto","text":"Los proyectos p\u00fablicos y de c\u00f3digo abierto son proyectos que est\u00e1n destinados a ser compartidos con un gran grupo de usuarios y pueden involucrar a grandes equipos de desarrollo. Estos proyectos deben tener una prioridad tan alta en la documentaci\u00f3n del proyecto como el desarrollo real del proyecto en s\u00ed. Algunas de las partes recomendadas para agregar al proyecto son las siguientes: Readme.md : un breve resumen del proyecto y su prop\u00f3sito. Incluya cualquier requisito especial para instalar u operar los proyectos. Adem\u00e1s, agregue los cambios importantes desde la versi\u00f3n anterior. Finalmente, agregue enlaces a m\u00e1s documentaci\u00f3n, informes de errores y cualquier otra informaci\u00f3n importante para el proyecto. Dan Bader ha elaborado un gran tutorial sobre todo lo que deber\u00eda incluirse en su archivo L\u00e9ame. How to Contribute : esto debe incluir c\u00f3mo pueden ayudar los nuevos contribuyentes al proyecto. Esto incluye desarrollar nuevas funciones, solucionar problemas conocidos, agregar documentaci\u00f3n, agregar nuevas pruebas o informar problemas. Code of Conduct : define c\u00f3mo los dem\u00e1s colaboradores deben tratarse entre s\u00ed al desarrollar o utilizar su software. Esto tambi\u00e9n indica lo que suceder\u00e1 si este c\u00f3digo se rompe. Si est\u00e1 utilizando Github, se puede generar una plantilla de C\u00f3digo de conducta con la redacci\u00f3n recomendada. Especialmente para proyectos de c\u00f3digo abierto, considere agregar esto. License : un archivo de texto sin formato que describe la licencia que est\u00e1 usando su proyecto. Especialmente para proyectos de c\u00f3digo abierto, considere agregar esto. docs : una carpeta que contiene m\u00e1s documentaci\u00f3n. La siguiente secci\u00f3n describe con m\u00e1s detalle qu\u00e9 se debe incluir y c\u00f3mo organizar el contenido de esta carpeta.","title":"Proyectos p\u00fablicos y de c\u00f3digo abierto"},{"location":"documentation/project/#las-cuatro-secciones-principales-de-la-carpeta-de-documentos","text":"Daniele Procida dio una maravillosa charla de PyCon 2017 y una publicaci\u00f3n de blog posterior sobre la documentaci\u00f3n de proyectos de Python. \u00c9l menciona que todos los proyectos deben tener las siguientes cuatro secciones principales para ayudarlo a enfocar su trabajo: Tutorials : lecciones que llevan al lector de la mano a trav\u00e9s de una serie de pasos para completar un proyecto (o ejercicio significativo). Orientado al aprendizaje del usuario. How-To Guides : gu\u00edas que llevan al lector a trav\u00e9s de los pasos necesarios para resolver un problema com\u00fan (recetas orientadas a problemas). References : Explicaciones que aclaran e iluminan un tema en particular. Orientado a la comprensi\u00f3n. Explanations : descripciones t\u00e9cnicas de la maquinaria y c\u00f3mo operarla (clases clave, funciones, API, etc.). Piense en el art\u00edculo de la Enciclopedia. La siguiente tabla muestra c\u00f3mo todas estas secciones se relacionan entre s\u00ed, as\u00ed como su prop\u00f3sito general: Most Useful When We\u2019re Studying Most Useful When We\u2019re Coding Practical Step Tutorials How-To Guides Theoretical Knowledge Explanation Reference Al final, desea asegurarse de que sus usuarios tengan acceso a las respuestas a cualquier pregunta que puedan tener. Al organizar su proyecto de esta manera, podr\u00e1 responder esas preguntas f\u00e1cilmente y en un formato en el que podr\u00e1n navegar r\u00e1pidamente.","title":"Las cuatro secciones principales de la carpeta de documentos"},{"location":"documentation/project/#herramientas-y-recursos-de-documentacion","text":"Documentar su c\u00f3digo, especialmente los proyectos grandes, puede resultar abrumador. Afortunadamente, existen algunas herramientas y referencias para comenzar: Tool Description Sphinx A collection of tools to auto-generate documentation in multiple formats Epydoc A tool for generating API documentation for Python modules based on their docstrings Read The Docs Automatic building, versioning, and hosting of your docs for you Doxygen A tool for generating documentation that supports Python as well as multiple other languages MkDocs A static site generator to help build project documentation using the Markdown language pycco A \u201cquick and dirty\u201d documentation generator that displays code and documentation side by side. Check out our tutorial on how to use it for more info. Junto con estas herramientas, hay algunos tutoriales, videos y art\u00edculos adicionales que pueden ser \u00fatiles cuando est\u00e1 documentando su proyecto: Carol Willing - Esfinge pr\u00e1ctica - PyCon 2018 Daniele Procida - Desarrollo basado en documentaci\u00f3n - Lecciones del proyecto Django - PyCon 2016 Eric Holscher - Documentar su proyecto con Sphinx y leer los documentos - PyCon 2016 Titus Brown, Luiz Irber - Creaci\u00f3n, construcci\u00f3n, prueba y documentaci\u00f3n de un proyecto de Python: un C\u00d3MO pr\u00e1ctico - PyCon 2016 Documentaci\u00f3n oficial de reStructuredText Introducci\u00f3n al texto reestructurado de Sphinx A veces, la mejor forma de aprender es imitar a los dem\u00e1s. Aqu\u00ed hay algunos ejemplos excelentes de proyectos que usan bien la documentaci\u00f3n: Django : Docs ( Source ) Requests : Docs ( Source ) Click : Docs ( Source ) Pandas : Docs ( Source )","title":"Herramientas y recursos de documentaci\u00f3n"},{"location":"documentation/project/#donde-empiezo","text":"La documentaci\u00f3n de los proyectos tiene una progresi\u00f3n sencilla: Sin documentaci\u00f3n Alguna documentaci\u00f3n Documentaci\u00f3n completa Buena documentacion Gran documentaci\u00f3n Si no sabe a d\u00f3nde ir a continuaci\u00f3n con su documentaci\u00f3n, mire d\u00f3nde se encuentra su proyecto ahora en relaci\u00f3n con la progresi\u00f3n anterior. \u00bfTienes alguna documentaci\u00f3n? Si no es as\u00ed, empiece por ah\u00ed. Si tiene algo de documentaci\u00f3n pero le faltan algunos de los archivos clave del proyecto, comience agregando esos. Al final, no se desanime ni se abrume por la cantidad de trabajo requerido para documentar el c\u00f3digo. Una vez que comience a documentar su c\u00f3digo, ser\u00e1 m\u00e1s f\u00e1cil continuar. No dude en comentar si tiene preguntas o comun\u00edquese con el equipo de Real Python en las redes sociales y lo ayudaremos.","title":"\u00bfD\u00f3nde empiezo?"},{"location":"documentation/project/#referencias","text":"Documenting Python Documenting Python Code: A Complete Guide","title":"Referencias"},{"location":"documentation/sphinx/","text":"Sphinx Introducci\u00f3n Sphinx es una herramienta que facilita la creaci\u00f3n de documentaci\u00f3n inteligente y hermosa, escrita por Georg Brandl y con licencia BSD. Fue creado originalmente para la documentaci\u00f3n de Python y tiene excelentes facilidades para la documentaci\u00f3n de proyectos de software en una variedad de lenguajes. \u00a1Por supuesto, este sitio tambi\u00e9n se crea a partir de fuentes reStructuredText utilizando Sphinx! Deben destacarse las siguientes caracter\u00edsticas: Formatos de salida : HTML (incluida la Ayuda HTML de Windows), LaTeX (para versiones en PDF imprimibles), ePub, Texinfo, p\u00e1ginas de manual, texto sin formato Referencias cruzadas extensas : marcado sem\u00e1ntico y enlaces autom\u00e1ticos para funciones, clases, citas, t\u00e9rminos del glosario y piezas de informaci\u00f3n similares Estructura jer\u00e1rquica : definici\u00f3n sencilla de un \u00e1rbol de documentos, con enlaces autom\u00e1ticos a hermanos, padres e hijos \u00cdndices autom\u00e1ticos : \u00edndice general as\u00ed como \u00edndices de m\u00f3dulo espec\u00edficos del idioma Manejo de c\u00f3digo : resaltado autom\u00e1tico con el resaltador Pygments Extensiones : prueba autom\u00e1tica de fragmentos de c\u00f3digo, inclusi\u00f3n de cadenas de documentos de m\u00f3dulos de Python (documentos API) y m\u00e1s Nuevas Extensiones : m\u00e1s de 50 extensiones aportadas por los usuarios en un segundo repositorio; la mayor\u00eda de ellos instalables desde PyPI Instalaci\u00f3n La instalaci\u00f3n de Sphinx depender\u00e1 del sistema operativo que est\u00e9s utilizando. Si ya tienes instalado Python, puedes descargar e instalar Sphinx utilizando pip: $ pip install -U sphinx Creaci\u00f3n del directorio de trabajo Para crear nuestro directorio de trabajo con Sphinx mediante l\u00ednea de comando ejecutamos: $ sphinx-quickstart [options] [projectdir] Sphinx se encargar\u00e1 de crear varios archivos de configuraci\u00f3n y de directorios vac\u00edos que ser\u00e1n utilizados m\u00e1s adelante. Para ver todas las opciones de sphinx-quickstart podemos visitar la p\u00e1guina Invocation of sphinx-quickstart . Ac\u00e1 existen dos formas de crear el proyecto: Respondiendo por terminal cada unas de la opciones (nombre poryecto, autor, etc.) Setear todos las opciones por l\u00ednea de comandos. Para efectos pr\u00e1cticos, ocuparemos la segunda opci\u00f3n: # inicializar ! sphinx - quickstart \\ -- quiet \\ -- project = docs \\ -- author = faam \\ -- release = 0.1 \\ -- language = es \u001b[01mFinished: An initial directory structure has been created.\u001b[39;49;00m You should now populate your master file /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/index.rst and create other documentation source files. Use the Makefile to build the docs, like so: make builder where \"builder\" is one of the supported builders, e.g. html, latex or linkcheck. Una vez creado el proyecto, deberiamos ver algo como esto: docs | _build | _static | _templates | conf.py | index.rst | make.bat | Makefile Primer ejemplo con Sphinx Nuestro ejemplo consiste en documentar el paquete de python denominado my_project , el cual consta simplemente de un m\u00f3dulo .py (denominado main.py ). Esquema del proyecto: docs | _build | _static | _templates | conf.py | index.rst | make.bat | Makefile | my_project | __init__.py | main.py Para poder crear una correcta documentaci\u00f3n, es neceario conocer los archivos generados por Sphinx y las modificaciones a los archivos .py . Archivo conf.py El directorio de configuraci\u00f3n debe contener un archivo llamado conf.py . Este archivo (que contiene c\u00f3digo Python) se denomina \"archivo de configuraci\u00f3n de compilaci\u00f3n\" y contiene (casi) toda la configuraci\u00f3n necesaria para personalizar el comportamiento de entrada y salida de Sphinx. %% writefile docs / conf . py # Configuration file for the Sphinx documentation builder. # # This file only contains a selection of the most common options. For a full # list see the documentation: # https://www.sphinx-doc.org/en/master/usage/configuration.html # -- Path setup -------------------------------------------------------------- # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # import os import sys cwd = os . getcwd () project_root = os . path . dirname ( cwd ) sys . path . insert ( 0 , project_root ) from my_project import __version__ # noqa # -- Project information ----------------------------------------------------- project = 'my_project' copyright = '2020, faam' author = 'faam' # The full version, including alpha/beta/rc tags release = __version__ # -- General configuration --------------------------------------------------- # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = [ \"sphinx.ext.autodoc\" , # Include documentation from docstrings \"sphinxcontrib.plantuml\" , # Sphinx \"plantuml\" extension \"sphinx-pydantic\" , # Autogenerate documentation from pydantic objects in Sphinx \"sphinxcontrib.bibtex\" , # A Sphinx extension for BibTeX style citations. \"sphinx.ext.mathjax\" , # Sphinx supports math in documentation with several extensions ] # Add any paths that contain templates here, relative to this directory. templates_path = [ '_templates' ] # The language for content autogenerated by Sphinx. Refer to documentation # for a list of supported languages. # # This is also used if you do content translation via gettext catalogs. # Usually you set \"language\" from the command line for these cases. language = 'es' # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. # This pattern also affects html_static_path and html_extra_path. exclude_patterns = [ '_build' , 'Thumbs.db' , '.DS_Store' ] # -- Options for HTML output ------------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = \"sphinx_rtd_theme\" # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named \"default.css\" will overwrite the builtin \"default.css\". html_static_path = [ '_static' ] Overwriting docs/conf.py Vayamos desglosando este archivo: 1.- En Path setup se importa la versi\u00f3n de nuestro paquete my_project . # -- Path setup -------------------------------------------------------------- # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # import os import sys cwd = os . getcwd () project_root = os . path . dirname ( cwd ) sys . path . insert ( 0 , project_root ) from my_project import __version__ # noqa 2.- En Project information se pone la informaci\u00f3n del proyecto # -- Project information ----------------------------------------------------- project = 'my_project' copyright = '2020, faam' author = 'faam' # The full version, including alpha/beta/rc tags release = __version__ 3.- En General configuration se configura: extensiones : agregar extensiones en la medida que se necesite. # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = [ \"sphinx.ext.autodoc\" , # Include documentation from docstrings \"sphinxcontrib.plantuml\" , # Sphinx \"plantuml\" extension \"sphinx-pydantic\" , # Autogenerate documentation from pydantic objects in Sphinx \"sphinxcontrib.bibtex\" , # A Sphinx extension for BibTeX style citations. \"sphinx.ext.mathjax\" , # Sphinx supports math in documentation with several extensions ] idioma : especificar el idioma de la documentaci\u00f3n (en este caso espa\u00f1ol ) # This is also used if you do content translation via gettext catalogs. # Usually you set \"language\" from the command line for these cases. language = 'es' 4.- Tambi\u00e9n podemos modificar el formato de salida del HTML. # -- Options for HTML output ------------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = \"sphinx_rtd_theme\" Archivo *.rst Sphinx utiliza como source archivos tipo .rst creados con un lenguaje de marcas denominado reStructuredText (o simplemente reST). Se trata de un tipo de formato similar a markdown, pero con una serie de marcas ampliadas especialmente dise\u00f1adas para facilitar el trabajo de documentaci\u00f3n autom\u00e1tica de c\u00f3digo. reStructuredText Directives Las directivas de reStructuredText son los argumentos que ocupa reStructuredText para construir su cuerpo. Las distintas directivas se iran aprendiendo en la medida que se construyan los archivos .rst a ocupar. Algunos ejemplos: .. toctree:: .. bibliography:: .. automodule:: .. uml:: .. image:: .. autofunction:: .. autoclass:: .. pydantic:: Archivo index.rst Por defecto, se viene con el archivo index.rst , que corresponde al \u00edndice del archivo html que se genera, en \u00e9l pondremos los archivos *.rst que se quieren mostrar en la documentaci\u00f3n. %% writefile docs / index . rst .. documentation master file , created by sphinx - quickstart on Sun Sep 27 12 : 49 : 37 2020. You can adapt this file completely to your liking , but it should at least contain the root ` toctree ` directive . Welcome to my_project 's documentation! ======================================= .. toctree :: : maxdepth : 2 : caption : Contents : main references Indices and tables ================== * : ref : ` genindex ` * : ref : ` modindex ` * : ref : ` search ` Overwriting docs/index.rst 1.- Se agrega el nombre del t\u00edtulo de la docuemntaci\u00f3n Welcome to my_project's documentation! ======================================= 2.- Se agregan los archivos main y reference : main references Esta forma de referenciar, hace menci\u00f3n a los archivos: main.rst : informaci\u00f3n del m\u00f3dulo main.py refrences.rst : informaci\u00f3n de las bibiliografias ocupadas. Archivo refrences.rst El archivo refrences.rst mostrar\u00e1 en la docuemntaci\u00f3n toda la bibliograf\u00eda ocupada. Se trabaja una estructura similar a la de Latex , creando un archivo references.bib con todas las referencias. %% writefile docs / references . bib @article { dijkstra2017 , author = { Dijkstra , Arjan and Roodbergen , Kees Jan }, year = { 2017 }, month = { 04 }, pages = {}, title = { Exact route - length formulas and a storage location assignment heuristic for picker - to - parts warehouses }, volume = { 102 }, journal = { Transportation Research Part E Logistics and Transportation Review }, doi = { 10.1016 / j . tre .2017.04.003 } } Writing docs/references.bib Ahora queda mostrar la informaci\u00f3n del archivo .bib en el archivo references.rst %% writefile docs / references . rst Referencias =========== .. bibliography :: references . bib : style : unsrt : all : Writing docs/references.rst Archivo main.rst Ac\u00e1 va toda la informaci\u00f3n del m\u00f3dulo main.py ( paquete my_project ). Por otro lado, si existiesen otros m\u00f3dulo del paquete my_project ser\u00eda ideal crear otros archivos .rst . %% writefile docs / main . rst Main ============ .. uml :: diagrams / example . puml .. automodule :: my_project . main Writing docs/main.rst Crear Proyecto Con los archivos .rst configurados, se puede poner manos a la obra con la documentaci\u00f3n de los archivos .py . Nuestro ejemplos mostrar\u00e1 imagenes y diagramas de plantuml , los cuales se agregan a la carpeta docs . # agregar imagenes a docs ! cp - R img / docs / # agregar diagramas plantuml a docs ! cp - R diagrams / docs / # crear directorio del proyecto ! mkdir my_project # crear archivo __init__.py ! cp - R __init__ . py my_project Archivo main.py Para este archivo documentaremos una funci\u00f3n y dos clases, donde una clase ser\u00e1 nativa de python y otra seguir\u00e1 los est\u00e1ndares de pydantic . %% writefile my_project / main . py # -*- coding: utf-8 -*- \"\"\" Main ============ .. autofunction:: calcular_pi .. autoclass:: RoutingStrategy .. pydantic:: my_project.main.OrdenTrabajo \"\"\" import abc from pydantic import BaseModel , validator from typing import List , Set , Optional , Generator from enum import Enum import os class OrdenTrabajo ( BaseModel ): \"\"\"Esta clase representa una Orden de Trabajo\"\"\" sku_ids : Set [ int ] def calcular_pi ( n : int ) -> float : \"\"\" Aproximacion del valor de pi mediante el m\u00e9todo de Leibniz :math:`\\displaystyle \\pi = 4 \\\\sum_{k=1}^{\\\\infty}\\\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\\\dfrac{1}{3}+\\\\dfrac{1}{5}-\\\\dfrac{1}{7} + ...)` :param n: Numero de terminos :return: Valor aproximado de pi :ejemplos: >>> calcular_pi(3) 3.466666666666667 >>> calcular_pi(1000) 3.140592653839794 \"\"\" pi = 0 # valor incial for k in range ( 1 , n + 1 ): numerador = ( - 1 ) ** ( k + 1 ) # numerador de la iteracion i denominador = 2 * k - 1 # denominador de la iteracion i pi += numerador / denominador # suma hasta el i-esimo termino return 4 * pi class RoutingStrategy ( str , Enum ): \"\"\" Enumeraci\u00f3n de las distintas formas de ruteo dentro de un centro de distribuci\u00f3n: .. image:: img/routing_strategies.png Ver :cite:`dijkstra2017` para m\u00e1s detalles. \"\"\" RETURN = \"RETURN\" S_SHAPE = \"S\" LARGEST_GAP = \"LARGEST GAP\" MIDPOINT = \"MIDPOINT\" Writing my_project/main.py Informaci\u00f3n importante a destacar 1.- Encabezado: se debe ocupar las directivas de reST para instanciar las clases (y funciones) que ir\u00e1n en la documentaci\u00f3n. Estas directivas depender\u00e1 del objeto ocupado en python. # -*- coding: utf-8 -*- \"\"\" Main ============ .. autofunction:: calcular_pi .. autoclass:: RoutingStrategy .. pydantic:: my_project.main.OrdenTrabajo \"\"\" 2.- Para agregar imagenes se ocupa la directiva .. image:: . Para agregar citas se ocupa la directiva :cite: . class RoutingStrategy ( str , Enum ): \"\"\" Enumeraci\u00f3n de las distintas formas de ruteo dentro de un centro de distribuci\u00f3n: .. image:: img/routing_strategies.png Ver :cite:`dijkstra2017` para m\u00e1s detalles. \"\"\" RETURN = \"RETURN\" S_SHAPE = \"S\" LARGEST_GAP = \"LARGEST GAP\" MIDPOINT = \"MIDPOINT\" \u00a1 Crear documentaci\u00f3n ! Si se ha seguido los pasos correctamente, se puede generar la documentaci\u00f3n del paquete my_project (en este caso, en HTML). Para crear la documentaci\u00f3n, es necesario moverse a la carpeta docs y ejecutar por l\u00ednea de comando make html ! cd docs && make html \u001b[01mRunning Sphinx v3.2.1\u001b[39;49;00m \u001b[01mloading translations [es]... \u001b[39;49;00mdone \u001b[01mmaking output directory... \u001b[39;49;00mdone \u001b[01mbuilding [mo]: \u001b[39;49;00mtargets for 0 po files that are out of date \u001b[01mbuilding [html]: \u001b[39;49;00mtargets for 3 source files that are out of date \u001b[01mupdating environment: \u001b[39;49;00m[new config] 3 added, 0 changed, 0 removed \u001b[01mchecking for /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/references.bib in bibtex cache... \u001b[39;49;00mnot found \u001b[01mparsing bibtex file /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/references.bib... \u001b[39;49;00mparsed 1 entries \u001b[01mlooking for now-outdated files... \u001b[39;49;00mnone found \u001b[01mpickling environment... \u001b[39;49;00mdone \u001b[01mchecking consistency... \u001b[39;49;00mdone \u001b[01mpreparing documents... \u001b[39;49;00mdone \u001b[01mwriting output... \u001b[39;49;00m[100%] \u001b[32mreferences\u001b[39;49;00m \u001b[01mgenerating indices... \u001b[39;49;00m genindex py-modindexdone \u001b[01mwriting additional pages... \u001b[39;49;00m searchdone \u001b[01mcopying images... \u001b[39;49;00m[100%] \u001b[33mimg/routing_strategies.png\u001b[39;49;00m \u001b[01mcopying static files... ... \u001b[39;49;00mdone \u001b[01mcopying extra files... \u001b[39;49;00mdone \u001b[01mdumping search index in Spanish (code: es)... \u001b[39;49;00mdone \u001b[01mdumping object inventory... \u001b[39;49;00mdone \u001b[01mbuild succeeded.\u001b[39;49;00m The HTML pages are in _build/html. La documentaci\u00f3n estar\u00e1 disponible en la carpeta docs/_build/html/ . Se accede a la documentaci\u00f3n mediante el navegador de Google Chrome ejecutando: #!cd docs/_build/html && google-chrome index.html Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r docs my_project","title":"Sphinx"},{"location":"documentation/sphinx/#sphinx","text":"","title":"Sphinx"},{"location":"documentation/sphinx/#introduccion","text":"Sphinx es una herramienta que facilita la creaci\u00f3n de documentaci\u00f3n inteligente y hermosa, escrita por Georg Brandl y con licencia BSD. Fue creado originalmente para la documentaci\u00f3n de Python y tiene excelentes facilidades para la documentaci\u00f3n de proyectos de software en una variedad de lenguajes. \u00a1Por supuesto, este sitio tambi\u00e9n se crea a partir de fuentes reStructuredText utilizando Sphinx! Deben destacarse las siguientes caracter\u00edsticas: Formatos de salida : HTML (incluida la Ayuda HTML de Windows), LaTeX (para versiones en PDF imprimibles), ePub, Texinfo, p\u00e1ginas de manual, texto sin formato Referencias cruzadas extensas : marcado sem\u00e1ntico y enlaces autom\u00e1ticos para funciones, clases, citas, t\u00e9rminos del glosario y piezas de informaci\u00f3n similares Estructura jer\u00e1rquica : definici\u00f3n sencilla de un \u00e1rbol de documentos, con enlaces autom\u00e1ticos a hermanos, padres e hijos \u00cdndices autom\u00e1ticos : \u00edndice general as\u00ed como \u00edndices de m\u00f3dulo espec\u00edficos del idioma Manejo de c\u00f3digo : resaltado autom\u00e1tico con el resaltador Pygments Extensiones : prueba autom\u00e1tica de fragmentos de c\u00f3digo, inclusi\u00f3n de cadenas de documentos de m\u00f3dulos de Python (documentos API) y m\u00e1s Nuevas Extensiones : m\u00e1s de 50 extensiones aportadas por los usuarios en un segundo repositorio; la mayor\u00eda de ellos instalables desde PyPI","title":"Introducci\u00f3n"},{"location":"documentation/sphinx/#instalacion","text":"La instalaci\u00f3n de Sphinx depender\u00e1 del sistema operativo que est\u00e9s utilizando. Si ya tienes instalado Python, puedes descargar e instalar Sphinx utilizando pip: $ pip install -U sphinx","title":"Instalaci\u00f3n"},{"location":"documentation/sphinx/#creacion-del-directorio-de-trabajo","text":"Para crear nuestro directorio de trabajo con Sphinx mediante l\u00ednea de comando ejecutamos: $ sphinx-quickstart [options] [projectdir] Sphinx se encargar\u00e1 de crear varios archivos de configuraci\u00f3n y de directorios vac\u00edos que ser\u00e1n utilizados m\u00e1s adelante. Para ver todas las opciones de sphinx-quickstart podemos visitar la p\u00e1guina Invocation of sphinx-quickstart . Ac\u00e1 existen dos formas de crear el proyecto: Respondiendo por terminal cada unas de la opciones (nombre poryecto, autor, etc.) Setear todos las opciones por l\u00ednea de comandos. Para efectos pr\u00e1cticos, ocuparemos la segunda opci\u00f3n: # inicializar ! sphinx - quickstart \\ -- quiet \\ -- project = docs \\ -- author = faam \\ -- release = 0.1 \\ -- language = es \u001b[01mFinished: An initial directory structure has been created.\u001b[39;49;00m You should now populate your master file /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/index.rst and create other documentation source files. Use the Makefile to build the docs, like so: make builder where \"builder\" is one of the supported builders, e.g. html, latex or linkcheck. Una vez creado el proyecto, deberiamos ver algo como esto: docs | _build | _static | _templates | conf.py | index.rst | make.bat | Makefile","title":"Creaci\u00f3n del directorio de trabajo"},{"location":"documentation/sphinx/#primer-ejemplo-con-sphinx","text":"Nuestro ejemplo consiste en documentar el paquete de python denominado my_project , el cual consta simplemente de un m\u00f3dulo .py (denominado main.py ). Esquema del proyecto: docs | _build | _static | _templates | conf.py | index.rst | make.bat | Makefile | my_project | __init__.py | main.py Para poder crear una correcta documentaci\u00f3n, es neceario conocer los archivos generados por Sphinx y las modificaciones a los archivos .py .","title":"Primer ejemplo con Sphinx"},{"location":"documentation/sphinx/#archivo-confpy","text":"El directorio de configuraci\u00f3n debe contener un archivo llamado conf.py . Este archivo (que contiene c\u00f3digo Python) se denomina \"archivo de configuraci\u00f3n de compilaci\u00f3n\" y contiene (casi) toda la configuraci\u00f3n necesaria para personalizar el comportamiento de entrada y salida de Sphinx. %% writefile docs / conf . py # Configuration file for the Sphinx documentation builder. # # This file only contains a selection of the most common options. For a full # list see the documentation: # https://www.sphinx-doc.org/en/master/usage/configuration.html # -- Path setup -------------------------------------------------------------- # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # import os import sys cwd = os . getcwd () project_root = os . path . dirname ( cwd ) sys . path . insert ( 0 , project_root ) from my_project import __version__ # noqa # -- Project information ----------------------------------------------------- project = 'my_project' copyright = '2020, faam' author = 'faam' # The full version, including alpha/beta/rc tags release = __version__ # -- General configuration --------------------------------------------------- # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = [ \"sphinx.ext.autodoc\" , # Include documentation from docstrings \"sphinxcontrib.plantuml\" , # Sphinx \"plantuml\" extension \"sphinx-pydantic\" , # Autogenerate documentation from pydantic objects in Sphinx \"sphinxcontrib.bibtex\" , # A Sphinx extension for BibTeX style citations. \"sphinx.ext.mathjax\" , # Sphinx supports math in documentation with several extensions ] # Add any paths that contain templates here, relative to this directory. templates_path = [ '_templates' ] # The language for content autogenerated by Sphinx. Refer to documentation # for a list of supported languages. # # This is also used if you do content translation via gettext catalogs. # Usually you set \"language\" from the command line for these cases. language = 'es' # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. # This pattern also affects html_static_path and html_extra_path. exclude_patterns = [ '_build' , 'Thumbs.db' , '.DS_Store' ] # -- Options for HTML output ------------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = \"sphinx_rtd_theme\" # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named \"default.css\" will overwrite the builtin \"default.css\". html_static_path = [ '_static' ] Overwriting docs/conf.py Vayamos desglosando este archivo: 1.- En Path setup se importa la versi\u00f3n de nuestro paquete my_project . # -- Path setup -------------------------------------------------------------- # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # import os import sys cwd = os . getcwd () project_root = os . path . dirname ( cwd ) sys . path . insert ( 0 , project_root ) from my_project import __version__ # noqa 2.- En Project information se pone la informaci\u00f3n del proyecto # -- Project information ----------------------------------------------------- project = 'my_project' copyright = '2020, faam' author = 'faam' # The full version, including alpha/beta/rc tags release = __version__ 3.- En General configuration se configura: extensiones : agregar extensiones en la medida que se necesite. # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom # ones. extensions = [ \"sphinx.ext.autodoc\" , # Include documentation from docstrings \"sphinxcontrib.plantuml\" , # Sphinx \"plantuml\" extension \"sphinx-pydantic\" , # Autogenerate documentation from pydantic objects in Sphinx \"sphinxcontrib.bibtex\" , # A Sphinx extension for BibTeX style citations. \"sphinx.ext.mathjax\" , # Sphinx supports math in documentation with several extensions ] idioma : especificar el idioma de la documentaci\u00f3n (en este caso espa\u00f1ol ) # This is also used if you do content translation via gettext catalogs. # Usually you set \"language\" from the command line for these cases. language = 'es' 4.- Tambi\u00e9n podemos modificar el formato de salida del HTML. # -- Options for HTML output ------------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = \"sphinx_rtd_theme\"","title":"Archivo conf.py"},{"location":"documentation/sphinx/#archivo-rst","text":"Sphinx utiliza como source archivos tipo .rst creados con un lenguaje de marcas denominado reStructuredText (o simplemente reST). Se trata de un tipo de formato similar a markdown, pero con una serie de marcas ampliadas especialmente dise\u00f1adas para facilitar el trabajo de documentaci\u00f3n autom\u00e1tica de c\u00f3digo.","title":"Archivo *.rst"},{"location":"documentation/sphinx/#restructuredtext-directives","text":"Las directivas de reStructuredText son los argumentos que ocupa reStructuredText para construir su cuerpo. Las distintas directivas se iran aprendiendo en la medida que se construyan los archivos .rst a ocupar. Algunos ejemplos: .. toctree:: .. bibliography:: .. automodule:: .. uml:: .. image:: .. autofunction:: .. autoclass:: .. pydantic::","title":"reStructuredText Directives"},{"location":"documentation/sphinx/#archivo-indexrst","text":"Por defecto, se viene con el archivo index.rst , que corresponde al \u00edndice del archivo html que se genera, en \u00e9l pondremos los archivos *.rst que se quieren mostrar en la documentaci\u00f3n. %% writefile docs / index . rst .. documentation master file , created by sphinx - quickstart on Sun Sep 27 12 : 49 : 37 2020. You can adapt this file completely to your liking , but it should at least contain the root ` toctree ` directive . Welcome to my_project 's documentation! ======================================= .. toctree :: : maxdepth : 2 : caption : Contents : main references Indices and tables ================== * : ref : ` genindex ` * : ref : ` modindex ` * : ref : ` search ` Overwriting docs/index.rst 1.- Se agrega el nombre del t\u00edtulo de la docuemntaci\u00f3n Welcome to my_project's documentation! ======================================= 2.- Se agregan los archivos main y reference : main references Esta forma de referenciar, hace menci\u00f3n a los archivos: main.rst : informaci\u00f3n del m\u00f3dulo main.py refrences.rst : informaci\u00f3n de las bibiliografias ocupadas.","title":"Archivo index.rst"},{"location":"documentation/sphinx/#archivo-refrencesrst","text":"El archivo refrences.rst mostrar\u00e1 en la docuemntaci\u00f3n toda la bibliograf\u00eda ocupada. Se trabaja una estructura similar a la de Latex , creando un archivo references.bib con todas las referencias. %% writefile docs / references . bib @article { dijkstra2017 , author = { Dijkstra , Arjan and Roodbergen , Kees Jan }, year = { 2017 }, month = { 04 }, pages = {}, title = { Exact route - length formulas and a storage location assignment heuristic for picker - to - parts warehouses }, volume = { 102 }, journal = { Transportation Research Part E Logistics and Transportation Review }, doi = { 10.1016 / j . tre .2017.04.003 } } Writing docs/references.bib Ahora queda mostrar la informaci\u00f3n del archivo .bib en el archivo references.rst %% writefile docs / references . rst Referencias =========== .. bibliography :: references . bib : style : unsrt : all : Writing docs/references.rst","title":"Archivo refrences.rst"},{"location":"documentation/sphinx/#archivo-mainrst","text":"Ac\u00e1 va toda la informaci\u00f3n del m\u00f3dulo main.py ( paquete my_project ). Por otro lado, si existiesen otros m\u00f3dulo del paquete my_project ser\u00eda ideal crear otros archivos .rst . %% writefile docs / main . rst Main ============ .. uml :: diagrams / example . puml .. automodule :: my_project . main Writing docs/main.rst","title":"Archivo main.rst"},{"location":"documentation/sphinx/#crear-proyecto","text":"Con los archivos .rst configurados, se puede poner manos a la obra con la documentaci\u00f3n de los archivos .py . Nuestro ejemplos mostrar\u00e1 imagenes y diagramas de plantuml , los cuales se agregan a la carpeta docs . # agregar imagenes a docs ! cp - R img / docs / # agregar diagramas plantuml a docs ! cp - R diagrams / docs / # crear directorio del proyecto ! mkdir my_project # crear archivo __init__.py ! cp - R __init__ . py my_project","title":"Crear Proyecto"},{"location":"documentation/sphinx/#archivo-mainpy","text":"Para este archivo documentaremos una funci\u00f3n y dos clases, donde una clase ser\u00e1 nativa de python y otra seguir\u00e1 los est\u00e1ndares de pydantic . %% writefile my_project / main . py # -*- coding: utf-8 -*- \"\"\" Main ============ .. autofunction:: calcular_pi .. autoclass:: RoutingStrategy .. pydantic:: my_project.main.OrdenTrabajo \"\"\" import abc from pydantic import BaseModel , validator from typing import List , Set , Optional , Generator from enum import Enum import os class OrdenTrabajo ( BaseModel ): \"\"\"Esta clase representa una Orden de Trabajo\"\"\" sku_ids : Set [ int ] def calcular_pi ( n : int ) -> float : \"\"\" Aproximacion del valor de pi mediante el m\u00e9todo de Leibniz :math:`\\displaystyle \\pi = 4 \\\\sum_{k=1}^{\\\\infty}\\\\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\\\\dfrac{1}{3}+\\\\dfrac{1}{5}-\\\\dfrac{1}{7} + ...)` :param n: Numero de terminos :return: Valor aproximado de pi :ejemplos: >>> calcular_pi(3) 3.466666666666667 >>> calcular_pi(1000) 3.140592653839794 \"\"\" pi = 0 # valor incial for k in range ( 1 , n + 1 ): numerador = ( - 1 ) ** ( k + 1 ) # numerador de la iteracion i denominador = 2 * k - 1 # denominador de la iteracion i pi += numerador / denominador # suma hasta el i-esimo termino return 4 * pi class RoutingStrategy ( str , Enum ): \"\"\" Enumeraci\u00f3n de las distintas formas de ruteo dentro de un centro de distribuci\u00f3n: .. image:: img/routing_strategies.png Ver :cite:`dijkstra2017` para m\u00e1s detalles. \"\"\" RETURN = \"RETURN\" S_SHAPE = \"S\" LARGEST_GAP = \"LARGEST GAP\" MIDPOINT = \"MIDPOINT\" Writing my_project/main.py","title":"Archivo main.py"},{"location":"documentation/sphinx/#informacion-importante-a-destacar","text":"1.- Encabezado: se debe ocupar las directivas de reST para instanciar las clases (y funciones) que ir\u00e1n en la documentaci\u00f3n. Estas directivas depender\u00e1 del objeto ocupado en python. # -*- coding: utf-8 -*- \"\"\" Main ============ .. autofunction:: calcular_pi .. autoclass:: RoutingStrategy .. pydantic:: my_project.main.OrdenTrabajo \"\"\" 2.- Para agregar imagenes se ocupa la directiva .. image:: . Para agregar citas se ocupa la directiva :cite: . class RoutingStrategy ( str , Enum ): \"\"\" Enumeraci\u00f3n de las distintas formas de ruteo dentro de un centro de distribuci\u00f3n: .. image:: img/routing_strategies.png Ver :cite:`dijkstra2017` para m\u00e1s detalles. \"\"\" RETURN = \"RETURN\" S_SHAPE = \"S\" LARGEST_GAP = \"LARGEST GAP\" MIDPOINT = \"MIDPOINT\"","title":"Informaci\u00f3n importante a destacar"},{"location":"documentation/sphinx/#crear-documentacion","text":"Si se ha seguido los pasos correctamente, se puede generar la documentaci\u00f3n del paquete my_project (en este caso, en HTML). Para crear la documentaci\u00f3n, es necesario moverse a la carpeta docs y ejecutar por l\u00ednea de comando make html ! cd docs && make html \u001b[01mRunning Sphinx v3.2.1\u001b[39;49;00m \u001b[01mloading translations [es]... \u001b[39;49;00mdone \u001b[01mmaking output directory... \u001b[39;49;00mdone \u001b[01mbuilding [mo]: \u001b[39;49;00mtargets for 0 po files that are out of date \u001b[01mbuilding [html]: \u001b[39;49;00mtargets for 3 source files that are out of date \u001b[01mupdating environment: \u001b[39;49;00m[new config] 3 added, 0 changed, 0 removed \u001b[01mchecking for /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/references.bib in bibtex cache... \u001b[39;49;00mnot found \u001b[01mparsing bibtex file /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/ecosystem/sphinx/docs/references.bib... \u001b[39;49;00mparsed 1 entries \u001b[01mlooking for now-outdated files... \u001b[39;49;00mnone found \u001b[01mpickling environment... \u001b[39;49;00mdone \u001b[01mchecking consistency... \u001b[39;49;00mdone \u001b[01mpreparing documents... \u001b[39;49;00mdone \u001b[01mwriting output... \u001b[39;49;00m[100%] \u001b[32mreferences\u001b[39;49;00m \u001b[01mgenerating indices... \u001b[39;49;00m genindex py-modindexdone \u001b[01mwriting additional pages... \u001b[39;49;00m searchdone \u001b[01mcopying images... \u001b[39;49;00m[100%] \u001b[33mimg/routing_strategies.png\u001b[39;49;00m \u001b[01mcopying static files... ... \u001b[39;49;00mdone \u001b[01mcopying extra files... \u001b[39;49;00mdone \u001b[01mdumping search index in Spanish (code: es)... \u001b[39;49;00mdone \u001b[01mdumping object inventory... \u001b[39;49;00mdone \u001b[01mbuild succeeded.\u001b[39;49;00m The HTML pages are in _build/html. La documentaci\u00f3n estar\u00e1 disponible en la carpeta docs/_build/html/ . Se accede a la documentaci\u00f3n mediante el navegador de Google Chrome ejecutando: #!cd docs/_build/html && google-chrome index.html Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r docs my_project","title":"\u00a1 Crear documentaci\u00f3n !"},{"location":"ecosystem/click/","text":"Click Introducci\u00f3n Click es un paquete de Python para crear hermosas interfaces de l\u00ednea de comandos de forma componible con tan poco c\u00f3digo como sea necesario. Es el \"Kit de creaci\u00f3n de interfaz de l\u00ednea de comandos\". Es altamente configurable pero viene con valores predeterminados razonables listos para usar. Su objetivo es hacer que el proceso de escribir herramientas de l\u00ednea de comandos sea r\u00e1pido y divertido, al mismo tiempo que evita cualquier frustraci\u00f3n causada por la incapacidad de implementar una API CLI prevista. Click en tres puntos: anidamiento arbitrario de comandos generaci\u00f3n autom\u00e1tica de p\u00e1ginas de ayuda admite la carga diferida de subcomandos en tiempo de ejecuci\u00f3n Veamos un ejemplo sencillo de esto: %% writefile click_example_01 . py import click @click . command () @click . argument ( 'name' , default = 'world' ) def hello ( name ): click . echo ( f 'Hello { name } ' ) if __name__ == '__main__' : hello () El ejemplo crea un mensaje con el valor de argumento dado. Si no hay ning\u00fan argumento, se utiliza el invitado predeterminado. El argumento se pasa a la funci\u00f3n como variable. ! python ./ click_example_01 . py ! python ./ click_example_01 . py guest Python click argument types Podemos especificar los tipos de argumentos, incluidos int, float, str, bool, choice y varios rangos. El predeterminado es str. %% writefile click_example_02 . py import click @click . command () @click . argument ( 'name' , default = 'guest' ) @click . argument ( 'age' , type = int ) def hello ( name , age ): click . echo ( f ' { name } is { age } years old' ) if __name__ == '__main__' : hello () ! python click_example_02 . py Peter 34 Python click variable number of arguments Con la opci\u00f3n nargs , podemos establecer que un argumento tome m\u00faltiples valores. Para el valor -1, el argumento puede tomar un n\u00famero variable de valores. %% writefile click_example_03 . py import click from operator import mul from functools import reduce @click . command () @click . argument ( 'vals' , type = int , nargs =- 1 ) def process ( vals ): print ( f 'The sum is { sum ( vals ) } ' ) print ( f 'The product is { reduce ( mul , vals , 1 ) } ' ) if __name__ == '__main__' : process () El ejemplo crea un comando de proceso, que puede tomar un n\u00famero variable de valores enteros en el argumento vals . El comando calcula la suma y el producto de los valores. ! python click_example_03 . py 1 2 3 4 5 Python click simple option Las opciones se agregan a los comandos con el decorador click.option() . Los nombres de las opciones tienen como prefijo uno o dos guiones. %% writefile click_example_04 . py import click @click . command () @click . option ( '--n' , type = int , default = 1 ) def dots ( n ): click . echo ( '.' * n ) if __name__ == '__main__' : dots () En el ejemplo, tenemos la opci\u00f3n --n que toma un n\u00famero. El n\u00famero determina cu\u00e1ntas veces se imprime el punto en la consola. ! python click_example_04 . py -- n 17 Python click option names Los nombres de las opciones comienzan con un solo gui\u00f3n o con dos guiones. Los programas de l\u00ednea de comandos suelen tener opciones tanto cortas como largas. Click deriva el nombre de la opci\u00f3n del nombre largo, si se utilizan ambos. %% writefile click_example_05 . py import click @click . command () @click . option ( '-s' , '--string' ) def output ( string ): click . echo ( string ) if __name__ == '__main__' : output () En el ejemplo, creamos una opci\u00f3n con nombres cortos y largos. El nombre de la variable pasada a la funci\u00f3n es un string, derivado del nombre de opci\u00f3n m\u00e1s largo. ! python click_example_05 . py - s sky ! python click_example_05 . py -- string cloud Python click prompt for value Podemos pedirle a un usuario que proporcione un valor de forma interactiva. %% writefile click_example_06 . py import click @click . command () @click . option ( \"--name\" , prompt = \"Your name\" , help = \"Provide your name\" ) def hello ( name ): click . echo ( f \"Hello, { name } \" ) if __name__ == '__main__' : hello () El ejemplo le pide al usuario su nombre. #!python click_example_06.py Python click colour output Con el m\u00e9todo secho , podemos generar el texto en color. Tambi\u00e9n podemos utilizar estilos como negrita y subrayado. Los valores de color est\u00e1n limitados a un conjunto de valores predefinidos. Para la salida en color necesitamos tener instalado el m\u00f3dulo colorama. %% writefile click_example_07 . py import click @click . command () def coloured (): click . secho ( 'Hello there' , fg = \"blue\" , bold = True ) if __name__ == '__main__' : coloured () El ejemplo muestra el texto en color azul intenso. ! python click_example_07 . py Python click flags Los flags son opciones booleanas que se pueden habilitar o deshabilitar. Esto se puede lograr definiendo dos flags de una vez separadas por una barra (/) para habilitar o deshabilitar la opci\u00f3n o con el par\u00e1metro is_flag . %% writefile click_example_08 . py import click @click . command () @click . option ( '--blue' , is_flag = True , help = 'message in blue color' ) def hello ( blue ): if blue : click . secho ( 'Hello there' , fg = 'blue' ) else : click . secho ( 'Hello there' ) if __name__ == '__main__' : hello () En el ejemplo, definimos una opci\u00f3n booleana --blue con el par\u00e1metro is_flag . Si est\u00e1 configurado, imprime el mensaje en color azul. ! python click_example_08 . py %% writefile click_example_09 . py import click @click . command () @click . argument ( 'word' ) @click . option ( '--shout/--no-shout' , default = False ) def output ( word , shout ): if shout : click . echo ( word . upper ()) else : click . echo ( word ) if __name__ == '__main__' : output () En el segundo caso, definimos los flags --shout y --no-shout . Si se establece la marca --shout , el argumento especificado se muestra en may\u00fasculas. ! python click_example_09 . py -- shout sky ! python click_example_09 . py -- no - shout sky Python click environment variables Los valores se pueden extraer de las variables de entorno. %% writefile click_example_10 . py import click import os @click . argument ( 'mydir' , envvar = 'MYDIR' , type = click . Path ( exists = True )) @click . command () def dolist ( mydir ): click . echo ( os . listdir ( mydir )) if __name__ == '__main__' : dolist () El ejemplo imprime el contenido del directorio especificado en la variable de entorno MYDIR. #!export MYDIR=~/Documents; click_example_10.py #!python click_example_10.py Python click option tuples Podemos tener opciones de valores m\u00faltiples que se convierten en tuplas de Python. %% writefile click_example_11 . py import click @click . command () @click . option ( '--data' , required = True , type = ( str , int )) def output ( data ): click . echo ( f 'name= { data [ 0 ] } age= { data [ 1 ] } ' ) if __name__ == '__main__' : output () En el ejemplo, la opci\u00f3n --data toma dos valores que se convierten en una tupla de Python. Los valores se utilizan para construir un mensaje. ! python click_example_11 . py -- data Peter 23 Specifying options multiple times Los valores de opci\u00f3n se pueden proporcionar varias veces y se pueden registrar todos los valores. Los valores se almacenan en una tupla de Python. %% writefile click_example_12 . py import click @click . command () @click . option ( '--word' , '-w' , multiple = True ) def words ( word ): click . echo ( ' \\n ' . join ( word )) if __name__ == '__main__' : words () En el ejemplo, podemos especificar las opciones --word/-w varias veces. ! python click_example_12 . py - w sky -- word forest -- word rock - w cloud The click.File type El tipo click.File declara que un par\u00e1metro es un archivo para lectura o escritura. El archivo se cierra autom\u00e1ticamente una vez que el contexto se rompe (despu\u00e9s de que el comando termin\u00f3 de funcionar). %% writefile words . txt sky cloud water forest rock moon falcon lake Trabajamos con este archivo de texto. %% writefile click_example_13 . py import click @click . command () @click . argument ( 'file_name' , type = click . File ( 'r' )) @click . argument ( 'lines' , default =- 1 , type = int ) def head ( file_name , lines ): counter = 0 for line in file_name : print ( line . strip ()) counter += 1 if counter == lines : break if __name__ == '__main__' : head () Creamos un equivalente del comando head de Linux. ! python click_example_13 . py words . txt 4 The click.Path type El tipo click.Path es similar al tipo click.File . En lugar de devolver un identificador de archivo abierto, solo devuelve el nombre del archivo. %% writefile click_example_14 . py import click @click . command () @click . argument ( 'file_name' , type = click . Path ( exists = True )) @click . argument ( 'lines' , default =- 1 , type = int ) def head ( file_name , lines ): with open ( file_name , 'r' ) as f : counter = 0 for line in file_name : print ( line . strip ()) counter += 1 if counter == lines : break if __name__ == '__main__' : head () Este es el comando de cabecera creado con el tipo click.Path . Python click command groups Los comandos se pueden agregar a grupos. Los grupos se crean con el decorador @click.group . %% writefile click_example_15 . py import click @click . group () def messages (): pass @click . command () def generic (): click . echo ( 'Hello there' ) @click . command () def welcome (): click . echo ( 'Welcome' ) messages . add_command ( generic ) messages . add_command ( welcome ) if __name__ == '__main__' : messages () El ejemplo define dos grupos. ! python click_example_15 . py -- help ! python click_example_15 . py generic ! python click_example_15 . py welcome El mensaje de ayuda muestra dos comandos. %% writefile click_example_16 . py import click @click . group () def cli (): pass @cli . command ( name = 'gen' ) def generic (): click . echo ( 'Hello there' ) @cli . command ( name = 'wel' ) def welcome (): click . echo ( 'Welcome' ) if __name__ == '__main__' : cli () Esta es una sintaxis alternativa para crear un grupo de comandos. Los comandos toman el nombre de la funci\u00f3n, pero se les puede dar otro nombre con la opci\u00f3n de nombre. ! python click_example_16 . py gen ! python click_example_16 . py wel Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm *. py *. txt","title":"Click"},{"location":"ecosystem/click/#click","text":"","title":"Click"},{"location":"ecosystem/click/#introduccion","text":"Click es un paquete de Python para crear hermosas interfaces de l\u00ednea de comandos de forma componible con tan poco c\u00f3digo como sea necesario. Es el \"Kit de creaci\u00f3n de interfaz de l\u00ednea de comandos\". Es altamente configurable pero viene con valores predeterminados razonables listos para usar. Su objetivo es hacer que el proceso de escribir herramientas de l\u00ednea de comandos sea r\u00e1pido y divertido, al mismo tiempo que evita cualquier frustraci\u00f3n causada por la incapacidad de implementar una API CLI prevista. Click en tres puntos: anidamiento arbitrario de comandos generaci\u00f3n autom\u00e1tica de p\u00e1ginas de ayuda admite la carga diferida de subcomandos en tiempo de ejecuci\u00f3n Veamos un ejemplo sencillo de esto: %% writefile click_example_01 . py import click @click . command () @click . argument ( 'name' , default = 'world' ) def hello ( name ): click . echo ( f 'Hello { name } ' ) if __name__ == '__main__' : hello () El ejemplo crea un mensaje con el valor de argumento dado. Si no hay ning\u00fan argumento, se utiliza el invitado predeterminado. El argumento se pasa a la funci\u00f3n como variable. ! python ./ click_example_01 . py ! python ./ click_example_01 . py guest","title":"Introducci\u00f3n"},{"location":"ecosystem/click/#python-click-argument-types","text":"Podemos especificar los tipos de argumentos, incluidos int, float, str, bool, choice y varios rangos. El predeterminado es str. %% writefile click_example_02 . py import click @click . command () @click . argument ( 'name' , default = 'guest' ) @click . argument ( 'age' , type = int ) def hello ( name , age ): click . echo ( f ' { name } is { age } years old' ) if __name__ == '__main__' : hello () ! python click_example_02 . py Peter 34","title":"Python click argument types"},{"location":"ecosystem/click/#python-click-variable-number-of-arguments","text":"Con la opci\u00f3n nargs , podemos establecer que un argumento tome m\u00faltiples valores. Para el valor -1, el argumento puede tomar un n\u00famero variable de valores. %% writefile click_example_03 . py import click from operator import mul from functools import reduce @click . command () @click . argument ( 'vals' , type = int , nargs =- 1 ) def process ( vals ): print ( f 'The sum is { sum ( vals ) } ' ) print ( f 'The product is { reduce ( mul , vals , 1 ) } ' ) if __name__ == '__main__' : process () El ejemplo crea un comando de proceso, que puede tomar un n\u00famero variable de valores enteros en el argumento vals . El comando calcula la suma y el producto de los valores. ! python click_example_03 . py 1 2 3 4 5","title":"Python click variable number of arguments"},{"location":"ecosystem/click/#python-click-simple-option","text":"Las opciones se agregan a los comandos con el decorador click.option() . Los nombres de las opciones tienen como prefijo uno o dos guiones. %% writefile click_example_04 . py import click @click . command () @click . option ( '--n' , type = int , default = 1 ) def dots ( n ): click . echo ( '.' * n ) if __name__ == '__main__' : dots () En el ejemplo, tenemos la opci\u00f3n --n que toma un n\u00famero. El n\u00famero determina cu\u00e1ntas veces se imprime el punto en la consola. ! python click_example_04 . py -- n 17","title":"Python click simple option"},{"location":"ecosystem/click/#python-click-option-names","text":"Los nombres de las opciones comienzan con un solo gui\u00f3n o con dos guiones. Los programas de l\u00ednea de comandos suelen tener opciones tanto cortas como largas. Click deriva el nombre de la opci\u00f3n del nombre largo, si se utilizan ambos. %% writefile click_example_05 . py import click @click . command () @click . option ( '-s' , '--string' ) def output ( string ): click . echo ( string ) if __name__ == '__main__' : output () En el ejemplo, creamos una opci\u00f3n con nombres cortos y largos. El nombre de la variable pasada a la funci\u00f3n es un string, derivado del nombre de opci\u00f3n m\u00e1s largo. ! python click_example_05 . py - s sky ! python click_example_05 . py -- string cloud","title":"Python click option names"},{"location":"ecosystem/click/#python-click-prompt-for-value","text":"Podemos pedirle a un usuario que proporcione un valor de forma interactiva. %% writefile click_example_06 . py import click @click . command () @click . option ( \"--name\" , prompt = \"Your name\" , help = \"Provide your name\" ) def hello ( name ): click . echo ( f \"Hello, { name } \" ) if __name__ == '__main__' : hello () El ejemplo le pide al usuario su nombre. #!python click_example_06.py","title":"Python click prompt for value"},{"location":"ecosystem/click/#python-click-colour-output","text":"Con el m\u00e9todo secho , podemos generar el texto en color. Tambi\u00e9n podemos utilizar estilos como negrita y subrayado. Los valores de color est\u00e1n limitados a un conjunto de valores predefinidos. Para la salida en color necesitamos tener instalado el m\u00f3dulo colorama. %% writefile click_example_07 . py import click @click . command () def coloured (): click . secho ( 'Hello there' , fg = \"blue\" , bold = True ) if __name__ == '__main__' : coloured () El ejemplo muestra el texto en color azul intenso. ! python click_example_07 . py","title":"Python click colour output"},{"location":"ecosystem/click/#python-click-flags","text":"Los flags son opciones booleanas que se pueden habilitar o deshabilitar. Esto se puede lograr definiendo dos flags de una vez separadas por una barra (/) para habilitar o deshabilitar la opci\u00f3n o con el par\u00e1metro is_flag . %% writefile click_example_08 . py import click @click . command () @click . option ( '--blue' , is_flag = True , help = 'message in blue color' ) def hello ( blue ): if blue : click . secho ( 'Hello there' , fg = 'blue' ) else : click . secho ( 'Hello there' ) if __name__ == '__main__' : hello () En el ejemplo, definimos una opci\u00f3n booleana --blue con el par\u00e1metro is_flag . Si est\u00e1 configurado, imprime el mensaje en color azul. ! python click_example_08 . py %% writefile click_example_09 . py import click @click . command () @click . argument ( 'word' ) @click . option ( '--shout/--no-shout' , default = False ) def output ( word , shout ): if shout : click . echo ( word . upper ()) else : click . echo ( word ) if __name__ == '__main__' : output () En el segundo caso, definimos los flags --shout y --no-shout . Si se establece la marca --shout , el argumento especificado se muestra en may\u00fasculas. ! python click_example_09 . py -- shout sky ! python click_example_09 . py -- no - shout sky","title":"Python click flags"},{"location":"ecosystem/click/#python-click-environment-variables","text":"Los valores se pueden extraer de las variables de entorno. %% writefile click_example_10 . py import click import os @click . argument ( 'mydir' , envvar = 'MYDIR' , type = click . Path ( exists = True )) @click . command () def dolist ( mydir ): click . echo ( os . listdir ( mydir )) if __name__ == '__main__' : dolist () El ejemplo imprime el contenido del directorio especificado en la variable de entorno MYDIR. #!export MYDIR=~/Documents; click_example_10.py #!python click_example_10.py","title":"Python click environment variables"},{"location":"ecosystem/click/#python-click-option-tuples","text":"Podemos tener opciones de valores m\u00faltiples que se convierten en tuplas de Python. %% writefile click_example_11 . py import click @click . command () @click . option ( '--data' , required = True , type = ( str , int )) def output ( data ): click . echo ( f 'name= { data [ 0 ] } age= { data [ 1 ] } ' ) if __name__ == '__main__' : output () En el ejemplo, la opci\u00f3n --data toma dos valores que se convierten en una tupla de Python. Los valores se utilizan para construir un mensaje. ! python click_example_11 . py -- data Peter 23","title":"Python click option tuples"},{"location":"ecosystem/click/#specifying-options-multiple-times","text":"Los valores de opci\u00f3n se pueden proporcionar varias veces y se pueden registrar todos los valores. Los valores se almacenan en una tupla de Python. %% writefile click_example_12 . py import click @click . command () @click . option ( '--word' , '-w' , multiple = True ) def words ( word ): click . echo ( ' \\n ' . join ( word )) if __name__ == '__main__' : words () En el ejemplo, podemos especificar las opciones --word/-w varias veces. ! python click_example_12 . py - w sky -- word forest -- word rock - w cloud","title":"Specifying options multiple times"},{"location":"ecosystem/click/#the-clickfile-type","text":"El tipo click.File declara que un par\u00e1metro es un archivo para lectura o escritura. El archivo se cierra autom\u00e1ticamente una vez que el contexto se rompe (despu\u00e9s de que el comando termin\u00f3 de funcionar). %% writefile words . txt sky cloud water forest rock moon falcon lake Trabajamos con este archivo de texto. %% writefile click_example_13 . py import click @click . command () @click . argument ( 'file_name' , type = click . File ( 'r' )) @click . argument ( 'lines' , default =- 1 , type = int ) def head ( file_name , lines ): counter = 0 for line in file_name : print ( line . strip ()) counter += 1 if counter == lines : break if __name__ == '__main__' : head () Creamos un equivalente del comando head de Linux. ! python click_example_13 . py words . txt 4","title":"The click.File type"},{"location":"ecosystem/click/#the-clickpath-type","text":"El tipo click.Path es similar al tipo click.File . En lugar de devolver un identificador de archivo abierto, solo devuelve el nombre del archivo. %% writefile click_example_14 . py import click @click . command () @click . argument ( 'file_name' , type = click . Path ( exists = True )) @click . argument ( 'lines' , default =- 1 , type = int ) def head ( file_name , lines ): with open ( file_name , 'r' ) as f : counter = 0 for line in file_name : print ( line . strip ()) counter += 1 if counter == lines : break if __name__ == '__main__' : head () Este es el comando de cabecera creado con el tipo click.Path .","title":"The click.Path type"},{"location":"ecosystem/click/#python-click-command-groups","text":"Los comandos se pueden agregar a grupos. Los grupos se crean con el decorador @click.group . %% writefile click_example_15 . py import click @click . group () def messages (): pass @click . command () def generic (): click . echo ( 'Hello there' ) @click . command () def welcome (): click . echo ( 'Welcome' ) messages . add_command ( generic ) messages . add_command ( welcome ) if __name__ == '__main__' : messages () El ejemplo define dos grupos. ! python click_example_15 . py -- help ! python click_example_15 . py generic ! python click_example_15 . py welcome El mensaje de ayuda muestra dos comandos. %% writefile click_example_16 . py import click @click . group () def cli (): pass @cli . command ( name = 'gen' ) def generic (): click . echo ( 'Hello there' ) @cli . command ( name = 'wel' ) def welcome (): click . echo ( 'Welcome' ) if __name__ == '__main__' : cli () Esta es una sintaxis alternativa para crear un grupo de comandos. Los comandos toman el nombre de la funci\u00f3n, pero se les puede dar otro nombre con la opci\u00f3n de nombre. ! python click_example_16 . py gen ! python click_example_16 . py wel Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm *. py *. txt","title":"Python click command groups"},{"location":"ecosystem/diagrams/","text":"Diagrams Introducci\u00f3n Naci\u00f3 para crear prototipos de una nueva arquitectura de sistema sin herramientas de dise\u00f1o. Tambi\u00e9n puede describir o visualizar la arquitectura del sistema existente. Diagram as Code le permite rastrear los cambios del diagrama de arquitectura en cualquier sistema de control de versiones. Actualmente, Diagrams admite seis proveedores principales: AWS , Azure , GCP , Kubernetes , Alibaba Cloud y Oracle Cloud . Ahora tambi\u00e9n admite nodos On-Premise , as\u00ed como Lenguajes de Programaci\u00f3n y Frameworks . Instalaci\u00f3n Python 3.6 o superior Instalar Graphviz Instalar la librer\u00eda diagrams : # using pip (pip3) $ pip install diagrams # using pipenv $ pipenv install diagrams # using poetry $ poetry add diagrams Tipos de componentes La biblioteca de diagramas proporciona componentes para varios proveedores diferentes. Lo siguiente probablemente ser\u00e1 m\u00e1s relevante para la mayor\u00eda de los casos de uso de los 14 disponibles. AWS/GCP/Azure Estos proveedores exponen los activos oficiales del servicio en la nube que usar\u00eda para cualquier diagrama que aproveche uno de los principales proveedores de la nube. Generic and On-Premise Estos nodos probablemente se usar\u00e1n juntos en el caso de que desee ilustrar las tecnolog\u00edas subyacentes de una manera independiente de la nube. Por ejemplo, proporcionar una arquitectura con un componente Beam sobre la pantalla Google DataFlow. Frameworks Estos componentes ser\u00e1n \u00fatiles si desea ilustrar un nodo con un lenguaje de programaci\u00f3n. SaaS Existe una colecci\u00f3n de nodos SaaS que se pueden usar, lo que resulta \u00fatil cuando desea mostrar que su arquitectura tiene notificaciones que llegan a algo como Slack. Conceptos Diagrama Diagram es el objeto principal que representa un diagrama.. El objeto Diagram representa un contexto de diagrama global. Puede crear un contexto de diagrama con la clase Diagram . El primer par\u00e1metro del constructor Diagram se utilizar\u00e1 para el nombre del archivo de salida. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" ): EC2 ( \"web\" ) Y si ejecuta el script anterior con el siguiente comando, $ python diagram.py Generar\u00e1 un archivo de imagen con un solo nodo EC2 dibujado como simple_diagram.png en su directorio de trabajo, y abrir\u00e1 ese archivo de imagen creado inmediatamente. Jupyter notebooks Diagram tambi\u00e9n se pueden renderizar directamente dentro del Jupyter de la siguiente manera: from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram Opciones Puede especificar el formato del archivo de salida con el par\u00e1metro outformat . El valor predeterminado es png . (png, jpg, svg, y pdf) son soportados. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , outformat = \"jpg\" ): EC2 ( \"web\" ) Overwriting diagram.py Puede especificar el nombre del archivo de salida con el par\u00e1metro de filename . La extensi\u00f3n no debe incluirse, est\u00e1 determinada por el par\u00e1metro outformat . %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , filename = \"my_diagram\" ): EC2 ( \"web\" ) Overwriting diagram.py Tambi\u00e9n puede deshabilitar la apertura autom\u00e1tica de archivos configurando el par\u00e1metro show como False . El valor predeterminado es True . %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ): EC2 ( \"web\" ) Overwriting diagram.py Permite opciones personalizadas de atributos de puntos de Graphviz . `graph_attr`, `node_attr` y `edge_attr` son soportados. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 graph_attr = { \"fontsize\" : \"45\" , \"bgcolor\" : \"transparent\" } with Diagram ( \"Simple Diagram\" , show = False , graph_attr = graph_attr ): EC2 ( \"web\" ) Overwriting diagram.py Nodes Node es un segundo objeto que representa un nodo o componente del sistema. Node es un concepto abstracto que representa un \u00fanico objeto componente del sistema. Un objeto Node consta de tres partes: proveedor, tipo de recurso y nombre. Es posible que ya haya visto cada parte en el ejemplo anterior. from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as dj : EC2 ( \"web\" ) En el ejemplo anterior, EC2 es un nodo de tipo de recurso inform\u00e1tico proporcionado por el proveedor de AWS . Puede usar otros objetos Node de manera similar como: # aws resources from diagrams.aws.compute import ECS , Lambda from diagrams.aws.database import RDS , ElastiCache from diagrams.aws.network import ELB , Route53 , VPC ... # azure resources from diagrams.azure.compute import FunctionApps from diagrams.azure.storage import BlobStorage ... # alibaba cloud resources from diagrams.alibabacloud.compute import ECS from diagrams.alibabacloud.storage import ObjectTableStore ... # gcp resources from diagrams.gcp.compute import AppEngine , GKE from diagrams.gcp.ml import AutoML ... # k8s resources from diagrams.k8s.compute import Pod , StatefulSet from diagrams.k8s.network import Service from diagrams.k8s.storage import PV , PVC , StorageClass ... # oracle resources from diagrams.oci.compute import VirtualMachine , Container from diagrams.oci.network import Firewall from diagrams.oci.storage import Filestorage , Storagegateway Data Flow Puede representar el flujo de datos conectando los nodos con estos operadores: >> : Conecta los nodos de izquierda a derecha. << : Conecta los nodos de derecha a izquierda. - : Conecta nodos en ninguna direcci\u00f3n. No dirigido. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB from diagrams.aws.storage import S3 with Diagram ( \"Web Services\" , show = False ) as node : ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) >> S3 ( \"store\" ) ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) << EC2 ( \"stat\" ) ( ELB ( \"lb\" ) >> EC2 ( \"web\" )) - EC2 ( \"web\" ) >> RDS ( \"userdb\" ) node Tenga cuidado al usar `-` y cualquier operador de turno juntos, lo que podr\u00eda causar resultados inesperados debido a la precedencia del operador. El orden de los diagramas renderizados es el inverso del orden de declaraci\u00f3n. Puede cambiar la direcci\u00f3n del flujo de datos con el par\u00e1metro direction . El valor predeterminado es LR . (TB, BT, LR y RL) est\u00e1n permitidos. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Workers\" , show = False , direction = \"TB\" ) as node : lb = ELB ( \"lb\" ) db = RDS ( \"events\" ) lb >> EC2 ( \"worker1\" ) >> db lb >> EC2 ( \"worker2\" ) >> db lb >> EC2 ( \"worker3\" ) >> db lb >> EC2 ( \"worker4\" ) >> db lb >> EC2 ( \"worker5\" ) >> db node Group Data Flow El ejemplo del worker anterior tiene demasiados flujos redundantes. En este caso, puede agrupar nodos en una lista para que todos los nodos est\u00e9n conectados a otros nodos a la vez. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Grouped Workers\" , show = False , direction = \"TB\" ) as node : ELB ( \"lb\" ) >> [ EC2 ( \"worker1\" ), EC2 ( \"worker2\" ), EC2 ( \"worker3\" ), EC2 ( \"worker4\" ), EC2 ( \"worker5\" )] >> RDS ( \"events\" ) node No puede conectar dos listas directamente porque las operaciones `shift/arithmetic` entre listas no est\u00e1n permitidas en Python. Clusters Cluster le permite agrupar (o agrupar) los nodos en un grupo aislado. Cluster representa un contexto de cl\u00faster local. Puede crear un contexto de cl\u00faster con la clase Cluster . Y tambi\u00e9n puede conectar los nodos de un cl\u00faster a otros nodos fuera de un cl\u00faster. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS from diagrams.aws.database import RDS from diagrams.aws.network import Route53 with Diagram ( \"Simple Web Service with DB Cluster\" , show = False ) as cluster : dns = Route53 ( \"dns\" ) web = ECS ( \"service\" ) with Cluster ( \"DB Cluster\" ): db_master = RDS ( \"master\" ) db_master - [ RDS ( \"slave1\" ), RDS ( \"slave2\" )] dns >> web >> db_master cluster Nested Clusters Tambi\u00e9n es posible la agrupaci\u00f3n en cl\u00fasteres anidados. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS , EKS , Lambda from diagrams.aws.database import Redshift from diagrams.aws.integration import SQS from diagrams.aws.storage import S3 with Diagram ( \"Event Processing\" , show = False ) as cluster : source = EKS ( \"k8s source\" ) with Cluster ( \"Event Flows\" ): with Cluster ( \"Event Workers\" ): workers = [ ECS ( \"worker1\" ), ECS ( \"worker2\" ), ECS ( \"worker3\" )] queue = SQS ( \"event queue\" ) with Cluster ( \"Processing\" ): handlers = [ Lambda ( \"proc1\" ), Lambda ( \"proc2\" ), Lambda ( \"proc3\" )] store = S3 ( \"events store\" ) dw = Redshift ( \"analytics\" ) source >> workers >> queue >> handlers handlers >> store handlers >> dw cluster No hay l\u00edmite de profundidad de anidaci\u00f3n. Si\u00e9ntase libre de crear cl\u00fasteres anidados con la profundidad que desee. Edges Edge representa un borde entre nodos. Edge es un objeto que representa una conexi\u00f3n entre nodos con algunas propiedades adicionales. Un objeto Edge contiene tres atributos: etiqueta, color y estilo que reflejan los atributos de borde de graphviz correspondientes. from diagrams import Cluster , Diagram , Edge from diagrams.onprem.analytics import Spark from diagrams.onprem.compute import Server from diagrams.onprem.database import PostgreSQL from diagrams.onprem.inmemory import Redis from diagrams.onprem.logging import Fluentd from diagrams.onprem.monitoring import Grafana , Prometheus from diagrams.onprem.network import Nginx from diagrams.onprem.queue import Kafka with Diagram ( name = \"Advanced Web Service with On-Premise (colored)\" , show = False ) as edges : ingress = Nginx ( \"ingress\" ) metrics = Prometheus ( \"metric\" ) metrics << Edge ( color = \"firebrick\" , style = \"dashed\" ) << Grafana ( \"monitoring\" ) with Cluster ( \"Service Cluster\" ): grpcsvc = [ Server ( \"grpc1\" ), Server ( \"grpc2\" ), Server ( \"grpc3\" )] with Cluster ( \"Sessions HA\" ): master = Redis ( \"session\" ) master - Edge ( color = \"brown\" , style = \"dashed\" ) - Redis ( \"replica\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"brown\" ) >> master with Cluster ( \"Database HA\" ): master = PostgreSQL ( \"users\" ) master - Edge ( color = \"brown\" , style = \"dotted\" ) - PostgreSQL ( \"slave\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"black\" ) >> master aggregator = Fluentd ( \"logging\" ) aggregator >> Edge ( label = \"parse\" ) >> Kafka ( \"stream\" ) >> Edge ( color = \"black\" , style = \"bold\" ) >> Spark ( \"analytics\" ) ingress >> Edge ( color = \"darkgreen\" ) << grpcsvc >> Edge ( color = \"darkorange\" ) >> aggregator edges Warning: Orthogonal edges do not currently handle edge labels. Try using xlabels. Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. ! rm - r *. png *. jpg diagram . py rm: cannot remove '*.jpg': No such file or directory","title":"Diagrams"},{"location":"ecosystem/diagrams/#diagrams","text":"","title":"Diagrams"},{"location":"ecosystem/diagrams/#introduccion","text":"Naci\u00f3 para crear prototipos de una nueva arquitectura de sistema sin herramientas de dise\u00f1o. Tambi\u00e9n puede describir o visualizar la arquitectura del sistema existente. Diagram as Code le permite rastrear los cambios del diagrama de arquitectura en cualquier sistema de control de versiones. Actualmente, Diagrams admite seis proveedores principales: AWS , Azure , GCP , Kubernetes , Alibaba Cloud y Oracle Cloud . Ahora tambi\u00e9n admite nodos On-Premise , as\u00ed como Lenguajes de Programaci\u00f3n y Frameworks .","title":"Introducci\u00f3n"},{"location":"ecosystem/diagrams/#instalacion","text":"Python 3.6 o superior Instalar Graphviz Instalar la librer\u00eda diagrams : # using pip (pip3) $ pip install diagrams # using pipenv $ pipenv install diagrams # using poetry $ poetry add diagrams","title":"Instalaci\u00f3n"},{"location":"ecosystem/diagrams/#tipos-de-componentes","text":"La biblioteca de diagramas proporciona componentes para varios proveedores diferentes. Lo siguiente probablemente ser\u00e1 m\u00e1s relevante para la mayor\u00eda de los casos de uso de los 14 disponibles.","title":"Tipos de componentes"},{"location":"ecosystem/diagrams/#awsgcpazure","text":"Estos proveedores exponen los activos oficiales del servicio en la nube que usar\u00eda para cualquier diagrama que aproveche uno de los principales proveedores de la nube.","title":"AWS/GCP/Azure"},{"location":"ecosystem/diagrams/#generic-and-on-premise","text":"Estos nodos probablemente se usar\u00e1n juntos en el caso de que desee ilustrar las tecnolog\u00edas subyacentes de una manera independiente de la nube. Por ejemplo, proporcionar una arquitectura con un componente Beam sobre la pantalla Google DataFlow.","title":"Generic and On-Premise"},{"location":"ecosystem/diagrams/#frameworks","text":"Estos componentes ser\u00e1n \u00fatiles si desea ilustrar un nodo con un lenguaje de programaci\u00f3n.","title":"Frameworks"},{"location":"ecosystem/diagrams/#saas","text":"Existe una colecci\u00f3n de nodos SaaS que se pueden usar, lo que resulta \u00fatil cuando desea mostrar que su arquitectura tiene notificaciones que llegan a algo como Slack.","title":"SaaS"},{"location":"ecosystem/diagrams/#conceptos","text":"","title":"Conceptos"},{"location":"ecosystem/diagrams/#diagrama","text":"Diagram es el objeto principal que representa un diagrama.. El objeto Diagram representa un contexto de diagrama global. Puede crear un contexto de diagrama con la clase Diagram . El primer par\u00e1metro del constructor Diagram se utilizar\u00e1 para el nombre del archivo de salida. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" ): EC2 ( \"web\" ) Y si ejecuta el script anterior con el siguiente comando, $ python diagram.py Generar\u00e1 un archivo de imagen con un solo nodo EC2 dibujado como simple_diagram.png en su directorio de trabajo, y abrir\u00e1 ese archivo de imagen creado inmediatamente.","title":"Diagrama"},{"location":"ecosystem/diagrams/#jupyter-notebooks","text":"Diagram tambi\u00e9n se pueden renderizar directamente dentro del Jupyter de la siguiente manera: from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as diagram : EC2 ( \"web\" ) diagram","title":"Jupyter notebooks"},{"location":"ecosystem/diagrams/#opciones","text":"Puede especificar el formato del archivo de salida con el par\u00e1metro outformat . El valor predeterminado es png . (png, jpg, svg, y pdf) son soportados. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , outformat = \"jpg\" ): EC2 ( \"web\" ) Overwriting diagram.py Puede especificar el nombre del archivo de salida con el par\u00e1metro de filename . La extensi\u00f3n no debe incluirse, est\u00e1 determinada por el par\u00e1metro outformat . %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , filename = \"my_diagram\" ): EC2 ( \"web\" ) Overwriting diagram.py Tambi\u00e9n puede deshabilitar la apertura autom\u00e1tica de archivos configurando el par\u00e1metro show como False . El valor predeterminado es True . %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ): EC2 ( \"web\" ) Overwriting diagram.py Permite opciones personalizadas de atributos de puntos de Graphviz . `graph_attr`, `node_attr` y `edge_attr` son soportados. %% writefile diagram . py from diagrams import Diagram from diagrams.aws.compute import EC2 graph_attr = { \"fontsize\" : \"45\" , \"bgcolor\" : \"transparent\" } with Diagram ( \"Simple Diagram\" , show = False , graph_attr = graph_attr ): EC2 ( \"web\" ) Overwriting diagram.py","title":"Opciones"},{"location":"ecosystem/diagrams/#nodes","text":"Node es un segundo objeto que representa un nodo o componente del sistema. Node es un concepto abstracto que representa un \u00fanico objeto componente del sistema. Un objeto Node consta de tres partes: proveedor, tipo de recurso y nombre. Es posible que ya haya visto cada parte en el ejemplo anterior. from diagrams import Diagram from diagrams.aws.compute import EC2 with Diagram ( \"Simple Diagram\" , show = False ) as dj : EC2 ( \"web\" ) En el ejemplo anterior, EC2 es un nodo de tipo de recurso inform\u00e1tico proporcionado por el proveedor de AWS . Puede usar otros objetos Node de manera similar como: # aws resources from diagrams.aws.compute import ECS , Lambda from diagrams.aws.database import RDS , ElastiCache from diagrams.aws.network import ELB , Route53 , VPC ... # azure resources from diagrams.azure.compute import FunctionApps from diagrams.azure.storage import BlobStorage ... # alibaba cloud resources from diagrams.alibabacloud.compute import ECS from diagrams.alibabacloud.storage import ObjectTableStore ... # gcp resources from diagrams.gcp.compute import AppEngine , GKE from diagrams.gcp.ml import AutoML ... # k8s resources from diagrams.k8s.compute import Pod , StatefulSet from diagrams.k8s.network import Service from diagrams.k8s.storage import PV , PVC , StorageClass ... # oracle resources from diagrams.oci.compute import VirtualMachine , Container from diagrams.oci.network import Firewall from diagrams.oci.storage import Filestorage , Storagegateway","title":"Nodes"},{"location":"ecosystem/diagrams/#data-flow","text":"Puede representar el flujo de datos conectando los nodos con estos operadores: >> : Conecta los nodos de izquierda a derecha. << : Conecta los nodos de derecha a izquierda. - : Conecta nodos en ninguna direcci\u00f3n. No dirigido. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB from diagrams.aws.storage import S3 with Diagram ( \"Web Services\" , show = False ) as node : ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) >> S3 ( \"store\" ) ELB ( \"lb\" ) >> EC2 ( \"web\" ) >> RDS ( \"userdb\" ) << EC2 ( \"stat\" ) ( ELB ( \"lb\" ) >> EC2 ( \"web\" )) - EC2 ( \"web\" ) >> RDS ( \"userdb\" ) node Tenga cuidado al usar `-` y cualquier operador de turno juntos, lo que podr\u00eda causar resultados inesperados debido a la precedencia del operador. El orden de los diagramas renderizados es el inverso del orden de declaraci\u00f3n. Puede cambiar la direcci\u00f3n del flujo de datos con el par\u00e1metro direction . El valor predeterminado es LR . (TB, BT, LR y RL) est\u00e1n permitidos. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Workers\" , show = False , direction = \"TB\" ) as node : lb = ELB ( \"lb\" ) db = RDS ( \"events\" ) lb >> EC2 ( \"worker1\" ) >> db lb >> EC2 ( \"worker2\" ) >> db lb >> EC2 ( \"worker3\" ) >> db lb >> EC2 ( \"worker4\" ) >> db lb >> EC2 ( \"worker5\" ) >> db node","title":"Data Flow"},{"location":"ecosystem/diagrams/#group-data-flow","text":"El ejemplo del worker anterior tiene demasiados flujos redundantes. En este caso, puede agrupar nodos en una lista para que todos los nodos est\u00e9n conectados a otros nodos a la vez. from diagrams import Diagram from diagrams.aws.compute import EC2 from diagrams.aws.database import RDS from diagrams.aws.network import ELB with Diagram ( \"Grouped Workers\" , show = False , direction = \"TB\" ) as node : ELB ( \"lb\" ) >> [ EC2 ( \"worker1\" ), EC2 ( \"worker2\" ), EC2 ( \"worker3\" ), EC2 ( \"worker4\" ), EC2 ( \"worker5\" )] >> RDS ( \"events\" ) node No puede conectar dos listas directamente porque las operaciones `shift/arithmetic` entre listas no est\u00e1n permitidas en Python.","title":"Group Data Flow"},{"location":"ecosystem/diagrams/#clusters","text":"Cluster le permite agrupar (o agrupar) los nodos en un grupo aislado. Cluster representa un contexto de cl\u00faster local. Puede crear un contexto de cl\u00faster con la clase Cluster . Y tambi\u00e9n puede conectar los nodos de un cl\u00faster a otros nodos fuera de un cl\u00faster. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS from diagrams.aws.database import RDS from diagrams.aws.network import Route53 with Diagram ( \"Simple Web Service with DB Cluster\" , show = False ) as cluster : dns = Route53 ( \"dns\" ) web = ECS ( \"service\" ) with Cluster ( \"DB Cluster\" ): db_master = RDS ( \"master\" ) db_master - [ RDS ( \"slave1\" ), RDS ( \"slave2\" )] dns >> web >> db_master cluster","title":"Clusters"},{"location":"ecosystem/diagrams/#nested-clusters","text":"Tambi\u00e9n es posible la agrupaci\u00f3n en cl\u00fasteres anidados. from diagrams import Cluster , Diagram from diagrams.aws.compute import ECS , EKS , Lambda from diagrams.aws.database import Redshift from diagrams.aws.integration import SQS from diagrams.aws.storage import S3 with Diagram ( \"Event Processing\" , show = False ) as cluster : source = EKS ( \"k8s source\" ) with Cluster ( \"Event Flows\" ): with Cluster ( \"Event Workers\" ): workers = [ ECS ( \"worker1\" ), ECS ( \"worker2\" ), ECS ( \"worker3\" )] queue = SQS ( \"event queue\" ) with Cluster ( \"Processing\" ): handlers = [ Lambda ( \"proc1\" ), Lambda ( \"proc2\" ), Lambda ( \"proc3\" )] store = S3 ( \"events store\" ) dw = Redshift ( \"analytics\" ) source >> workers >> queue >> handlers handlers >> store handlers >> dw cluster No hay l\u00edmite de profundidad de anidaci\u00f3n. Si\u00e9ntase libre de crear cl\u00fasteres anidados con la profundidad que desee.","title":"Nested Clusters"},{"location":"ecosystem/diagrams/#edges","text":"Edge representa un borde entre nodos. Edge es un objeto que representa una conexi\u00f3n entre nodos con algunas propiedades adicionales. Un objeto Edge contiene tres atributos: etiqueta, color y estilo que reflejan los atributos de borde de graphviz correspondientes. from diagrams import Cluster , Diagram , Edge from diagrams.onprem.analytics import Spark from diagrams.onprem.compute import Server from diagrams.onprem.database import PostgreSQL from diagrams.onprem.inmemory import Redis from diagrams.onprem.logging import Fluentd from diagrams.onprem.monitoring import Grafana , Prometheus from diagrams.onprem.network import Nginx from diagrams.onprem.queue import Kafka with Diagram ( name = \"Advanced Web Service with On-Premise (colored)\" , show = False ) as edges : ingress = Nginx ( \"ingress\" ) metrics = Prometheus ( \"metric\" ) metrics << Edge ( color = \"firebrick\" , style = \"dashed\" ) << Grafana ( \"monitoring\" ) with Cluster ( \"Service Cluster\" ): grpcsvc = [ Server ( \"grpc1\" ), Server ( \"grpc2\" ), Server ( \"grpc3\" )] with Cluster ( \"Sessions HA\" ): master = Redis ( \"session\" ) master - Edge ( color = \"brown\" , style = \"dashed\" ) - Redis ( \"replica\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"brown\" ) >> master with Cluster ( \"Database HA\" ): master = PostgreSQL ( \"users\" ) master - Edge ( color = \"brown\" , style = \"dotted\" ) - PostgreSQL ( \"slave\" ) << Edge ( label = \"collect\" ) << metrics grpcsvc >> Edge ( color = \"black\" ) >> master aggregator = Fluentd ( \"logging\" ) aggregator >> Edge ( label = \"parse\" ) >> Kafka ( \"stream\" ) >> Edge ( color = \"black\" , style = \"bold\" ) >> Spark ( \"analytics\" ) ingress >> Edge ( color = \"darkgreen\" ) << grpcsvc >> Edge ( color = \"darkorange\" ) >> aggregator edges Warning: Orthogonal edges do not currently handle edge labels. Try using xlabels. Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. ! rm - r *. png *. jpg diagram . py rm: cannot remove '*.jpg': No such file or directory","title":"Edges"},{"location":"ecosystem/loguru/","text":"Loguru Introducci\u00f3n Python incluye un pr\u00e1ctico m\u00f3dulo de logging . Tanto para efectuar una depuraci\u00f3n sencilla como para realizar un registro centralizado desde diversos servidores, el m\u00f3dulo logging de Python puede facilitar enormemente el trabajo a los desarrolladores y operadores. Logging proviene del t\u00e9rmino en ingl\u00e9s \u201clog\u02ee y, en este contexto, se refiere a un protocolo. Al igual que un libro de registro, contiene todos los registros importantes del historial de eventos. Dependiendo del tipo de seguimiento que queramos hacer, solo se registran ciertas acciones o eventos de un proceso o, por el contrario, se comprueban todas las acciones. El registro de Python puede contener una gran cantidad de datos, especialmente al desarrollar aplicaciones complejas. Mediante el logging to file de Python (es decir, un archivo de registro creado por el m\u00f3dulo logging de Python y en el que un handler anota los datos de registro), los desarrolladores recopilan estos datos. Es importante que el archivo de registro funcione de forma asincr\u00f3nica. De lo contrario, el logging de Python puede bloquear la ejecuci\u00f3n del c\u00f3digo. An\u00e1lisis de errores El logging de Python presenta cinco niveles de gravedad distintos, que en ingl\u00e9s reciben el nombre de \u201clevels of severity\u02ee. Si deseas crear tu propio filtro de registro, obviamente puedes hacerlo, aunque los niveles de gravedad incluidos en el m\u00f3dulo logging de Python, desarrollado por Vinay Sajip , nos parecen bastante adecuados: Nombre del nivel de registro Uso Posible salida de mensaje Debug Diagn\u00f3stico del problema, muy detallado Sangr\u00eda inesperada en la l\u00ednea X Info Indica que el sistema funciona correctamente La funci\u00f3n 1*1 est\u00e1 ejecut\u00e1ndose. Warning La aplicaci\u00f3n funciona correctamente, pero se ha producido una situaci\u00f3n inesperada o se predice un problema futuro. Poco espacio de almacenamiento Error No se pudo realizar una funci\u00f3n debido a un problema. Ha ocurrido un error y se ha interrumpido la acci\u00f3n. Critical Ha ocurrido un problema grave. Es posible que la aplicaci\u00f3n deba interrumpirse por completo. Error grave: el programa no puede acceder a este servicio y debe cerrarse. Debug es el nivel m\u00e1s bajo, por lo que tambi\u00e9n genera informaci\u00f3n de baja prioridad. Esto no significa, sin embargo, que la gravedad de un error sea superior a la de critical. Debug incluye todos los dem\u00e1s niveles y, por lo tanto, genera todos los mensajes hasta los de nivel critical. Componenetes principales del m\u00f3dulo logging a) Logger Los logger registran las acciones durante la ejecuci\u00f3n de un programa . No se pueden usar directamente como instancia, sino que se los solicita con la funci\u00f3n logging.getLogger (nombre del logger). Se asigna un nombre concreto al logger, por ejemplo, para mostrar las jerarqu\u00edas de una manera estructurada. En Python, los directorios de los paquetes se separan con un punto. Por lo tanto, el paquete log puede contener los directorios log.bam o log.bar.loco . Los logger funcionan de manera an\u00e1loga, de modo que, en este caso, el objeto log recibir\u00e1 los datos de los directorios log.bam y log.bar.loco . b) Handler Los handler recopilan la informaci\u00f3n del logger y la reenv\u00edan. El handler es una clase b\u00e1sica que determina c\u00f3mo act\u00faa la interfaz de las instancias del handler. Para establecer el destino, debes utilizar el tipo de handler correspondiente. StreamHandler env\u00eda los datos a las secuencias, mientras que FileHandler los env\u00eda a los archivos. Para un programa, puedes utilizar varios handler que env\u00eden mensajes del mismo logger. Esto te puede ser \u00fatil, por ejemplo, si deseas mostrar los datos de depuraci\u00f3n en la consola y los mensajes de error importantes en un archivo independiente. Mediante el m\u00e9todo setLevel() puedes establecer el nivel m\u00ednimo de gravedad que un mensaje de registro requiere para ser reenviado a dicho handler. En lugar de logger.setLevel (que determina el nivel de registro), el m\u00e9todo recibe el nombre de [handlername].setLevel c) Formatter Los formatter (objetos de formato), a diferencia de los handler, se pueden utilizar directamente como instancias en el c\u00f3digo de la aplicaci\u00f3n . Con estas instancias puedes determinar el formato en el que se emitir\u00e1 la notificaci\u00f3n en el archivo de registro. Si no utilizas ning\u00fan formato, solo aparecer\u00e1 el mensaje especificado del logger. d) Filter Los filter permiten crear definiciones a\u00fan m\u00e1s precisas para los mensajes de salida. Establece primero los filtros y, despu\u00e9s, a\u00f1\u00e1delos al handler o al logger correspondiente mediante el m\u00e9todo addFilter() . Si el valor de un filtro es false (err\u00f3neo) debido a las propiedades del mensaje, no reenviar\u00e1 el mensaje. Utiliza la funci\u00f3n logging.Filter(name = fh) , donde el atributo fh representa cualquier nombre de logger, para permitir que se env\u00eden \u00fanicamente los datos de registro de un logger concreto y bloquear todos los dem\u00e1s logger. Logging con Loguru Loguru es una biblioteca que tiene como objetivo brindar un logging agradable en Python. Adem\u00e1s, esta biblioteca est\u00e1 destinada a hacer que el registro de Python sea menos doloroso al agregar un mont\u00f3n de funcionalidades \u00fatiles que resuelven las advertencias de los loggers est\u00e1ndar. Usar logs en su aplicaci\u00f3n deber\u00eda ser un automatismo, Loguru intenta hacerlo agradable y poderoso. F\u00e1cil de usar El concepto principal de \"Loguru\" es que hay uno y solo uno logger . Para mayor comodidad, est\u00e1 preconfigurado y se env\u00eda a stderr para empezar (pero eso es completamente configurable). %% python from loguru import logger logger . debug ( \"That's it, beautiful and simple logging!\" ) 2020-09-29 15:17:28.833 | DEBUG | __main__:<module>:2 - That's it, beautiful and simple logging! No Handler, no Formatter, no Filter: todo en uno \u00bfC\u00f3mo agregar un Handler? \u00bfC\u00f3mo configurar el formato de los registros? \u00bfC\u00f3mo filtrar mensajes? \u00bfC\u00f3mo poner el nivel?. Una respuesta: la funci\u00f3n add() . %% python from loguru import logger import sys logger . add ( sys . stderr , format = \" {time} {level} {message} \" , filter = \"my_module\" , level = \"INFO\" ) Esta funci\u00f3n debe usarse para registrar los sink , responsables de administrar los log messages contextualizados con un record dict . Un sink puede tomar muchas formas: una funci\u00f3n simple, una ruta de cadena, un objeto similar a un archivo, una funci\u00f3n de rutina o un controlador integrado (built-in Handler). Registro de archivos m\u00e1s f\u00e1cil con rotation / retention / compression Si desea enviar mensajes registrados a un archivo, solo tiene que usar una ruta de cadena como sink . Tambi\u00e9n se puede programar autom\u00e1ticamente para mayor comodidad: %% python from loguru import logger logger . add ( \"file_ {time} .log\" ) Tambi\u00e9n es f\u00e1cilmente configurable si necesita un registrador giratorio (rotating logger), si desea eliminar registros m\u00e1s antiguos o si desea comprimir sus archivos al cierre. %% python from loguru import logger logger . add ( \"file_1.log\" , rotation = \"500 MB\" ) # Automatically rotate too big file logger . add ( \"file_2.log\" , rotation = \"12:00\" ) # New file is created each day at noon logger . add ( \"file_3.log\" , rotation = \"1 week\" ) # Once the file is too old, it's rotated logger . add ( \"file_X.log\" , retention = \"10 days\" ) # Cleanup after some time logger . add ( \"file_Y.log\" , compression = \"zip\" ) # Save some loved space Captura de excepciones dentro threads o main \u00bfAlguna vez ha visto su programa fallar inesperadamente sin ver nada en el archivo de registro? \u00bfAlguna vez not\u00f3 que las excepciones que ocurren en los hilos no se registran? Esto se puede resolver usando el decorador/administrador de contexto catch que asegura que cualquier error se propague correctamente al logger . %% python from loguru import logger @logger . catch def my_function ( x , y , z ): # An error? It's caught anyway! return 1 / ( x + y + z ) Hermosos logging con colores Loguru agrega autom\u00e1ticamente colores a sus registros si su terminal es compatible. Puede definir su estilo favorito utilizando etiquetas de marcado en el formato sink . %% python from loguru import logger import sys logger . add ( sys . stdout , colorize = True , format = \"<green> {time} </green> <level> {message} </level>\" ) Las funciones de corrutina utilizadas como sink tambi\u00e9n son compatibles y se deben esperar con complete() . Excepciones completamente descriptivas Registrar las excepciones que ocurren en su c\u00f3digo es importante para rastrear errores, pero es bastante in\u00fatil si no sabe por qu\u00e9 fall\u00f3. Loguru te ayuda a identificar problemas al permitir que se muestre todo el seguimiento de la pila ( stack ), incluidos los valores de las variables (\u00a1gracias better_exceptions por esto!). %% python from loguru import logger logger . add ( \"out.log\" , backtrace = True , diagnose = True ) # Caution, may leak sensitive data in prod def func ( a , b ): return a / b def nested ( c ): try : func ( 5 , c ) except ZeroDivisionError : logger . exception ( \"What?!\" ) nested ( 0 ) 2020-09-29 15:17:33.143 | ERROR | __main__:nested:12 - What?! Traceback (most recent call last): File \"<stdin>\", line 14, in <module> > File \"<stdin>\", line 10, in nested File \"<stdin>\", line 6, in func ZeroDivisionError: division by zero Mejor manejo de fecha y hora el logger est\u00e1ndar est\u00e1 repleto de argumentos como datefmt o msecs , %(asctime)s y %(created)s , fechas y horas ingenuas sin informaci\u00f3n de zona horaria, formato no intuitivo, etc. Loguru lo corrige: %% python from loguru import logger import sys logger . add ( \"file.log\" , format = \"{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message} \" ) Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. log *. zip","title":"Loguru"},{"location":"ecosystem/loguru/#loguru","text":"","title":"Loguru"},{"location":"ecosystem/loguru/#introduccion","text":"Python incluye un pr\u00e1ctico m\u00f3dulo de logging . Tanto para efectuar una depuraci\u00f3n sencilla como para realizar un registro centralizado desde diversos servidores, el m\u00f3dulo logging de Python puede facilitar enormemente el trabajo a los desarrolladores y operadores. Logging proviene del t\u00e9rmino en ingl\u00e9s \u201clog\u02ee y, en este contexto, se refiere a un protocolo. Al igual que un libro de registro, contiene todos los registros importantes del historial de eventos. Dependiendo del tipo de seguimiento que queramos hacer, solo se registran ciertas acciones o eventos de un proceso o, por el contrario, se comprueban todas las acciones. El registro de Python puede contener una gran cantidad de datos, especialmente al desarrollar aplicaciones complejas. Mediante el logging to file de Python (es decir, un archivo de registro creado por el m\u00f3dulo logging de Python y en el que un handler anota los datos de registro), los desarrolladores recopilan estos datos. Es importante que el archivo de registro funcione de forma asincr\u00f3nica. De lo contrario, el logging de Python puede bloquear la ejecuci\u00f3n del c\u00f3digo.","title":"Introducci\u00f3n"},{"location":"ecosystem/loguru/#analisis-de-errores","text":"El logging de Python presenta cinco niveles de gravedad distintos, que en ingl\u00e9s reciben el nombre de \u201clevels of severity\u02ee. Si deseas crear tu propio filtro de registro, obviamente puedes hacerlo, aunque los niveles de gravedad incluidos en el m\u00f3dulo logging de Python, desarrollado por Vinay Sajip , nos parecen bastante adecuados: Nombre del nivel de registro Uso Posible salida de mensaje Debug Diagn\u00f3stico del problema, muy detallado Sangr\u00eda inesperada en la l\u00ednea X Info Indica que el sistema funciona correctamente La funci\u00f3n 1*1 est\u00e1 ejecut\u00e1ndose. Warning La aplicaci\u00f3n funciona correctamente, pero se ha producido una situaci\u00f3n inesperada o se predice un problema futuro. Poco espacio de almacenamiento Error No se pudo realizar una funci\u00f3n debido a un problema. Ha ocurrido un error y se ha interrumpido la acci\u00f3n. Critical Ha ocurrido un problema grave. Es posible que la aplicaci\u00f3n deba interrumpirse por completo. Error grave: el programa no puede acceder a este servicio y debe cerrarse. Debug es el nivel m\u00e1s bajo, por lo que tambi\u00e9n genera informaci\u00f3n de baja prioridad. Esto no significa, sin embargo, que la gravedad de un error sea superior a la de critical. Debug incluye todos los dem\u00e1s niveles y, por lo tanto, genera todos los mensajes hasta los de nivel critical.","title":"An\u00e1lisis de errores"},{"location":"ecosystem/loguru/#componenetes-principales-del-modulo-logging","text":"","title":"Componenetes principales del m\u00f3dulo logging"},{"location":"ecosystem/loguru/#a-logger","text":"Los logger registran las acciones durante la ejecuci\u00f3n de un programa . No se pueden usar directamente como instancia, sino que se los solicita con la funci\u00f3n logging.getLogger (nombre del logger). Se asigna un nombre concreto al logger, por ejemplo, para mostrar las jerarqu\u00edas de una manera estructurada. En Python, los directorios de los paquetes se separan con un punto. Por lo tanto, el paquete log puede contener los directorios log.bam o log.bar.loco . Los logger funcionan de manera an\u00e1loga, de modo que, en este caso, el objeto log recibir\u00e1 los datos de los directorios log.bam y log.bar.loco .","title":"a) Logger"},{"location":"ecosystem/loguru/#b-handler","text":"Los handler recopilan la informaci\u00f3n del logger y la reenv\u00edan. El handler es una clase b\u00e1sica que determina c\u00f3mo act\u00faa la interfaz de las instancias del handler. Para establecer el destino, debes utilizar el tipo de handler correspondiente. StreamHandler env\u00eda los datos a las secuencias, mientras que FileHandler los env\u00eda a los archivos. Para un programa, puedes utilizar varios handler que env\u00eden mensajes del mismo logger. Esto te puede ser \u00fatil, por ejemplo, si deseas mostrar los datos de depuraci\u00f3n en la consola y los mensajes de error importantes en un archivo independiente. Mediante el m\u00e9todo setLevel() puedes establecer el nivel m\u00ednimo de gravedad que un mensaje de registro requiere para ser reenviado a dicho handler. En lugar de logger.setLevel (que determina el nivel de registro), el m\u00e9todo recibe el nombre de [handlername].setLevel","title":"b) Handler"},{"location":"ecosystem/loguru/#c-formatter","text":"Los formatter (objetos de formato), a diferencia de los handler, se pueden utilizar directamente como instancias en el c\u00f3digo de la aplicaci\u00f3n . Con estas instancias puedes determinar el formato en el que se emitir\u00e1 la notificaci\u00f3n en el archivo de registro. Si no utilizas ning\u00fan formato, solo aparecer\u00e1 el mensaje especificado del logger.","title":"c) Formatter"},{"location":"ecosystem/loguru/#d-filter","text":"Los filter permiten crear definiciones a\u00fan m\u00e1s precisas para los mensajes de salida. Establece primero los filtros y, despu\u00e9s, a\u00f1\u00e1delos al handler o al logger correspondiente mediante el m\u00e9todo addFilter() . Si el valor de un filtro es false (err\u00f3neo) debido a las propiedades del mensaje, no reenviar\u00e1 el mensaje. Utiliza la funci\u00f3n logging.Filter(name = fh) , donde el atributo fh representa cualquier nombre de logger, para permitir que se env\u00eden \u00fanicamente los datos de registro de un logger concreto y bloquear todos los dem\u00e1s logger.","title":"d) Filter"},{"location":"ecosystem/loguru/#logging-con-loguru","text":"Loguru es una biblioteca que tiene como objetivo brindar un logging agradable en Python. Adem\u00e1s, esta biblioteca est\u00e1 destinada a hacer que el registro de Python sea menos doloroso al agregar un mont\u00f3n de funcionalidades \u00fatiles que resuelven las advertencias de los loggers est\u00e1ndar. Usar logs en su aplicaci\u00f3n deber\u00eda ser un automatismo, Loguru intenta hacerlo agradable y poderoso.","title":"Logging con Loguru"},{"location":"ecosystem/loguru/#facil-de-usar","text":"El concepto principal de \"Loguru\" es que hay uno y solo uno logger . Para mayor comodidad, est\u00e1 preconfigurado y se env\u00eda a stderr para empezar (pero eso es completamente configurable). %% python from loguru import logger logger . debug ( \"That's it, beautiful and simple logging!\" ) 2020-09-29 15:17:28.833 | DEBUG | __main__:<module>:2 - That's it, beautiful and simple logging!","title":"F\u00e1cil de usar"},{"location":"ecosystem/loguru/#no-handler-no-formatter-no-filter-todo-en-uno","text":"\u00bfC\u00f3mo agregar un Handler? \u00bfC\u00f3mo configurar el formato de los registros? \u00bfC\u00f3mo filtrar mensajes? \u00bfC\u00f3mo poner el nivel?. Una respuesta: la funci\u00f3n add() . %% python from loguru import logger import sys logger . add ( sys . stderr , format = \" {time} {level} {message} \" , filter = \"my_module\" , level = \"INFO\" ) Esta funci\u00f3n debe usarse para registrar los sink , responsables de administrar los log messages contextualizados con un record dict . Un sink puede tomar muchas formas: una funci\u00f3n simple, una ruta de cadena, un objeto similar a un archivo, una funci\u00f3n de rutina o un controlador integrado (built-in Handler).","title":"No Handler, no Formatter, no Filter: todo en uno"},{"location":"ecosystem/loguru/#registro-de-archivos-mas-facil-con-rotation-retention-compression","text":"Si desea enviar mensajes registrados a un archivo, solo tiene que usar una ruta de cadena como sink . Tambi\u00e9n se puede programar autom\u00e1ticamente para mayor comodidad: %% python from loguru import logger logger . add ( \"file_ {time} .log\" ) Tambi\u00e9n es f\u00e1cilmente configurable si necesita un registrador giratorio (rotating logger), si desea eliminar registros m\u00e1s antiguos o si desea comprimir sus archivos al cierre. %% python from loguru import logger logger . add ( \"file_1.log\" , rotation = \"500 MB\" ) # Automatically rotate too big file logger . add ( \"file_2.log\" , rotation = \"12:00\" ) # New file is created each day at noon logger . add ( \"file_3.log\" , rotation = \"1 week\" ) # Once the file is too old, it's rotated logger . add ( \"file_X.log\" , retention = \"10 days\" ) # Cleanup after some time logger . add ( \"file_Y.log\" , compression = \"zip\" ) # Save some loved space","title":"Registro de archivos m\u00e1s f\u00e1cil con rotation / retention / compression"},{"location":"ecosystem/loguru/#captura-de-excepciones-dentro-threads-o-main","text":"\u00bfAlguna vez ha visto su programa fallar inesperadamente sin ver nada en el archivo de registro? \u00bfAlguna vez not\u00f3 que las excepciones que ocurren en los hilos no se registran? Esto se puede resolver usando el decorador/administrador de contexto catch que asegura que cualquier error se propague correctamente al logger . %% python from loguru import logger @logger . catch def my_function ( x , y , z ): # An error? It's caught anyway! return 1 / ( x + y + z )","title":"Captura de excepciones dentro threads o  main"},{"location":"ecosystem/loguru/#hermosos-logging-con-colores","text":"Loguru agrega autom\u00e1ticamente colores a sus registros si su terminal es compatible. Puede definir su estilo favorito utilizando etiquetas de marcado en el formato sink . %% python from loguru import logger import sys logger . add ( sys . stdout , colorize = True , format = \"<green> {time} </green> <level> {message} </level>\" ) Las funciones de corrutina utilizadas como sink tambi\u00e9n son compatibles y se deben esperar con complete() .","title":"Hermosos logging con colores"},{"location":"ecosystem/loguru/#excepciones-completamente-descriptivas","text":"Registrar las excepciones que ocurren en su c\u00f3digo es importante para rastrear errores, pero es bastante in\u00fatil si no sabe por qu\u00e9 fall\u00f3. Loguru te ayuda a identificar problemas al permitir que se muestre todo el seguimiento de la pila ( stack ), incluidos los valores de las variables (\u00a1gracias better_exceptions por esto!). %% python from loguru import logger logger . add ( \"out.log\" , backtrace = True , diagnose = True ) # Caution, may leak sensitive data in prod def func ( a , b ): return a / b def nested ( c ): try : func ( 5 , c ) except ZeroDivisionError : logger . exception ( \"What?!\" ) nested ( 0 ) 2020-09-29 15:17:33.143 | ERROR | __main__:nested:12 - What?! Traceback (most recent call last): File \"<stdin>\", line 14, in <module> > File \"<stdin>\", line 10, in nested File \"<stdin>\", line 6, in func ZeroDivisionError: division by zero","title":"Excepciones completamente descriptivas"},{"location":"ecosystem/loguru/#mejor-manejo-de-fecha-y-hora","text":"el logger est\u00e1ndar est\u00e1 repleto de argumentos como datefmt o msecs , %(asctime)s y %(created)s , fechas y horas ingenuas sin informaci\u00f3n de zona horaria, formato no intuitivo, etc. Loguru lo corrige: %% python from loguru import logger import sys logger . add ( \"file.log\" , format = \"{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message} \" ) Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. log *. zip","title":"Mejor manejo de fecha y hora"},{"location":"ecosystem/plantuml/","text":"PlantUML Introducci\u00f3n PlantUML es una herramienta de dibujo de diagramas. Soporta varios de los diagramas m\u00e1s usados. Entre ellos destacan: Diagramas de Secuencia Diagramas de Clases Diagramas de Estados Diagramas de Actividad Una de sus ventajas es que se puede integrar con una gran cantidad de aplicaciones. Otra de sus ventajas es la simplicidad e intuitividad de su sintaxis, por ejemplo, para hacer una flecha en un diagrama de secuencia se usa \u201c->\u201d; si se necesita una flecha discontinua se usar\u00eda \u201c\u2013>\u00bb; una relaci\u00f3n de herencia en un diagrama de clases \u201c<|--\u201d. Es importante recordar que es una herramienta de dibujo. Esto quiere decir que es posible dibujar diagramas inconsistentes si no se tiene algo de cuidado. Instalaci\u00f3n Instalar Graphviz . Es necesario para poder generar la mayor\u00eda de los diagramas. Instalar plantuml. En un sistema basado en Debian, puede instalar el paquete plantuml. De lo contrario, puede descargar plantuml.jar y copiarlo en /usr/local/bin/plantuml.jar . Para correr estos ejemplos en jupyter notebook, debemos intalar iplantuml . Ejemplos Diagramas de secuencia Comencemos, pues, a dibujar. Lo principal es empezar cada uno de nuestros diagramas con @startuml y terminarlos con @enduml. Veremos mediante ejemplos qu\u00e9 cosas se pueden hacer con esta herramienta, desde algo sencillo a algo m\u00e1s complejo. La complejidad y el tama\u00f1o de los diagramas puede ser atroz. Por si os quer\u00e9is hacer una idea, en la documentaci\u00f3n se habla de un problema de memoria para diagramas de mas de 20000 x 10000px, pudi\u00e9ndose arreglar aumentando la memoria que usa la JVM. Nosotros no vamos a llegar a tanto, empezamos con un diagrama sencillo tal que as\u00ed: import iplantuml %% plantuml @startuml Juan -> Paco : saluda Juan <-- Paco : responde Juan -> Jes\u00fas : saluda Juan <-- Jes\u00fas : responde @enduml Tambi\u00e9n podemos declarar distintos participantes en el diagrama, como un actor (el monigote de los diagramas) o una base de datos, entre otros. Incluso a\u00f1adir notas, o cambiar la apariencia de todo. Completando el ejemplo anterior\u2026 (lo siento Jes\u00fas, te he convertido en baseDeDatos) %% plantuml @startuml actor Juan database baseDeDatos #green Juan -> baseDeDatos : saludas note right : cortes\u00eda Juan <-- baseDeDatos : responde Juan -> Paco : saluda Paco -> Paco : \u00bf c\u00f3mo se \\ nllamaba \\ neste t\u00edo ? Juan <-- Paco : responde @enduml Como podemos ver, las posibilidades se hacen enormes seg\u00fan descubrimos nuevos elementos que a\u00f1adir en nuestros diagramas, as\u00ed como formas de combinarlos. En el siguiente c\u00f3digo podemos ver una muestra de las posibilidades: %% plantuml @startuml == Comienzo == Elemento1 - X Elemento2 Elemento2 - [ #0000FF]-\\ Elemento1 Elemento2 <-> Elemento1 == Final == Elemento1 -> o Elemento2 @enduml Con esto terminamos con los diagramas de secuencia, podemos hacernos una idea de las posibilidades. Diagramas de clases Lo siguientes diagramas que tenemos en la lista son los diagramas de clases, vamos a analizarlos. A continuaci\u00f3n exponemos las principales operaciones entre clases: Herencia, composici\u00f3n y agregaci\u00f3n. %% plantuml @startuml Clase1 <|-- Clase2 Clase1 <|-- Clase3 Clase4 *-- Clase5 Clase6 o -- Clase7 @enduml Como hemos hecho antes, ahora completamos el diagrama con m\u00e1s elementos para demostrar la potencia: nombres a las relaciones, m\u00e9todos, etc. %% plantuml @startuml class Clase1 { toString () } class Clase2 { String [] elementos mostrarElementos () } Clase1 <|-- Clase2 Clase1 <|-- Clase3 Clase4 \"1\" *-- \"n\" Clase5 : agregaci\u00f3n Clase6 o -- Clase7 @enduml Tenemos muchas m\u00e1s opciones para relacionar clases entre s\u00ed, m\u00e1s ejemplos: %% plantuml @startuml Clase1 .. Clase2 Clase1 -- Clase3 Clase3 --> Clase4 Clase4 <|.. Clase5 Clase6 ..> Clase7 Clase7 ..|> Clase8 Clase8 <--* Clase9 @enduml Para acabar con este tipo de diagramas, vamos a hablar de la visibilidad de m\u00e9todos y atributos, as\u00ed como la posibilidad de trabajar con interfaces o clases abstractas, dejando muchas cosas en el tintero para que pod\u00e1is investigar (y no os de tanta pereza leer un art\u00edculo tan largo). %% plantuml @startuml abstract Abstracta { - privado #protected ~ package_private () + public () } interface Interfaz { metodo () } enum TimeUnit { DIAS HORAS MINUTOS } class Clase2 #red Abstracta <|-- Clase2 Abstracta <|-- Clase3 Interfaz <|.. Clase4 Interfaz <|.. Clase5 @enduml Diagramas de estados Seguimos con los diagramas de estados de toda la vida, que simbolizan un esquema de transiciones entre diversos estados. %% plantuml @startuml [ * ] --> Nacimiento Nacimiento : sin preocupaciones Tropiezo : se li\u00f3 parda Nacimiento --> Tropiezo : torpeza Tropiezo -> Muerte : SAMUR no llega a tiempo Muerte --> [ * ] @enduml Se pueden tener adem\u00e1s estados compuestos. Completando el ejemplo anterior con un estado compuesto nos quedar\u00eda algo como lo siguiente: %% plantuml @startuml [ * ] --> Nacimiento Nacimiento : sin preocupaciones state Tropiezo { Agilidad : lo esquiva Torpeza : se lio parda } Nacimiento --> Tropiezo : torpeza Agilidad -> Vida : felicidad Torpeza -> Muerte : SAMUR no llega a tiempo Torpeza -> Vida : SAMUR llega a tiempo Vida --> Muerte Muerte --> [ * ] @enduml A grandes rasgos es todo para este tipo de diagramas. Se\u00f1alar que las flechas de transiciones entre estados se adaptan bastante bien a los elementos con los que puedan colisionar. Otros diagramas Agrupando componentes %% plantuml @startuml package \"Some Group\" { HTTP - [ First Component ] [ Another Component ] } node \"Other Groups\" { FTP - [ Second Component ] [ First Component ] --> FTP } cloud { [ Example 1 ] } database \"MySql\" { folder \"This is my folder\" { [ Folder 3 ] } frame \"Foo\" { [ Frame 4 ] } } [ Another Component ] --> [ Example 1 ] [ Example 1 ] --> [ Folder 3 ] [ Folder 3 ] --> [ Frame 4 ] @enduml","title":"Plantuml"},{"location":"ecosystem/plantuml/#plantuml","text":"","title":"PlantUML"},{"location":"ecosystem/plantuml/#introduccion","text":"PlantUML es una herramienta de dibujo de diagramas. Soporta varios de los diagramas m\u00e1s usados. Entre ellos destacan: Diagramas de Secuencia Diagramas de Clases Diagramas de Estados Diagramas de Actividad Una de sus ventajas es que se puede integrar con una gran cantidad de aplicaciones. Otra de sus ventajas es la simplicidad e intuitividad de su sintaxis, por ejemplo, para hacer una flecha en un diagrama de secuencia se usa \u201c->\u201d; si se necesita una flecha discontinua se usar\u00eda \u201c\u2013>\u00bb; una relaci\u00f3n de herencia en un diagrama de clases \u201c<|--\u201d. Es importante recordar que es una herramienta de dibujo. Esto quiere decir que es posible dibujar diagramas inconsistentes si no se tiene algo de cuidado.","title":"Introducci\u00f3n"},{"location":"ecosystem/plantuml/#instalacion","text":"Instalar Graphviz . Es necesario para poder generar la mayor\u00eda de los diagramas. Instalar plantuml. En un sistema basado en Debian, puede instalar el paquete plantuml. De lo contrario, puede descargar plantuml.jar y copiarlo en /usr/local/bin/plantuml.jar . Para correr estos ejemplos en jupyter notebook, debemos intalar iplantuml .","title":"Instalaci\u00f3n"},{"location":"ecosystem/plantuml/#ejemplos","text":"","title":"Ejemplos"},{"location":"ecosystem/plantuml/#diagramas-de-secuencia","text":"Comencemos, pues, a dibujar. Lo principal es empezar cada uno de nuestros diagramas con @startuml y terminarlos con @enduml. Veremos mediante ejemplos qu\u00e9 cosas se pueden hacer con esta herramienta, desde algo sencillo a algo m\u00e1s complejo. La complejidad y el tama\u00f1o de los diagramas puede ser atroz. Por si os quer\u00e9is hacer una idea, en la documentaci\u00f3n se habla de un problema de memoria para diagramas de mas de 20000 x 10000px, pudi\u00e9ndose arreglar aumentando la memoria que usa la JVM. Nosotros no vamos a llegar a tanto, empezamos con un diagrama sencillo tal que as\u00ed: import iplantuml %% plantuml @startuml Juan -> Paco : saluda Juan <-- Paco : responde Juan -> Jes\u00fas : saluda Juan <-- Jes\u00fas : responde @enduml Tambi\u00e9n podemos declarar distintos participantes en el diagrama, como un actor (el monigote de los diagramas) o una base de datos, entre otros. Incluso a\u00f1adir notas, o cambiar la apariencia de todo. Completando el ejemplo anterior\u2026 (lo siento Jes\u00fas, te he convertido en baseDeDatos) %% plantuml @startuml actor Juan database baseDeDatos #green Juan -> baseDeDatos : saludas note right : cortes\u00eda Juan <-- baseDeDatos : responde Juan -> Paco : saluda Paco -> Paco : \u00bf c\u00f3mo se \\ nllamaba \\ neste t\u00edo ? Juan <-- Paco : responde @enduml Como podemos ver, las posibilidades se hacen enormes seg\u00fan descubrimos nuevos elementos que a\u00f1adir en nuestros diagramas, as\u00ed como formas de combinarlos. En el siguiente c\u00f3digo podemos ver una muestra de las posibilidades: %% plantuml @startuml == Comienzo == Elemento1 - X Elemento2 Elemento2 - [ #0000FF]-\\ Elemento1 Elemento2 <-> Elemento1 == Final == Elemento1 -> o Elemento2 @enduml Con esto terminamos con los diagramas de secuencia, podemos hacernos una idea de las posibilidades.","title":"Diagramas de secuencia"},{"location":"ecosystem/plantuml/#diagramas-de-clases","text":"Lo siguientes diagramas que tenemos en la lista son los diagramas de clases, vamos a analizarlos. A continuaci\u00f3n exponemos las principales operaciones entre clases: Herencia, composici\u00f3n y agregaci\u00f3n. %% plantuml @startuml Clase1 <|-- Clase2 Clase1 <|-- Clase3 Clase4 *-- Clase5 Clase6 o -- Clase7 @enduml Como hemos hecho antes, ahora completamos el diagrama con m\u00e1s elementos para demostrar la potencia: nombres a las relaciones, m\u00e9todos, etc. %% plantuml @startuml class Clase1 { toString () } class Clase2 { String [] elementos mostrarElementos () } Clase1 <|-- Clase2 Clase1 <|-- Clase3 Clase4 \"1\" *-- \"n\" Clase5 : agregaci\u00f3n Clase6 o -- Clase7 @enduml Tenemos muchas m\u00e1s opciones para relacionar clases entre s\u00ed, m\u00e1s ejemplos: %% plantuml @startuml Clase1 .. Clase2 Clase1 -- Clase3 Clase3 --> Clase4 Clase4 <|.. Clase5 Clase6 ..> Clase7 Clase7 ..|> Clase8 Clase8 <--* Clase9 @enduml Para acabar con este tipo de diagramas, vamos a hablar de la visibilidad de m\u00e9todos y atributos, as\u00ed como la posibilidad de trabajar con interfaces o clases abstractas, dejando muchas cosas en el tintero para que pod\u00e1is investigar (y no os de tanta pereza leer un art\u00edculo tan largo). %% plantuml @startuml abstract Abstracta { - privado #protected ~ package_private () + public () } interface Interfaz { metodo () } enum TimeUnit { DIAS HORAS MINUTOS } class Clase2 #red Abstracta <|-- Clase2 Abstracta <|-- Clase3 Interfaz <|.. Clase4 Interfaz <|.. Clase5 @enduml","title":"Diagramas de clases"},{"location":"ecosystem/plantuml/#diagramas-de-estados","text":"Seguimos con los diagramas de estados de toda la vida, que simbolizan un esquema de transiciones entre diversos estados. %% plantuml @startuml [ * ] --> Nacimiento Nacimiento : sin preocupaciones Tropiezo : se li\u00f3 parda Nacimiento --> Tropiezo : torpeza Tropiezo -> Muerte : SAMUR no llega a tiempo Muerte --> [ * ] @enduml Se pueden tener adem\u00e1s estados compuestos. Completando el ejemplo anterior con un estado compuesto nos quedar\u00eda algo como lo siguiente: %% plantuml @startuml [ * ] --> Nacimiento Nacimiento : sin preocupaciones state Tropiezo { Agilidad : lo esquiva Torpeza : se lio parda } Nacimiento --> Tropiezo : torpeza Agilidad -> Vida : felicidad Torpeza -> Muerte : SAMUR no llega a tiempo Torpeza -> Vida : SAMUR llega a tiempo Vida --> Muerte Muerte --> [ * ] @enduml A grandes rasgos es todo para este tipo de diagramas. Se\u00f1alar que las flechas de transiciones entre estados se adaptan bastante bien a los elementos con los que puedan colisionar.","title":"Diagramas de estados"},{"location":"ecosystem/plantuml/#otros-diagramas","text":"","title":"Otros diagramas"},{"location":"ecosystem/plantuml/#agrupando-componentes","text":"%% plantuml @startuml package \"Some Group\" { HTTP - [ First Component ] [ Another Component ] } node \"Other Groups\" { FTP - [ Second Component ] [ First Component ] --> FTP } cloud { [ Example 1 ] } database \"MySql\" { folder \"This is my folder\" { [ Folder 3 ] } frame \"Foo\" { [ Frame 4 ] } } [ Another Component ] --> [ Example 1 ] [ Example 1 ] --> [ Folder 3 ] [ Folder 3 ] --> [ Frame 4 ] @enduml","title":"Agrupando componentes"},{"location":"ecosystem/pydantic/","text":"Pydantic Introducci\u00f3n Pydantic es una librer\u00eda de python centrada en tres principios: Validaci\u00f3n de datos y gesti\u00f3n de la configuraci\u00f3n mediante anotaciones de tipo Python. Aplicar sugerencias de tipo en tiempo de ejecuci\u00f3n y proporciona errores f\u00e1ciles de usar cuando los datos no son v\u00e1lidos. Definir c\u00f3mo deben estar los datos en Python can\u00f3nico puro. Veamos un ejemplo: from datetime import datetime from typing import List , Optional from pydantic import BaseModel class User ( BaseModel ): id : int name = 'John Doe' signup_ts : Optional [ datetime ] = None friends : List [ int ] = [] external_data = { 'id' : '123' , 'signup_ts' : '2019-06-01 12:22' , 'friends' : [ 1 , 2 , '3' ], } user = User ( ** external_data ) print ( user . id ) 123 print ( repr ( user . signup_ts )) datetime.datetime(2019, 6, 1, 12, 22) print ( user . friends ) [1, 2, 3] print ( user . dict ()) {'id': 123, 'signup_ts': datetime.datetime(2019, 6, 1, 12, 22), 'friends': [1, 2, 3], 'name': 'John Doe'} Que est\u00e1 pasando aqui: id es de tipo int; la declaraci\u00f3n de solo anotaci\u00f3n le dice a Pydantic que este campo es obligatorio. Las cadenas, bytes o flotantes se convertir\u00e1n en ints si es posible; de lo contrario, se generar\u00e1 una excepci\u00f3n. name se infiere como una cadena del valor predeterminado proporcionado; debido a que tiene un valor predeterminado, no es necesario. signup_ts es un campo de fecha y hora que no es obligatorio (y toma el valor None si no se proporciona). pydantic procesar\u00e1 una marca de tiempo de Unix int (por ejemplo, 1496498400) o una cadena que represente la fecha y la hora. friends usa el sistema de escritura de Python y requiere una lista de entradas. Al igual que con id , los objetos de tipo entero se convertir\u00e1n en enteros. Si la validaci\u00f3n falla, pydantic generar\u00e1 un error con un desglose de lo que estaba mal: from pydantic import ValidationError try : User ( signup_ts = 'broken' , friends = [ 1 , 2 , 'not number' ]) except ValidationError as e : print ( e . json ()) [ { \"loc\": [ \"id\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" }, { \"loc\": [ \"signup_ts\" ], \"msg\": \"invalid datetime format\", \"type\": \"value_error.datetime\" }, { \"loc\": [ \"friends\", 2 ], \"msg\": \"value is not a valid integer\", \"type\": \"type_error.integer\" } ] Models El medio principal para definir objetos en Pydantic es a trav\u00e9s de modelos (los modelos son simplemente clases que heredan de BaseModel) . Puede pensar en los modelos como similares a los tipos en lenguajes estrictamente typed, o como los requisitos de un solo punto final en una API. Los datos que no son de confianza se pueden pasar a un modelo y, despu\u00e9s de analizar y validar, Pydantic garantiza que los campos de la instancia del modelo resultante se ajustar\u00e1n a los tipos de campo definidos en el modelo. from pydantic import BaseModel class User ( BaseModel ): id : int name = 'Jane Doe' Propiedades del modelo El ejemplo anterior solo muestra la punta del iceberg de lo que pueden hacer los modelos. Los modelos poseen los siguientes m\u00e9todos y atributos: dict() returns a dictionary of the model's fields and values; cf. exporting models json() returns a JSON string representation dict(); cf. exporting models copy() returns a deep copy of the model; cf. exporting models parse_obj() a utility for loading any object into a model with error handling if the object is not a dictionary; cf. helper functions parse_raw() a utility for loading strings of numerous formats; cf. helper functions parse_file() like parse_raw() but for files; cf. helper function from_orm() loads data into a model from an arbitrary class; cf. ORM mode schema() returns a dictionary representing the model as JSON Schema; cf. Schema schema_json() returns a JSON string representation of schema(); cf. Schema construct() a class method for creating models without running validation; cf. Creating models without validation __fields_set__ Set of names of fields which were set when the model instance was initialised __fields__ a dictionary of the model's fields __config__ the configuration class for the model, cf. model config Validators La validaci\u00f3n personalizada y las relaciones complejas entre objetos se pueden lograr utilizando el decorador validator . from pydantic import BaseModel , ValidationError , validator class UserModel ( BaseModel ): name : str username : str password1 : str password2 : str @validator ( 'name' ) def name_must_contain_space ( cls , v ): if ' ' not in v : raise ValueError ( 'must contain a space' ) return v . title () @validator ( 'password2' ) def passwords_match ( cls , v , values , ** kwargs ): if 'password1' in values and v != values [ 'password1' ]: raise ValueError ( 'passwords do not match' ) return v @validator ( 'username' ) def username_alphanumeric ( cls , v ): assert v . isalnum (), 'must be alphanumeric' return v # correcto user = UserModel ( name = 'samuel colvin' , username = 'scolvin' , password1 = 'zxcvbn' , password2 = 'zxcvbn' , ) print ( user ) name='Samuel Colvin' username='scolvin' password1='zxcvbn' password2='zxcvbn' # incorrecto try : UserModel ( name = 'samuel' , username = 'scolvin' , password1 = 'zxcvbn' , password2 = 'zxcvbn2' , ) except ValidationError as e : print ( e ) 2 validation errors for UserModel name must contain a space (type=value_error) password2 passwords do not match (type=value_error) Algunas cosas a tener en cuenta sobre los validadores: los validadores son \"m\u00e9todos de clase\", por lo que el primer valor de argumento que reciben es la clase UserModel , no una instancia de UserModel . el segundo argumento es siempre el valor del campo a validar; se puede nombrar como quieras tambi\u00e9n puede agregar cualquier subconjunto de los siguientes argumentos a la firma (los nombres deben coincidir): values : un dictado que contiene el mapeo de nombre a valor de cualquier campo validado previamente config : la configuraci\u00f3n del modelo field : el campo que se est\u00e1 validando **kwargs : si se proporciona, esto incluir\u00e1 los argumentos anteriores que no se enumeran expl\u00edcitamente en la firma los validadores deben devolver el valor analizado o generar un ValueError , TypeError o AssertionError (se pueden usar declaraciones de aserci\u00f3n). donde los validadores se basan en otros valores, debe tener en cuenta que: La validaci\u00f3n se realiza en el orden en que se definen los campos. En el ejemplo anterior, password2 tiene acceso a password1 (y name ), pero password1 no tiene acceso a password2 . Si la validaci\u00f3n falla en otro campo (o ese campo falta), no se incluir\u00e1 en los valores, por lo tanto, if 'password1' in values and ... en este ejemplo. Model Config El comportamiento de Pydantic se puede controlar a trav\u00e9s de la clase Config en un modelo. title the title for the generated JSON Schema anystr_strip_whitespace whether to strip leading and trailing whitespace for str & byte types (default: False) min_anystr_length the min length for str & byte types (default: 0) max_anystr_length the max length for str & byte types (default: 2 ** 16) validate_all whether to validate field defaults (default: False) extra whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of 'ignore', 'allow', or 'forbid', or values of the Extra enum (default: Extra.ignore). 'forbid' will cause validation to fail if extra attributes are included, 'ignore' will silently ignore any extra attributes, and 'allow' will assign the attributes to the model. allow_mutation whether or not models are faux-immutable, i.e. whether setattr is allowed (default: True) use_enum_values whether to populate models with the value property of enums, rather than the raw enum. This may be useful if you want to serialise model.dict() later (default: False) fields a dict containing schema information for each field; this is equivalent to using the Field class (default: None) validate_assignment whether to perform validation on assignment to attributes (default: False) allow_population_by_field_name whether an aliased field may be populated by its name as given by the model attribute, as well as the alias (default: False) error_msg_templates a dict used to override the default error message templates. Pass in a dictionary with keys matching the error messages you want to override (default: {}) arbitrary_types_allowed whether to allow arbitrary user types for fields (they are validated simply by checking if the value is an instance of the type). If False, RuntimeError will be raised on model declaration (default: False). See an example in Field Types. orm_mode whether to allow usage of ORM mode getter_dict a custom class (which should inherit from GetterDict) to use when decomposing ORM classes for validation, for use with orm_mode alias_generator a callable that takes a field name and returns an alias for it keep_untouched a tuple of types (e.g. descriptors) for a model's default values that should not be changed during model creation and will not be included in the model schemas. Note: this means that attributes on the model with defaults of this type, not annotations of this type, will be left alone. schema_extra a dict used to extend/update the generated JSON Schema, or a callable to post-process it; see Schema customization json_loads a custom function for decoding JSON; see custom JSON (de)serialisation json_dumps a custom function for encoding JSON; see custom JSON (de)serialisation json_encoders a dict used to customise the way types are encoded to JSON; see JSON Serialisation El que m\u00e1s destacamos ac\u00e1 es arbitrary_types_allowed , que nos permite validar cualquier tipo de datos (desde otras librer\u00edas). from pydantic import BaseModel from pandas import DataFrame # error class User ( BaseModel ): id : int df : DataFrame --------------------------------------------------------------------------- RuntimeError Traceback (most recent call last) <ipython-input-13-636d3cdef2f5> in <module> 1 # error ----> 2 class User(BaseModel): 3 id: int 4 df: DataFrame ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/main.py in __new__(mcs, name, bases, namespace, **kwargs) 255 annotation=ann_type, 256 class_validators=vg.get_validators(ann_name), --> 257 config=config, 258 ) 259 if not inferred.required: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in infer(cls, name, value, annotation, class_validators, config) 316 required=required, 317 model_config=config, --> 318 field_info=field_info, 319 ) 320 ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in __init__(self, name, type_, class_validators, model_config, default, default_factory, required, alias, field_info) 269 self.shape: int = SHAPE_SINGLETON 270 self.model_config.prepare_field(self) --> 271 self.prepare() 272 273 def get_default(self) -> Any: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in prepare(self) 349 if self.default is Undefined and self.default_factory is None: 350 self.default = None --> 351 self.populate_validators() 352 353 def _set_default_and_type(self) -> None: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in populate_validators(self) 527 v_funcs = ( 528 *[v.func for v in class_validators_ if v.each_item and v.pre], --> 529 *(get_validators() if get_validators else list(find_validators(self.type_, self.model_config))), 530 *[v.func for v in class_validators_ if v.each_item and not v.pre], 531 ) ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/validators.py in find_validators(type_, config) 591 yield make_arbitrary_type_validator(type_) 592 else: --> 593 raise RuntimeError(f'no validator found for {type_}, see `arbitrary_types_allowed` in Config') RuntimeError: no validator found for <class 'pandas.core.frame.DataFrame'>, see `arbitrary_types_allowed` in Config # correcto class User ( BaseModel ): id : int df : DataFrame class Config : arbitrary_types_allowed = True # ejemplo User ( id = 1 , df = DataFrame ({ 'a' :[ 1 , 2 ], 'b' :[ 3 , 4 ]}) ) User(id=1, name='Jane Doe')","title":"Pydantic"},{"location":"ecosystem/pydantic/#pydantic","text":"","title":"Pydantic"},{"location":"ecosystem/pydantic/#introduccion","text":"Pydantic es una librer\u00eda de python centrada en tres principios: Validaci\u00f3n de datos y gesti\u00f3n de la configuraci\u00f3n mediante anotaciones de tipo Python. Aplicar sugerencias de tipo en tiempo de ejecuci\u00f3n y proporciona errores f\u00e1ciles de usar cuando los datos no son v\u00e1lidos. Definir c\u00f3mo deben estar los datos en Python can\u00f3nico puro. Veamos un ejemplo: from datetime import datetime from typing import List , Optional from pydantic import BaseModel class User ( BaseModel ): id : int name = 'John Doe' signup_ts : Optional [ datetime ] = None friends : List [ int ] = [] external_data = { 'id' : '123' , 'signup_ts' : '2019-06-01 12:22' , 'friends' : [ 1 , 2 , '3' ], } user = User ( ** external_data ) print ( user . id ) 123 print ( repr ( user . signup_ts )) datetime.datetime(2019, 6, 1, 12, 22) print ( user . friends ) [1, 2, 3] print ( user . dict ()) {'id': 123, 'signup_ts': datetime.datetime(2019, 6, 1, 12, 22), 'friends': [1, 2, 3], 'name': 'John Doe'} Que est\u00e1 pasando aqui: id es de tipo int; la declaraci\u00f3n de solo anotaci\u00f3n le dice a Pydantic que este campo es obligatorio. Las cadenas, bytes o flotantes se convertir\u00e1n en ints si es posible; de lo contrario, se generar\u00e1 una excepci\u00f3n. name se infiere como una cadena del valor predeterminado proporcionado; debido a que tiene un valor predeterminado, no es necesario. signup_ts es un campo de fecha y hora que no es obligatorio (y toma el valor None si no se proporciona). pydantic procesar\u00e1 una marca de tiempo de Unix int (por ejemplo, 1496498400) o una cadena que represente la fecha y la hora. friends usa el sistema de escritura de Python y requiere una lista de entradas. Al igual que con id , los objetos de tipo entero se convertir\u00e1n en enteros. Si la validaci\u00f3n falla, pydantic generar\u00e1 un error con un desglose de lo que estaba mal: from pydantic import ValidationError try : User ( signup_ts = 'broken' , friends = [ 1 , 2 , 'not number' ]) except ValidationError as e : print ( e . json ()) [ { \"loc\": [ \"id\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" }, { \"loc\": [ \"signup_ts\" ], \"msg\": \"invalid datetime format\", \"type\": \"value_error.datetime\" }, { \"loc\": [ \"friends\", 2 ], \"msg\": \"value is not a valid integer\", \"type\": \"type_error.integer\" } ]","title":"Introducci\u00f3n"},{"location":"ecosystem/pydantic/#models","text":"El medio principal para definir objetos en Pydantic es a trav\u00e9s de modelos (los modelos son simplemente clases que heredan de BaseModel) . Puede pensar en los modelos como similares a los tipos en lenguajes estrictamente typed, o como los requisitos de un solo punto final en una API. Los datos que no son de confianza se pueden pasar a un modelo y, despu\u00e9s de analizar y validar, Pydantic garantiza que los campos de la instancia del modelo resultante se ajustar\u00e1n a los tipos de campo definidos en el modelo. from pydantic import BaseModel class User ( BaseModel ): id : int name = 'Jane Doe'","title":"Models"},{"location":"ecosystem/pydantic/#propiedades-del-modelo","text":"El ejemplo anterior solo muestra la punta del iceberg de lo que pueden hacer los modelos. Los modelos poseen los siguientes m\u00e9todos y atributos: dict() returns a dictionary of the model's fields and values; cf. exporting models json() returns a JSON string representation dict(); cf. exporting models copy() returns a deep copy of the model; cf. exporting models parse_obj() a utility for loading any object into a model with error handling if the object is not a dictionary; cf. helper functions parse_raw() a utility for loading strings of numerous formats; cf. helper functions parse_file() like parse_raw() but for files; cf. helper function from_orm() loads data into a model from an arbitrary class; cf. ORM mode schema() returns a dictionary representing the model as JSON Schema; cf. Schema schema_json() returns a JSON string representation of schema(); cf. Schema construct() a class method for creating models without running validation; cf. Creating models without validation __fields_set__ Set of names of fields which were set when the model instance was initialised __fields__ a dictionary of the model's fields __config__ the configuration class for the model, cf. model config","title":"Propiedades del modelo"},{"location":"ecosystem/pydantic/#validators","text":"La validaci\u00f3n personalizada y las relaciones complejas entre objetos se pueden lograr utilizando el decorador validator . from pydantic import BaseModel , ValidationError , validator class UserModel ( BaseModel ): name : str username : str password1 : str password2 : str @validator ( 'name' ) def name_must_contain_space ( cls , v ): if ' ' not in v : raise ValueError ( 'must contain a space' ) return v . title () @validator ( 'password2' ) def passwords_match ( cls , v , values , ** kwargs ): if 'password1' in values and v != values [ 'password1' ]: raise ValueError ( 'passwords do not match' ) return v @validator ( 'username' ) def username_alphanumeric ( cls , v ): assert v . isalnum (), 'must be alphanumeric' return v # correcto user = UserModel ( name = 'samuel colvin' , username = 'scolvin' , password1 = 'zxcvbn' , password2 = 'zxcvbn' , ) print ( user ) name='Samuel Colvin' username='scolvin' password1='zxcvbn' password2='zxcvbn' # incorrecto try : UserModel ( name = 'samuel' , username = 'scolvin' , password1 = 'zxcvbn' , password2 = 'zxcvbn2' , ) except ValidationError as e : print ( e ) 2 validation errors for UserModel name must contain a space (type=value_error) password2 passwords do not match (type=value_error) Algunas cosas a tener en cuenta sobre los validadores: los validadores son \"m\u00e9todos de clase\", por lo que el primer valor de argumento que reciben es la clase UserModel , no una instancia de UserModel . el segundo argumento es siempre el valor del campo a validar; se puede nombrar como quieras tambi\u00e9n puede agregar cualquier subconjunto de los siguientes argumentos a la firma (los nombres deben coincidir): values : un dictado que contiene el mapeo de nombre a valor de cualquier campo validado previamente config : la configuraci\u00f3n del modelo field : el campo que se est\u00e1 validando **kwargs : si se proporciona, esto incluir\u00e1 los argumentos anteriores que no se enumeran expl\u00edcitamente en la firma los validadores deben devolver el valor analizado o generar un ValueError , TypeError o AssertionError (se pueden usar declaraciones de aserci\u00f3n). donde los validadores se basan en otros valores, debe tener en cuenta que: La validaci\u00f3n se realiza en el orden en que se definen los campos. En el ejemplo anterior, password2 tiene acceso a password1 (y name ), pero password1 no tiene acceso a password2 . Si la validaci\u00f3n falla en otro campo (o ese campo falta), no se incluir\u00e1 en los valores, por lo tanto, if 'password1' in values and ... en este ejemplo.","title":"Validators"},{"location":"ecosystem/pydantic/#model-config","text":"El comportamiento de Pydantic se puede controlar a trav\u00e9s de la clase Config en un modelo. title the title for the generated JSON Schema anystr_strip_whitespace whether to strip leading and trailing whitespace for str & byte types (default: False) min_anystr_length the min length for str & byte types (default: 0) max_anystr_length the max length for str & byte types (default: 2 ** 16) validate_all whether to validate field defaults (default: False) extra whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of 'ignore', 'allow', or 'forbid', or values of the Extra enum (default: Extra.ignore). 'forbid' will cause validation to fail if extra attributes are included, 'ignore' will silently ignore any extra attributes, and 'allow' will assign the attributes to the model. allow_mutation whether or not models are faux-immutable, i.e. whether setattr is allowed (default: True) use_enum_values whether to populate models with the value property of enums, rather than the raw enum. This may be useful if you want to serialise model.dict() later (default: False) fields a dict containing schema information for each field; this is equivalent to using the Field class (default: None) validate_assignment whether to perform validation on assignment to attributes (default: False) allow_population_by_field_name whether an aliased field may be populated by its name as given by the model attribute, as well as the alias (default: False) error_msg_templates a dict used to override the default error message templates. Pass in a dictionary with keys matching the error messages you want to override (default: {}) arbitrary_types_allowed whether to allow arbitrary user types for fields (they are validated simply by checking if the value is an instance of the type). If False, RuntimeError will be raised on model declaration (default: False). See an example in Field Types. orm_mode whether to allow usage of ORM mode getter_dict a custom class (which should inherit from GetterDict) to use when decomposing ORM classes for validation, for use with orm_mode alias_generator a callable that takes a field name and returns an alias for it keep_untouched a tuple of types (e.g. descriptors) for a model's default values that should not be changed during model creation and will not be included in the model schemas. Note: this means that attributes on the model with defaults of this type, not annotations of this type, will be left alone. schema_extra a dict used to extend/update the generated JSON Schema, or a callable to post-process it; see Schema customization json_loads a custom function for decoding JSON; see custom JSON (de)serialisation json_dumps a custom function for encoding JSON; see custom JSON (de)serialisation json_encoders a dict used to customise the way types are encoded to JSON; see JSON Serialisation El que m\u00e1s destacamos ac\u00e1 es arbitrary_types_allowed , que nos permite validar cualquier tipo de datos (desde otras librer\u00edas). from pydantic import BaseModel from pandas import DataFrame # error class User ( BaseModel ): id : int df : DataFrame --------------------------------------------------------------------------- RuntimeError Traceback (most recent call last) <ipython-input-13-636d3cdef2f5> in <module> 1 # error ----> 2 class User(BaseModel): 3 id: int 4 df: DataFrame ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/main.py in __new__(mcs, name, bases, namespace, **kwargs) 255 annotation=ann_type, 256 class_validators=vg.get_validators(ann_name), --> 257 config=config, 258 ) 259 if not inferred.required: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in infer(cls, name, value, annotation, class_validators, config) 316 required=required, 317 model_config=config, --> 318 field_info=field_info, 319 ) 320 ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in __init__(self, name, type_, class_validators, model_config, default, default_factory, required, alias, field_info) 269 self.shape: int = SHAPE_SINGLETON 270 self.model_config.prepare_field(self) --> 271 self.prepare() 272 273 def get_default(self) -> Any: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in prepare(self) 349 if self.default is Undefined and self.default_factory is None: 350 self.default = None --> 351 self.populate_validators() 352 353 def _set_default_and_type(self) -> None: ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/fields.py in populate_validators(self) 527 v_funcs = ( 528 *[v.func for v in class_validators_ if v.each_item and v.pre], --> 529 *(get_validators() if get_validators else list(find_validators(self.type_, self.model_config))), 530 *[v.func for v in class_validators_ if v.each_item and not v.pre], 531 ) ~/.cache/pypoetry/virtualenvs/python-development-tools-nOt15PiH-py3.7/lib/python3.7/site-packages/pydantic/validators.py in find_validators(type_, config) 591 yield make_arbitrary_type_validator(type_) 592 else: --> 593 raise RuntimeError(f'no validator found for {type_}, see `arbitrary_types_allowed` in Config') RuntimeError: no validator found for <class 'pandas.core.frame.DataFrame'>, see `arbitrary_types_allowed` in Config # correcto class User ( BaseModel ): id : int df : DataFrame class Config : arbitrary_types_allowed = True # ejemplo User ( id = 1 , df = DataFrame ({ 'a' :[ 1 , 2 ], 'b' :[ 3 , 4 ]}) ) User(id=1, name='Jane Doe')","title":"Model Config"},{"location":"oop/oop/","text":"Introducci\u00f3n La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop/#introduccion","text":"La Programaci\u00f3n Orientada a Objetos (POO u OOP seg\u00fan sus siglas en ingl\u00e9s) tiene sus ra\u00edces en la d\u00e9cada del 60 con el lenguaje de programaci\u00f3n Simula que en 1967, el cual fue el primer lenguaje que posee las caracter\u00edsticas principales de un lenguaje orientado a objetos. Smalltalk (de 1972 a 1980) es posiblemente el ejemplo can\u00f3nico, y con el que gran parte de la teor\u00eda de la POO se ha desarrollado. M\u00e1s su uso se populariz\u00f3 a principios de la d\u00e9cada de 1990 Este modo o paradigma de programaci\u00f3n nos permite organizar el c\u00f3digo de una manera que se asemeja bastante a como pensamos en la vida real, utilizando las famosas clases. Estas nos permiten agrupar un conjunto de variables y funciones que veremos a continuaci\u00f3n. Cosas de lo m\u00e1s cotidianas como un perro o un coche pueden ser representadas con clases. Estas clases tienen diferentes caracter\u00edsticas, que en el caso del perro podr\u00edan ser la edad, el nombre o la raza. Llamaremos a estas caracter\u00edsticas, atributos. Por otro lado, las clases tienen un conjunto de funcionalidades o cosas que pueden hacer. En el caso del perro podr\u00eda ser andar o ladrar. Llamaremos a estas funcionalidades m\u00e9todos. Por \u00faltimo, pueden existir diferentes tipos de perro. Podemos tener uno que se llama Toby o el del vecino que se llama Laika. Llamaremos a estos diferentes tipos de perro objetos. Es decir, el concepto abstracto de perro es la clase, pero Toby o cualquier otro perro particular ser\u00e1 el objeto. La programaci\u00f3n orientada a objetos est\u00e1 basada en 6 principios o pilares b\u00e1sicos:","title":"Introducci\u00f3n"},{"location":"oop/oop_abstraccion/","text":"Abstracci\u00f3n La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430> M\u00e9todos en las subclases Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come Ejercicios Ejercicio 01 Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Abstraccion"},{"location":"oop/oop_abstraccion/#abstraccion","text":"La abstracci\u00f3n es un termino que hace referencia a la ocultaci\u00f3n de la complejidad intr\u00ednseca de una aplicaci\u00f3n al exterior, centr\u00e1ndose s\u00f3lo en como puede ser usada, lo que se conoce como interfaz (o clases abstractas). la abstracci\u00f3n consiste en ocultar toda la complejidad que algo puede tener por dentro, ofreci\u00e9ndonos unas funciones de alto nivel, por lo general sencillas de usar, que pueden ser usadas para interactuar con la aplicaci\u00f3n sin tener conocimiento de lo que hay dentro. Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod del modulo abc ( Abstract Base Classes ). Un m\u00f3dulo que se encuentra en la librer\u00eda est\u00e1ndar del lenguaje, por lo que no es necesario instalar. As\u00ed para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un m\u00e9todo abstracto. from abc import ABC , abstractmethod class Animal ( ABC ): @abstractmethod def mover ( self ): pass Ahora si se intenta crear una instancia de la clase animal, Python no lo permitir\u00e1 indicando que no es posible. Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un m\u00e9todo abstracto, Python permitir\u00e1 instancias las clases. class Animal ( ABC ): def mover ( self ): pass Animal () <__main__.Animal at 0x7f890cf53430> class Animal (): @abstractmethod def mover ( self ): pass Animal () <__main__.Animal at 0x7f890c646430>","title":"Abstracci\u00f3n"},{"location":"oop/oop_abstraccion/#metodos-en-las-subclases","text":"Las subclases tienen que implementar todos los m\u00e9todos abstractos, en el caso de que falta alguno de ellos Python no permitir\u00e1 instancias tampoco la clase hija. # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) # falta implementar metodo comer() g = Gato () # Error --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-104-f134a1af2db8> in <module> ----> 1 g = Gato() # Error TypeError: Can't instantiate abstract class Gato with abstract methods comer Escribamos el ejemplo correctamente: # clase abstracta class Animal ( ABC ): @abstractmethod def mover ( self ): pass @abstractmethod def comer ( self ): print ( 'Animal come' ) # subclase class Gato ( Animal ): def mover ( self ): print ( 'Mover gato' ) def comer ( self ): print ( 'Gato come' ) g = Gato () g . mover () Mover gato g . comer () Gato come","title":"M\u00e9todos en las subclases"},{"location":"oop/oop_abstraccion/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_abstraccion/#ejercicio-01","text":"Defina la interfaz Vehiculo , que cumpla los siguientes aspectos: Atributos de instancias ruedas . Definir m\u00e9todo abstracto nombre , que imprima por pantalla el nombre del veh\u00edculo. Definir m\u00e9todo abstracto tipo_transporte , que imprima por pantalla el tipo de transporte del veh\u00edculo (terrestre, maritimo o a\u00e9reo). Con esta interfaz, cree las clases Coche , Barco y Avion . Luego, cree los objetos coche , barco y avion a partir de las clases Coche , Barco y Avion , respectivamente. from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = None @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase Barco class Barco ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # clase Avion class Avion ( Vehiculo ): def nombre ( self ): pass def tipo_transporte ( self ): pass # objetos a partir de las distintas clases coche = None barco = None avion = None","title":"Ejercicio 01"},{"location":"oop/oop_acoplamiento/","text":"Acoplamiento en programaci\u00f3n El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte. Ejercicios Ejercicio 01 Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Acoplamiento"},{"location":"oop/oop_acoplamiento/#acoplamiento-en-programacion","text":"El acoplamiento en programaci\u00f3n (denominado coupling en Ingl\u00e9s) es un concepto que mide la dependencia entre dos m\u00f3dulos distintos de software, como pueden ser por ejemplo las clases. El acoplamiento puede ser de dos tipos: Acoplamiento d\u00e9bil , que indica que no existe dependencia de un m\u00f3dulo con otros. Esto deber\u00eda ser la meta de nuestro software. Acoplamiento fuerte , que por lo contrario indica que un m\u00f3dulo tiene dependencias internas con otros. El t\u00e9rmino acoplamiento est\u00e1 muy relacionado con la cohesi\u00f3n, ya que acoplamiento d\u00e9bil suele ir ligado a cohesi\u00f3n fuerte. En general lo que buscamos en nuestro c\u00f3digo es que tenga acoplamiento d\u00e9bil y cohesi\u00f3n fuerte, es decir, que no tenga dependencias con otros m\u00f3dulos y que las tareas que realiza est\u00e9n relacionadas entre s\u00ed. Si a\u00fan no te hemos convencido de porque buscamos c\u00f3digo d\u00e9bilmente acoplado, veamos lo que pasar\u00eda con un c\u00f3digo fuertemente acoplado: Debido a las dependencias con otros m\u00f3dulo, un cambio en un modulo ajeno al nuestro podr\u00eda tener un \u201cefecto mariposa\u201d en nuestro c\u00f3digo, a\u00fan sin haber modificado directamente nuestro m\u00f3dulo. Si un m\u00f3dulo tiene dependencias con otros, reduce la reusabilidad, ya que para reusarlo deber\u00edamos copiar tambi\u00e9n las dependencias. Veamos un ejemplo usando clases y objetos en Python. Tenemos una Clase1 que define un atributo de clase x . Por otro lado la Clase2 basa el comportamiento del m\u00e9todo mi_metodo() en el valor de x de la Clase1 . En este ejemplo existe acoplamiento fuerte, ya que existe una dependencia con una variable de otro m\u00f3dulo. class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor mi_clase = Clase2 () mi_clase . mi_metodo ( \"Hola\" ) mi_clase . valor 'Hola' Puede parecer un ejemplo trivial, pero cuando el software se va complicando, no es nada raro acabar haciendo cosas de este tipo casi sin darnos cuenta. Hay veces que dependencias externas pueden estar justificadas, pero hay que estar muy seguro de lo que se hace. Este tipo de dependencias tambi\u00e9n puede hacer el c\u00f3digo muy dif\u00edcil de depurar. Imaginemos que nuestro c\u00f3digo de la Clase2 funciona perfectamente, pero de repente alguien hace un cambio en la Clase1 . Un cambio tan sencillo como el siguiente. Clase1 . x = False Este cambio estar\u00eda modificando el comportamiento de nuestra clase y nos preguntar\u00edamos \u00bfporqu\u00e9 ha dejado de funcionar mi c\u00f3digo si no he tocado nada? A veces atribuimos estos comportamientos a la magia o radiaci\u00f3n c\u00f3smica, pero simplemente tenemos c\u00f3digo con acoplamiento fuerte.","title":"Acoplamiento en programaci\u00f3n"},{"location":"oop/oop_acoplamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_acoplamiento/#ejercicio-01","text":"Considere el siguiente ejemplo: class Clase1 : x = True pass class Clase2 : def mi_metodo ( self , valor ): if Clase1 . x : self . valor = valor De lo explicado anteriormente, se sabe que en este c\u00f3digo existe un acoplamiento fuerte . Reescribe el c\u00f3digo anterior para pasar de un acoplamiento fuerte a un acoplamiento d\u00e9bil .","title":"Ejercicio 01"},{"location":"oop/oop_cohesion/","text":"Cohesi\u00f3n La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesion"},{"location":"oop/oop_cohesion/#cohesion","text":"La cohesi\u00f3n hace referencia al grado de relaci\u00f3n entre los elementos de un m\u00f3dulo. En el dise\u00f1o de una funci\u00f3n, es importante pensar bien la tarea que va a realizar, intentando que sea \u00fanica y bien definida. Cuantas m\u00e1s cosas diferentes haga una funci\u00f3n sin relaci\u00f3n entre s\u00ed, m\u00e1s complicado ser\u00e1 el c\u00f3digo de entender. Existen por lo tanto dos tipos de cohesi\u00f3n: La cohesi\u00f3n d\u00e9bil que indica que la relaci\u00f3n entre los elementos es baja. Es decir, no pertenecen a una \u00fanica funcionalidad. La cohesi\u00f3n fuerte , que debe ser nuestro objetivo al dise\u00f1ar programas. La cohesi\u00f3n fuerte indica que existe una alta relaci\u00f3n entre los elementos existentes dentro del m\u00f3dulo. Ve\u00e1moslo con un ejemplo. Tenemos una funci\u00f3n suma() que suma dos n\u00fameros. El problema es que adem\u00e1s de sumar dos n\u00fameros, los convierte a float() y adem\u00e1s pide al usuario que introduzca por pantalla el n\u00famero. Podr\u00eda parecer que esas otras dos funcionalidades no son para tanto, pero si por ejemplo una persona quiere usar nuestra funci\u00f3n suma() pero ya tiene los n\u00fameros y no quiere pedirlos por pantalla, no le servir\u00eda nuestra funci\u00f3n. # Mal. Cohesi\u00f3n d\u00e9bil def suma (): num1 = float ( input ( \"Dame primer n\u00famero\" ) or 42 ) num2 = float ( input ( \"Dame segundo n\u00famero\" ) or 12 ) suma = num1 + num2 print ( suma ) suma () Dame primer n\u00famero Dame segundo n\u00famero 54.0 Para que la funci\u00f3n tuviese una cohesi\u00f3n fuerte, ser\u00eda conveniente que la suma realizara una \u00fanica tarea bien definida, que es sumar. # Bien. Cohesi\u00f3n fuerte def suma ( numeros ): total = 0 for i in numeros : total = total + i return total Evidentemente un ejemplo tan sencillo como el explicado no tiene implicaciones demasiado graves, pero es importante buscar que las funciones realicen una \u00fanica tarea (o conjunto) pero relacionadas entre s\u00ed. Dise\u00f1ar c\u00f3digo con cohesi\u00f3n fuerte nos permite: Reducir la complejidad del m\u00f3dulo, ya que tendr\u00e1 un menor n\u00famero de operaciones. Se podr\u00e1 reutilizar los m\u00f3dulos m\u00e1s f\u00e1cilmente El sistema ser\u00e1 m\u00e1s f\u00e1cilmente mantenible.","title":"Cohesi\u00f3n"},{"location":"oop/oop_conceptos_basicos/","text":"Conceptos b\u00e1sicos Clases y objetos Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro). Definiendo atributos A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma. Definiendo m\u00e9todos Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments Tipos de m\u00e9todos Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" M\u00e9todos de instancia Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase M\u00e9todos de clase A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase. M\u00e9todos est\u00e1ticos Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta. Ejercicios Ejercicio 01 Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Conceptos B\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#conceptos-basicos","text":"","title":"Conceptos b\u00e1sicos"},{"location":"oop/oop_conceptos_basicos/#clases-y-objetos","text":"Una clase es una entidad que define una serie de elementos que determinan un estado (datos) y un comportamiento (operaciones sobre los datos que modifican su estado). Por su parte, un objeto es una concreci\u00f3n o instancia de una clase. Lo primero es crear una clase, para ello usaremos el ejemplo de perro. Para crear una clase se ocupa el comando class . # Creando una clase vac\u00eda class Perro : pass Se trata de una clase vac\u00eda y sin mucha utilidad pr\u00e1ctica, pero es la m\u00ednima clase que podemos crear. N\u00f3tese el uso del pass que no hace realmente nada, pero dar\u00eda un error si despu\u00e9s de los : no tenemos contenido. Ahora que tenemos la clase , podemos crear un objeto de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con () . Dentro de los par\u00e9ntesis ir\u00edan los par\u00e1metros de entrada si los hubiera. # Creamos un objeto de la clase perro mi_perro = Perro () Observaci\u00f3n : El nombre de la clase debe comenzar con May\u00fascula (Ejemplo: Perro).","title":"Clases y objetos"},{"location":"oop/oop_conceptos_basicos/#definiendo-atributos","text":"A continuaci\u00f3n vamos a a\u00f1adir algunos atributos a nuestra clase. Antes de nada es importante distinguir que existen dos tipos de atributos: Atributos de instancia : Pertenecen a la instancia de la clase o al objeto. Son atributos particulares de cada instancia, en nuestro caso de cada perro. Atributos de clase : Se trata de atributos que pertenecen a la clase, por lo tanto ser\u00e1n comunes para todos los objetos. Empecemos creando un par de atributos de instancia para nuestro perro, el nombre y la raza. Para ello creamos un m\u00e9todo __init__ que ser\u00e1 llamado autom\u00e1ticamente cuando creemos un objeto. Se trata del constructor . class Perro : # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Ahora que hemos definido el m\u00e9todo __init__ con dos par\u00e1metros de entrada, podemos crear el objeto pasando el valor de los atributos. Usando type() podemos ver como efectivamente el objeto es de la clase Perro. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) print ( type ( mi_perro )) Creando perro Toby, Bulldog <class '__main__.Perro'> Seguramente te hayas fijado en el self que se pasa como par\u00e1metro de entrada del m\u00e9todo. Es una variable que representa la instancia de la clase, y deber\u00e1 estar siempre ah\u00ed. El uso de __init__ y el doble __ no es una coincidencia. Cuando veas un m\u00e9todo con esa forma, significa que est\u00e1 reservado para un uso especial del lenguaje. En este caso ser\u00eda lo que se conoce como constructor. Hay gente que llama a estos m\u00e9todos m\u00e1gicos . Por \u00faltimo, podemos acceder a los atributos usando el objeto. print ( mi_perro . nombre ) # Toby print ( mi_perro . raza ) # Bulldog --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-55-75ae86c0ae26> in <module> ----> 1 print(mi_perro.nombre) # Toby 2 print(mi_perro.raza) # Bulldog AttributeError: 'Perro' object has no attribute 'nombre' Hasta ahora hemos definido atributos de instancia, ya que son atributos que pertenecen a cada perro concreto. Ahora vamos a definir un atributo de clase, que ser\u00e1 com\u00fan para todos los perros. Por ejemplo, la especie de los perros es algo com\u00fan para todos los objetos Perro. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza Dado que es un atributo de clase, no es necesario crear un objeto para acceder al atributos. Podemos hacer lo siguiente. print ( Perro . especie ) mam\u00edfero Se puede acceder tambi\u00e9n al atributo de clase desde el objeto. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . especie Creando perro Toby, Bulldog 'mam\u00edfero' De esta manera, todos los objetos que se creen de la clase perro compartir\u00e1n ese atributo de clase, ya que pertenecen a la misma.","title":"Definiendo atributos"},{"location":"oop/oop_conceptos_basicos/#definiendo-metodos","text":"Los m\u00e9todos son las funciones que se definen dentro de una clase y que, por consiguiente, pueden ser referenciadas por los objetos de dicha clase. Vamos a codificar dos m\u00e9todos, ladrar y caminar . El primero no recibir\u00e1 ning\u00fan par\u00e1metro y el segundo recibir\u00e1 el n\u00famero de pasos que queremos andar. Como hemos indicado anteriormente self hace referencia a la instancia de la clase. Se puede definir un m\u00e9todo con def y el nombre, y entre () los par\u00e1metros de entrada que recibe, donde siempre tendr\u00e1 que estar self el primero. class Perro : # Atributo de clase especie = 'mam\u00edfero' # El m\u00e9todo __init__ es llamado al crear el objeto def __init__ ( self , nombre , raza ): print ( f \"Creando perro { nombre } , { raza } \" ) # Atributos de instancia self . nombre = nombre self . raza = raza def ladra ( self ): print ( \"Guau\" ) def camina ( self , pasos ): print ( f \"Caminando { pasos } pasos\" ) Por lo tanto si creamos un objeto mi_perro , podremos hacer uso de sus m\u00e9todos llam\u00e1ndolos con . y el nombre del m\u00e9todo. Como si de una funci\u00f3n se tratase, pueden recibir y devolver argumentos. mi_perro = Perro ( \"Toby\" , \"Bulldog\" ) mi_perro . ladra () mi_perro . camina ( 10 ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-56-8f9b248109d4> in <module> ----> 1 mi_perro = Perro(\"Toby\", \"Bulldog\") 2 mi_perro.ladra() 3 mi_perro.camina(10) TypeError: Perro() takes no arguments","title":"Definiendo m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#tipos-de-metodos","text":"Hemos visto como se pueden crear m\u00e9todos con def dentro de una clase, pudiendo recibir par\u00e1metros como entrada y modificar el estado (como los atributos) de la instancia. Pues bien, haciendo uso de los decoradores, es posible crear diferentes tipos de m\u00e9todos: Lo m\u00e9todos de instancia \u201cnormales\u201d que ya hemos visto como metodo() M\u00e9todos de clase usando el decorador @classmethod Y m\u00e9todos est\u00e1ticos usando el decorador @staticmethod En la siguiente clase tenemos un ejemplo donde definimos los tres tipos de m\u00e9todos. class Clase : def metodo ( self ): return 'M\u00e9todo normal' , self @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\"","title":"Tipos de m\u00e9todos"},{"location":"oop/oop_conceptos_basicos/#metodos-de-instancia","text":"Los m\u00e9todos de instancia son los m\u00e9todos normales, de toda la vida, que hemos visto anteriormente. Reciben como par\u00e1metro de entrada self que hace referencia a la instancia que llama al m\u00e9todo. Tambi\u00e9n pueden recibir otros argumentos como entrada. class Clase : def metodo ( self , arg1 , arg2 ): return 'M\u00e9todo normal' , self Y como ya sabemos, una vez creado un objeto pueden ser llamados. mi_clase = Clase () mi_clase . metodo ( \"a\" , \"b\" ) ('M\u00e9todo normal', <__main__.Clase at 0x7f890c6465e0>) En vista a esto, los m\u00e9todos de instancia: Pueden acceder y modificar los atributos del objeto. Pueden acceder a otros m\u00e9todos. Dado que desde el objeto self se puede acceder a la clase con self.class , tambi\u00e9n pueden modificar el estado de la clase","title":"M\u00e9todos de instancia"},{"location":"oop/oop_conceptos_basicos/#metodos-de-clase","text":"A diferencia de los m\u00e9todos de instancia, los m\u00e9todos de clase reciben como argumento cls , que hace referencia a la clase. Por lo tanto, pueden acceder a la clase pero no a la instancia. class Clase : @classmethod def metododeclase ( cls ): return 'M\u00e9todo de clase' , cls Se pueden llamar sobre la clase. Clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Pero tambi\u00e9n se pueden llamar sobre el objeto. mi_clase = Clase () mi_clase . metododeclase () ('M\u00e9todo de clase', __main__.Clase) Por lo tanto, los m\u00e9todos de clase: No pueden acceder a los atributos de la instancia. Pero si pueden modificar los atributos de la clase.","title":"M\u00e9todos de clase"},{"location":"oop/oop_conceptos_basicos/#metodos-estaticos","text":"Los m\u00e9todos est\u00e1ticos se pueden definir con el decorador @staticmethod y no aceptan como par\u00e1metro ni la instancia ni la clase. Es por ello por lo que no pueden modificar el estado ni de la clase ni de la instancia. Pero por supuesto pueden aceptar par\u00e1metros de entrada. class Clase : @staticmethod def metodoestatico (): return \"M\u00e9todo est\u00e1tico\" mi_clase = Clase () Clase . metodoestatico () mi_clase . metodoestatico () 'M\u00e9todo est\u00e1tico' Por lo tanto el uso de los m\u00e9todos est\u00e1ticos pueden resultar \u00fatil para indicar que un m\u00e9todo no modificar\u00e1 el estado de la instancia ni de la clase. Es cierto que se podr\u00eda hacer lo mismo con un m\u00e9todo de instancia por ejemplo, pero a veces resulta importante indicar de alguna manera estas peculiaridades, evitando as\u00ed futuros problemas y malentendidos. En otras palabras, los m\u00e9todos est\u00e1ticos se podr\u00edan ver como funciones normales, con la salvedad de que van ligadas a una clase concreta.","title":"M\u00e9todos est\u00e1ticos"},{"location":"oop/oop_conceptos_basicos/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_conceptos_basicos/#ejercicio-01","text":"Crear una clase denomina Coche que cumpla los siguientes aspectos: Atributo de clase rueda igual a 4. Atributos de instancias color , aceleracion y velocidad . Pero que la velocidad sea igual a un valor contante 0. Definir m\u00e9todo acelera , que d\u00e9 como salida la velocidad m\u00e1s la aceleraci\u00f3n. Definir m\u00e9todo frena , que d\u00e9 como salida la velocidad menos la aceleraci\u00f3n (si el resultado es menor que 0, retorno el valor 0). Finalmente, cree el objeto coche_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = None def __init__ ( self , color , aceleracion ): self . color = None self . aceleracion = None self . velocidad = None def acelera ( self ): pass def frena ( self ): pass # crear objeto de la clase Coche coche_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #coche_01.ruedas # color #coche_01.color # aceleracion #coche_01.aceleracion # velocidad #coche_01.velocidad # metodo frena #coche_01.acelera() #coche_01.velocidad # metodo frena #coche_01.frena() #coche_01.velocidad","title":"Ejercicio 01"},{"location":"oop/oop_encapsulamiento/","text":"Encapsulamiento El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo Decoradores Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d. Ejercicios Ejercicio 01 Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#encapsulamiento","text":"El encapsulamiento hace referencia al ocultamiento de los estado internos de una clase al exterior. Dicho de otra manera, encapsular consiste en hacer que los atributos o m\u00e9todos internos a una clase no se puedan acceder ni modificar desde fuera, sino que tan solo el propio objeto pueda acceder a ellos. Para la gente que conozca Java , le resultar\u00e1 un termino muy familiar, pero en Python es algo distinto. Digamos que Python por defecto no oculta los atributos y m\u00e9todos de una clase al exterior. Veamos un ejemplo con el lenguaje Python. class Clase : atributo_clase = \"Hola\" def __init__ ( self , atributo_instancia ): self . atributo_instancia = atributo_instancia mi_clase = Clase ( \"Que tal\" ) mi_clase . atributo_clase 'Hola' mi_clase . atributo_instancia 'Que tal' Ambos atributos son perfectamente accesibles desde el exterior. Sin embargo esto es algo que tal vez no queramos. Hay ciertos m\u00e9todos o atributos que queremos que pertenezcan s\u00f3lo a la clase o al objeto, y que s\u00f3lo puedan ser accedidos por los mismos. Para ello podemos usar la doble __ para nombrar a un atributo o m\u00e9todo. Esto har\u00e1 que Python los interprete como privados , de manera que no podr\u00e1n ser accedidos desde el exterior. class Clase : atributo_clase = \"Hola\" # Accesible desde el exterior __atributo_clase = \"Hola\" # No accesible # No accesible desde el exterior def __mi_metodo ( self ): print ( \"Haz algo\" ) self . __variable = 0 # Accesible desde el exterior def metodo_normal ( self ): # El m\u00e9todo si es accesible desde el interior self . __mi_metodo () mi_clase = Clase () mi_clase . __atributo_clase # Error! El atributo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-123-032bf986b5b0> in <module> 1 mi_clase = Clase() ----> 2 mi_clase.__atributo_clase # Error! El atributo no es accesible AttributeError: 'Clase' object has no attribute '__atributo_clase' mi_clase . __mi_metodo () # Error! El m\u00e9todo no es accesible --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-124-d565976117bf> in <module> ----> 1 mi_clase.__mi_metodo() # Error! El m\u00e9todo no es accesible AttributeError: 'Clase' object has no attribute '__mi_metodo' mi_clase . atributo_clase # Ok! 'Hola' mi_clase . metodo_normal () # Ok! Haz algo Y como curiosidad, podemos hacer uso de dir para ver el listado de m\u00e9todos y atributos de nuestra clase. Podemos ver claramente como tenemos el metodo_normal y el atributo de clase, pero no podemos encontrar __mi_metodo ni __atributo_clase . print ( dir ( mi_clase )) ['_Clase__atributo_clase', '_Clase__mi_metodo', '_Clase__variable', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'atributo_clase', 'metodo_normal'] Pues bien, en realidad si que podr\u00edamos acceder a __atributo_clase y a __mi_metodo haciendo un poco de trampa. Aunque no se vea a simple vista, si que est\u00e1n pero con un nombre distinto, para de alguna manera ocultarlos y evitar su uso. Pero podemos llamarlos de la siguiente manera, pero por lo general no es una buena idea. mi_clase . _Clase__atributo_clase 'Hola' mi_clase . _Clase__mi_metodo () Haz algo","title":"Encapsulamiento"},{"location":"oop/oop_encapsulamiento/#decoradores","text":"Decorador Property El decorador @property , que viene por defecto con Python, y puede ser usado para modificar un m\u00e9todo para que sea un atributo o propiedad. El decorador puede ser usado sobre un m\u00e9todo, que har\u00e1 que act\u00fae como si fuera un atributo. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo Como si de un atributo normal se tratase, podemos acceder a el con el objeto . y nombre. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo # 'valor_atributo' 'valor_atributo' Muy importante notar que aunque mi_atributo pueda parecer un m\u00e9todo, en realidad no lo es, por lo que no puede ser llamado con (). mi_clase . mi_atributo () # Error! Es un atributo, no un m\u00e9todo --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-135-e6068a9fee20> in <module> ----> 1 mi_clase.mi_atributo() # Error! Es un atributo, no un m\u00e9todo TypeError: 'str' object is not callable Tal vez te preguntes para que sirve esto, ya que el siguiente c\u00f3digo hace exactamente lo mismo sin hacer uso de decoradores. class Clase : def __init__ ( self , mi_atributo ): self . mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' Bien, la explicaci\u00f3n no es sencilla, pero est\u00e1 relacionada con el concepto de encapsulaci\u00f3n de la programaci\u00f3n orientada a objetos. Este concepto nos indica que en determinadas ocasiones es importante ocultar el estado interno de los objetos al exterior, para evitar que sean modificados de manera incorrecta. Para la gente que venga del mundo de Java , esto no ser\u00e1 nada nuevo, y est\u00e1 muy relacionado con los m\u00e9todos set() y get() que veremos a continuaci\u00f3n. La primera diferencia que vemos entre los c\u00f3digos anteriores es el uso de __ antes de mi_atributo . Cuando nombramos una variable de esta manera, es una forma de decirle a Python que queremos que se \u201coculte\u201d y que no pueda ser accedida como el resto de atributos. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo mi_clase = Clase ( \"valor_atributo\" ) mi_clase . __mi_atributo # Error! --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-139-5c61a1cd0bf2> in <module> ----> 1 mi_clase.__mi_atributo # Error! AttributeError: 'Clase' object has no attribute '__mi_atributo' Esto puede ser importante con ciertas variables que no queremos que sean accesibles desde el exterior de una manera no controlada. Al definir la propiedad con @property el acceso a ese atributo se realiza a trav\u00e9s de una funci\u00f3n, siendo por lo tanto un acceso controlado. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): # El acceso se realiza a trav\u00e9s de este \"m\u00e9todo\" y # podr\u00eda contener c\u00f3digo extra y no un simple retorno return self . __mi_atributo Otra utilidad podr\u00eda ser la consulta de un par\u00e1metro que requiera de muchos c\u00e1lculos. Se podr\u00eda tener un atributo que no estuviera directamente almacenado en la clase, sino que precisara de realizar ciertos c\u00e1lculos. Para optimizar esto, se podr\u00edan hacer los c\u00e1lculos s\u00f3lo cuando el atributo es consultado. Por \u00faltimo, existen varios a\u00f1adidos al decorador @property como pueden ser el setter . Se trata de otro decorador que permite definir un \u201cm\u00e9todo\u201d que modifica el contenido del atributo que se est\u00e9 usando. class Clase : def __init__ ( self , mi_atributo ): self . __mi_atributo = mi_atributo @property def mi_atributo ( self ): return self . __mi_atributo @mi_atributo . setter def mi_atributo ( self , valor ): if valor != \"\" : print ( \"Modificando el valor\" ) self . __mi_atributo = valor else : print ( \"Error est\u00e1 vac\u00edo\" ) De esta forma podemos a\u00f1adir c\u00f3digo al setter , haciendo que por ejemplo realice comprobaciones antes de modificar el valor. Esto es una cosa que de usar un atributo normal no podr\u00edamos hacer, y es muy \u00fatil de cara a la encapsulaci\u00f3n. mi_clase = Clase ( \"valor_atributo\" ) mi_clase . mi_atributo 'valor_atributo' mi_clase . mi_atributo = \"nuevo_valor\" mi_clase . mi_atributo Modificando el valor 'nuevo_valor' mi_clase . mi_atributo = \"\" # Error est\u00e1 vac\u00edo Error est\u00e1 vac\u00edo Resulta l\u00f3gico pensar que si un determinado atributo pertenece a una clase, si queremos modificarlo deber\u00eda de tener la \u201caprobaci\u00f3n\u201d de la clase, para asegurarse que ninguna entidad externa est\u00e1 \u201chaciendo cosas raras\u201d.","title":"Decoradores"},{"location":"oop/oop_encapsulamiento/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_encapsulamiento/#ejercicio-01","text":"Crear una clase denomina Parametros que cumpla los siguientes aspectos: Atributo de clase privado local igual a True Atributo de instancia forecast_start (fecha objetivo) Atributo de instancia forecast_weeks (n\u00famero de semanas a pronosticar) Atributo de instancia test_weeks (n\u00famero de semanas de testeo) Ocupar el decorador property para definir el atributo forecast_periods , que corresponde n\u00famero de dias a pronosticar: (test_weeks + forecast_weeks)*7 Ocupar el decorador property para definir el atributo test_start , que corresponde a la fecha de testeo ( forecast_start - total de d\u00edas de test_weeks ) # clase ForecastParams:","title":"Ejercicio 01"},{"location":"oop/oop_herencia/","text":"Herencia La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n. Extendiendo y modificando m\u00e9todos Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar! Uso de super() En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis' Herencia m\u00faltiple Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>) Ejercicios Ejercicio 01 Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Herencia"},{"location":"oop/oop_herencia/#herencia","text":"La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase padre, compartiendo sus m\u00e9todos y atributos. Adem\u00e1s de ello, una clase hija puede sobreescribir los m\u00e9todos o atributos, o incluso definir unos nuevos. Se puede crear una clase hija con tan solo pasar como par\u00e1metro la clase de la que queremos heredar. En el siguiente ejemplo vemos como se puede usar la herencia en Python, con la clase Perro que hereda de Animal . # Definimos una clase padre class Animal : pass # Creamos una clase hija que hereda de la padre class Perro ( Animal ): pass De hecho podemos ver como efectivamente la clase Perro es la hija de Animal usando __bases__ print ( Perro . __bases__ ) (<class '__main__.Animal'>,) De manera similar podemos ver que clases descienden de una en concreto con __subclasses__ . print ( Animal . __subclasses__ ()) [<class '__main__.Perro'>] \u00bfY para que queremos la herencia? Dado que una clase hija hereda los atributos y m\u00e9todos de la padre, nos puede ser muy \u00fatil cuando tengamos clases que se parecen entre s\u00ed pero tienen ciertas particularidades. En este caso en vez de definir un mont\u00f3n de clases para cada animal, podemos tomar los elementos comunes y crear una clase Animal de la que hereden el resto, respetando el principio DRY (Don't Repeat Yourself). Realizar estas abstracciones y buscar el denominador com\u00fan para definir una clase de la que hereden las dem\u00e1s, es una tarea de lo m\u00e1s compleja en el mundo de la programaci\u00f3n.","title":"Herencia"},{"location":"oop/oop_herencia/#extendiendo-y-modificando-metodos","text":"Continuemos con nuestro ejemplo de perros y animales. Vamos a definir una clase padre Animal que tendr\u00e1 todos los atributos y m\u00e9todos gen\u00e9ricos que los animales pueden tener. Esta tarea de buscar el denominador com\u00fan es muy importante en programaci\u00f3n. Veamos los atributos: Tenemos la especie ya que todos los animales pertenecen a una. La edad, ya que todo ser vivo nace, crece, se reproduce y muere. Los m\u00e9todos o funcionalidades: Un m\u00e9todo hablar, que cada animal implementar\u00e1 de una forma. Los perros ladran, las abejas zumban y los caballos relinchan. Un m\u00e9todo moverse. Unos animales lo har\u00e1n caminando, otros volando. Un m\u00e9todo descr\u00edbeme que ser\u00e1 com\u00fan. Definimos la clase padre, con una serie de atributos comunes para todos los animales como hemos indicado. class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def hablar ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico pero con implementaci\u00f3n particular def moverse ( self ): # M\u00e9todo vac\u00edo pass # M\u00e9todo gen\u00e9rico con la misma implementaci\u00f3n def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tenemos ya por lo tanto una clase gen\u00e9rica Animal , que generaliza las caracter\u00edsticas y funcionalidades que todo animal puede tener. Ahora creamos una clase Perro que hereda del Animal . Como primer ejemplo vamos a crear una clase vac\u00eda, para ver como los m\u00e9todos y atributos son heredados por defecto. # Perro hereda de Animal class Perro ( Animal ): pass mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_perro . describeme () Soy un Animal del tipo Perro Hemos creado una clase nueva que tiene todo el contenido que la clase padre tiene, pero aqu\u00ed viene lo que es de verdad interesante. Vamos a crear varios animales concretos y sobreescrbir algunos de los m\u00e9todos que hab\u00edan sido definidos en la clase Animal , como el hablar o el moverse, ya que cada animal se comporta de una manera distinta. Podemos incluso crear nuevos m\u00e9todos que se a\u00f1adir\u00e1n a los ya heredados, como en el caso de la Abeja con picar() . class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) def moverse ( self ): print ( \"Caminando con 4 patas\" ) class Abeja ( Animal ): def hablar ( self ): print ( \"Bzzzz!\" ) def moverse ( self ): print ( \"Volando\" ) # Nuevo m\u00e9todo def picar ( self ): print ( \"Picar!\" ) Por lo tanto ya podemos crear nuestros objetos de esos animales y hacer uso de sus m\u00e9todos que podr\u00edan clasificarse en tres: Heredados directamente de la clase padre: describeme() Heredados de la clase padre pero modificados: hablar() y moverse() Creados en la clase hija por lo tanto no existentes en la clase padre: picar() mi_perro = Perro ( 'mam\u00edfero' , 10 ) mi_vaca = Vaca ( 'mam\u00edfero' , 23 ) mi_abeja = Abeja ( 'insecto' , 1 ) mi_perro . hablar () mi_vaca . hablar () Guau! Muuu! mi_vaca . describeme () mi_abeja . describeme () Soy un Animal del tipo Vaca Soy un Animal del tipo Abeja mi_abeja . picar () Picar!","title":"Extendiendo y modificando m\u00e9todos"},{"location":"oop/oop_herencia/#uso-de-super","text":"En pocas palabras, la funci\u00f3n super() nos permite acceder a los m\u00e9todos de la clase padre desde una de sus hijas. Volvamos al ejemplo de Animal y Perro : class Animal : def __init__ ( self , especie , edad ): self . especie = especie self . edad = edad def hablar ( self ): pass def moverse ( self ): pass def describeme ( self ): print ( \"Soy un Animal del tipo\" , type ( self ) . __name__ ) Tal vez queramos que nuestro Perro tenga un par\u00e1metro extra en el constructor, como podr\u00eda ser el due\u00f1o. Para realizar esto tenemos dos alternativas: Podemos crear un nuevo __init__ y guardar todas las variables una a una. O podemos usar super() para llamar al __init__ de la clase padre que ya aceptaba la especie y edad, y s\u00f3lo asignar la variable nueva manualmente. class Perro ( Animal ): def __init__ ( self , especie , edad , due\u00f1o ): # Alternativa 1 # self.especie = especie # self.edad = edad # self.due\u00f1o = due\u00f1o # Alternativa 2 super () . __init__ ( especie , edad ) self . due\u00f1o = due\u00f1o mi_perro = Perro ( 'mam\u00edfero' , 7 , 'Luis' ) mi_perro . especie 'mam\u00edfero' mi_perro . edad 7 mi_perro . due\u00f1o 'Luis'","title":"Uso de super()"},{"location":"oop/oop_herencia/#herencia-multiple","text":"Hemos visto como se pod\u00eda crear una clase padre que heredaba de una clase hija, pudiendo hacer uso de sus m\u00e9todos y atributos. La herencia m\u00faltiple es similar, pero una clase hereda de varias clases padre en vez de una sola. Veamos un ejemplo. Por un lado tenemos dos clases Clase1 y Clase2 , y por otro tenemos la Clase3 que hereda de las dos anteriores. Por lo tanto, heredar\u00e1 todos los m\u00e9todos y atributos de ambas. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass Las clases hijas heredan los m\u00e9todos de las clases padre, pero tambi\u00e9n pueden reimplementarlos de manera distinta. Entonces, si llamo a un m\u00e9todo que todas las clases tienen en com\u00fan \u00bfa cu\u00e1l se llama?. Pues bien, existe una forma de saberlo. La forma de saber a que m\u00e9todo se llama es consultar el MRO (Method Order Resolution). Esta funci\u00f3n nos devuelve una tupla con el orden de b\u00fasqueda de los m\u00e9todos. Como era de esperar se empieza en la propia clase y se va subiendo hasta la clase padre, de izquierda a derecha. class Clase1 : pass class Clase2 : pass class Clase3 ( Clase1 , Clase2 ): pass print ( Clase3 . __mro__ ) (<class '__main__.Clase3'>, <class '__main__.Clase1'>, <class '__main__.Clase2'>, <class 'object'>) Al final del todo vemos la clase object . Aunque pueda parecer raro, es correcto ya que en realidad todas las clases en Python heredan de una clase gen\u00e9rica object , aunque no lo especifiquemos expl\u00edcitamente. Podemos tener una clase heredando de otras tres. F\u00edjate en que el MRO depende del orden en el que las clases son pasadas: 1, 3, 2. class Clase1 : pass class Clase2 : pass class Clase3 : pass class Clase4 ( Clase1 , Clase3 , Clase2 ): pass print ( Clase4 . __mro__ ) (<class '__main__.Clase4'>, <class '__main__.Clase1'>, <class '__main__.Clase3'>, <class '__main__.Clase2'>, <class 'object'>)","title":"Herencia m\u00faltiple"},{"location":"oop/oop_herencia/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_herencia/#ejercicio-01","text":"Crear una clase denomina CocheVolador que cumpla los siguientes aspectos: La clase CocheVolador hereda de la clase Coche . Atributo de clase rueda igual a 6. Tenga los atributos de instancia de la clase Coche m\u00e1s el tributo esta_volando (con valor por defecto igual False ) Definir m\u00e9todo vuela , que reemplace el valor de esta_volando por True . Definir m\u00e9todo aterriza , que reemplace el valor de esta_volando por False . Finalmente, cree el objeto cocheV_01 que tenga como argumentos color rojo y aceleraci\u00f3n 20 . Pruebe los atributos y m\u00e9todos asociados a esta clase. # crear clase Coche class Coche : \"\"\" Esta clase define el estado y el comportamiento de un coche \"\"\" ruedas = 4 def __init__ ( self , color , aceleracion ): self . color = color self . aceleracion = aceleracion self . velocidad = 0 def acelera ( self ): self . velocidad = self . velocidad + self . aceleracion def frena ( self ): v = self . velocidad - self . aceleracion v = 0 if v < 0 else v self . velocidad = v # crear clase CocheVolador class CocheVolador ( Coche ): \"\"\" Esta clase define el estado y el comportamiento de un coche volador \"\"\" ruedas = None def __init__ ( self , color , aceleracion , esta_volando = False ): super () . __init__ ( color , aceleracion ) self . esta_volando = None def vuela ( self ): pass def aterriza ( self ): pass # crear objeto de la clase CocheVolador cocheV_01 = None Atributos y m\u00e9todos de la clase Coche # ruedas #cocheV_01.ruedas # color #cocheV_01.color # aceleracion #cocheV_01.aceleracion # velocidad #cocheV_01.velocidad # metodo frena #cocheV_01.acelera() #cocheV_01.velocidad # metodo frena #cocheV_01.frena() #cocheV_01.velocidad Atributos y m\u00e9todos de la clase CocheVolador # esta_volando #cocheV_01.esta_volando # metodo vuela #cocheV_01.vuela() #cocheV_01.esta_volando # metodo aterriza #cocheV_01.aterriza() #cocheV_01.esta_volando","title":"Ejercicio 01"},{"location":"oop/oop_polimorfismo/","text":"Polimorfismo en programaci\u00f3n El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu! Ejercicios Ejercicio 01 Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Polimorfismo"},{"location":"oop/oop_polimorfismo/#polimorfismo-en-programacion","text":"El Polimorfismo es la capacidad de una entidad de referenciar en tiempo de ejecuci\u00f3n a instancias de diferentes clases. Una definici\u00f3n un tanto informal del polimorfismo, dir\u00eda algo as\u00ed: \u201cme da igual de que clase sea este objeto, que si comparte funcionalidades con otros, para mi son lo mismo\u201d. Evidentemente para que esto ocurra tiene que existir un denominador com\u00fan, que por definici\u00f3n ocurre cuando una clase hija hereda de una padre, heredando todos sus m\u00e9todos y atributos. Las clases hijas pueden implementar los m\u00e9todos de una forma diferente, pero usando el mismo interfaz . Vamos a ver un ejemplo en Python con tres clases de tres animales. Todas implementan el m\u00e9todo hablar() . class Perro : def hablar ( self ): print ( \"Guau!\" ) class Gato : def hablar ( self ): print ( \"Miau!\" ) class Vaca : def hablar ( self ): print ( \"Muuu!\" ) Vamos a crear una lista de objetos, uno de cada clase. animales = [ Perro (), Gato (), Vaca ()] Y ahora vamos a llamar al m\u00e9todo hablar() de todos los animales. Como todos ellos lo codifican con el mismo nombre, pero con una implementaci\u00f3n distinta, se ejecutar\u00e1 sin problemas. Esto ejemplo usa en cierto modo el concepto de polimorfismo for animal in animales : animal . hablar () Guau! Miau! Muuu! Y llevado a la herencia, ser\u00eda exactamente igual. Tenemos una clase padre Animal con un m\u00e9todo definido pero no implementado, de la que heredan tres animales. Cada animal implementa el m\u00e9todo com\u00fan de una manera distinta. class Animal : def hablar ( self ): pass class Perro ( Animal ): def hablar ( self ): print ( \"Guau!\" ) class Gato ( Animal ): def hablar ( self ): print ( \"Miau!\" ) class Vaca ( Animal ): def hablar ( self ): print ( \"Muuu!\" ) animales = [ Perro (), Gato (), Vaca ()] for animal in animales : animal . hablar () Guau! Miau! Muuu!","title":"Polimorfismo en programaci\u00f3n"},{"location":"oop/oop_polimorfismo/#ejercicios","text":"","title":"Ejercicios"},{"location":"oop/oop_polimorfismo/#ejercicio-01","text":"Ocupando las clases Coche , Barco y Avion , imprima por pantalla el nombre del veh\u00edculo y el tipo de transporte de las distintas clases respectivamente. Aplique el concepto de polimorfismo de clases (explique por qu\u00e9 funciona en este caso). from abc import ABC , abstractmethod # clase abstracta Vehiculo class Vehiculo ( ABC ): def __init__ ( self , ruedas ): self . ruedas = ruedas @abstractmethod def nombre ( self ): pass @abstractmethod def tipo_transporte ( self ): pass # clase abstracta Coche (ejemplo) class Coche ( Vehiculo ): def nombre ( self ): print ( \"Soy un coche\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: terrestre\" ) # clase abstracta Barco class Barco ( Vehiculo ): def nombre ( self ): print ( \"Soy un barco\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: maritimo\" ) # clase abstracta Avion class Avion ( Vehiculo ): def nombre ( self ): print ( \"Soy un avion\" ) def tipo_transporte ( self ): print ( \"Tipo de transporte: aereo\" ) # objetos a partir de las distintas clases coche = None barco = None avion = None # imprimir nombre y tipo de transporte de los objetos definidos","title":"Ejercicio 01"},{"location":"patterns/comportamiento/","text":"Patrones de comportamiento Los patrones de comportamiento estudian las relaciones entre llamadas entre los diferentes objetos, normalmente ligados con la dimensi\u00f3n temporal. Chain of Responsibility Evita acoplar el emisor de una petici\u00f3n a su receptor, al dar a m\u00e1s de un objeto la posibilidad de responder a la petici\u00f3n. Crea una cadena con los objetos receptores y pasa la petici\u00f3n a trav\u00e9s de la cadena hasta que esta sea tratada por alg\u00fan objeto. Ejemplo # patron class Handler : def __init__ ( self ): self . __succesor__ = None def set_succesor ( self , succesor ): self . __succesor__ = succesor def handler_request ( self , opt ): pass class HandlerOptionOne ( Handler ): def handler_request ( self , opt ): if opt == 1 : print ( \"Domingo\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionTwo ( Handler ): def handler_request ( self , opt ): if opt == 2 : print ( \"Lunes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionThree ( Handler ): def handler_request ( self , opt ): if opt == 3 : print ( \"Martes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFour ( Handler ): def handler_request ( self , opt ): if opt == 4 : print ( \"Miercoles\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFive ( Handler ): def handler_request ( self , opt ): if opt == 5 : print ( \"Jueves\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSix ( Handler ): def handler_request ( self , opt ): if opt == 6 : print ( \"Viernes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSeven ( Handler ): def handler_request ( self , opt ): if opt == 7 : print ( \"Sabado\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionDefault ( Handler ): def handler_request ( self , opt ): print ( \"Opci\u00f3n no valida\" ) # ejemplo class EjemploCadena : def obtener_nombre ( self ): return \"Chain of responsability\" def operacion ( self , opcion = 5 ): cadena = [ HandlerOptionSix (), HandlerOptionTwo (), HandlerOptionThree (), HandlerOptionFour (), HandlerOptionFive (), HandlerOptionOne (), HandlerOptionSeven (), HandlerOptionDefault ()] for i in range ( len ( cadena ) - 1 ): cadena [ i ] . set_succesor ( cadena [ i + 1 ]) #opcion = int(input(\"ingrese un n\u00famero: \")) cadena [ 0 ] . handler_request ( opcion ) # resultado EjemploCadena () . operacion () Jueves Command Encapsula una petici\u00f3n en un objeto, permitiendo as\u00ed parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer la operaciones. # patron class Command : def execute ( self , recivier ): pass class Recivier (): def show_message ( self , msg ): print ( msg ) class DomesticEngineer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take out the trash\" ) class Politician ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take the money from the rich, take the votes from poor\" ) class Programmer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"sell the bugs, charge extra for the fixes\" ) # ejemplo class EjemploCommand : def obtener_nombre ( self ): return \"Command\" def operacion ( self ): comandos = [ Politician (), DomesticEngineer (), Programmer ()] r = Recivier () for i in comandos : i . execute ( r ) # resultado EjemploCommand () . operacion () take the money from the rich, take the votes from poor take out the trash sell the bugs, charge extra for the fixes Interpreter Dado un lenguaje, define una representaci\u00f3n de su gram\u00e1tica junto con un int\u00e9rprete que usa dicha representaci\u00f3n para interpretar las sentencias del lenguaje. # patron class Expresion : def __init__ ( self , value = None , left = None , right = None ): self . __value__ = value self . __left__ = left self . __right__ = right class ExpresionNumber ( Expresion ): def evaluate ( self ): return int ( self . __value__ ) class ExpresionPluss ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () + self . __right__ . evaluate () class ExpresionMinus ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () - self . __right__ . evaluate () # ejemplo class EjemploInterpreter : def obtener_nombre ( self ): return \"Interpreter\" def operacion ( self ): operacion = ExpresionPluss ( left = ExpresionNumber ( value = '15' ), right = ExpresionMinus ( left = ExpresionNumber ( value = '25' ), right = ExpresionNumber ( value = '5' ))) print ( operacion . evaluate ()) # resultado EjemploInterpreter () . operacion () 35 Otros Patrones Iterator: Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representaci\u00f3n interna. Mediator: Define un objeto que encapsula c\u00f3mo interact\u00faan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros expl\u00edcitamente, y permite variar la interacci\u00f3n entre ellos de forma independiente. Memento: Representa y externaliza el estado interno de un objeto sin violar la encapsulaci\u00f3n, de forma que \u00e9ste puede volver a dicho estado m\u00e1s tarde. Observer: Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambia de estado se notifica y actualizan autom\u00e1ticamente todos los objetos. State: Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecer\u00e1 que cambia la clase del objeto. Strategy: Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo var\u00ede independientemente de los clientes que lo usan. Template Method: Define en una operaci\u00f3n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura. Visitor: Representa una operaci\u00f3n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci\u00f3n sin cambiar las clases de los elementos sobre los que opera.","title":"Patrones de comportamiento"},{"location":"patterns/comportamiento/#patrones-de-comportamiento","text":"Los patrones de comportamiento estudian las relaciones entre llamadas entre los diferentes objetos, normalmente ligados con la dimensi\u00f3n temporal.","title":"Patrones de comportamiento"},{"location":"patterns/comportamiento/#chain-of-responsibility","text":"Evita acoplar el emisor de una petici\u00f3n a su receptor, al dar a m\u00e1s de un objeto la posibilidad de responder a la petici\u00f3n. Crea una cadena con los objetos receptores y pasa la petici\u00f3n a trav\u00e9s de la cadena hasta que esta sea tratada por alg\u00fan objeto.","title":"Chain of Responsibility"},{"location":"patterns/comportamiento/#ejemplo","text":"# patron class Handler : def __init__ ( self ): self . __succesor__ = None def set_succesor ( self , succesor ): self . __succesor__ = succesor def handler_request ( self , opt ): pass class HandlerOptionOne ( Handler ): def handler_request ( self , opt ): if opt == 1 : print ( \"Domingo\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionTwo ( Handler ): def handler_request ( self , opt ): if opt == 2 : print ( \"Lunes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionThree ( Handler ): def handler_request ( self , opt ): if opt == 3 : print ( \"Martes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFour ( Handler ): def handler_request ( self , opt ): if opt == 4 : print ( \"Miercoles\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionFive ( Handler ): def handler_request ( self , opt ): if opt == 5 : print ( \"Jueves\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSix ( Handler ): def handler_request ( self , opt ): if opt == 6 : print ( \"Viernes\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionSeven ( Handler ): def handler_request ( self , opt ): if opt == 7 : print ( \"Sabado\" ) else : self . __succesor__ . handler_request ( opt ) class HandlerOptionDefault ( Handler ): def handler_request ( self , opt ): print ( \"Opci\u00f3n no valida\" ) # ejemplo class EjemploCadena : def obtener_nombre ( self ): return \"Chain of responsability\" def operacion ( self , opcion = 5 ): cadena = [ HandlerOptionSix (), HandlerOptionTwo (), HandlerOptionThree (), HandlerOptionFour (), HandlerOptionFive (), HandlerOptionOne (), HandlerOptionSeven (), HandlerOptionDefault ()] for i in range ( len ( cadena ) - 1 ): cadena [ i ] . set_succesor ( cadena [ i + 1 ]) #opcion = int(input(\"ingrese un n\u00famero: \")) cadena [ 0 ] . handler_request ( opcion ) # resultado EjemploCadena () . operacion () Jueves","title":"Ejemplo"},{"location":"patterns/comportamiento/#command","text":"Encapsula una petici\u00f3n en un objeto, permitiendo as\u00ed parametrizar a los clientes con distintas peticiones, encolar o llevar un registro de las peticiones y poder deshacer la operaciones. # patron class Command : def execute ( self , recivier ): pass class Recivier (): def show_message ( self , msg ): print ( msg ) class DomesticEngineer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take out the trash\" ) class Politician ( Command ): def execute ( self , recivier ): recivier . show_message ( \"take the money from the rich, take the votes from poor\" ) class Programmer ( Command ): def execute ( self , recivier ): recivier . show_message ( \"sell the bugs, charge extra for the fixes\" ) # ejemplo class EjemploCommand : def obtener_nombre ( self ): return \"Command\" def operacion ( self ): comandos = [ Politician (), DomesticEngineer (), Programmer ()] r = Recivier () for i in comandos : i . execute ( r ) # resultado EjemploCommand () . operacion () take the money from the rich, take the votes from poor take out the trash sell the bugs, charge extra for the fixes","title":"Command"},{"location":"patterns/comportamiento/#interpreter","text":"Dado un lenguaje, define una representaci\u00f3n de su gram\u00e1tica junto con un int\u00e9rprete que usa dicha representaci\u00f3n para interpretar las sentencias del lenguaje. # patron class Expresion : def __init__ ( self , value = None , left = None , right = None ): self . __value__ = value self . __left__ = left self . __right__ = right class ExpresionNumber ( Expresion ): def evaluate ( self ): return int ( self . __value__ ) class ExpresionPluss ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () + self . __right__ . evaluate () class ExpresionMinus ( Expresion ): def evaluate ( self ): return self . __left__ . evaluate () - self . __right__ . evaluate () # ejemplo class EjemploInterpreter : def obtener_nombre ( self ): return \"Interpreter\" def operacion ( self ): operacion = ExpresionPluss ( left = ExpresionNumber ( value = '15' ), right = ExpresionMinus ( left = ExpresionNumber ( value = '25' ), right = ExpresionNumber ( value = '5' ))) print ( operacion . evaluate ()) # resultado EjemploInterpreter () . operacion () 35","title":"Interpreter"},{"location":"patterns/comportamiento/#otros-patrones","text":"Iterator: Proporciona un modo de acceder secuencialmente a los elementos de un objeto agregado sin exponer su representaci\u00f3n interna. Mediator: Define un objeto que encapsula c\u00f3mo interact\u00faan un conjunto de objetos. Promueve un bajo acoplamiento al evitar que los objetos se refieran unos a otros expl\u00edcitamente, y permite variar la interacci\u00f3n entre ellos de forma independiente. Memento: Representa y externaliza el estado interno de un objeto sin violar la encapsulaci\u00f3n, de forma que \u00e9ste puede volver a dicho estado m\u00e1s tarde. Observer: Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambia de estado se notifica y actualizan autom\u00e1ticamente todos los objetos. State: Permite que un objeto modifique su comportamiento cada vez que cambia su estado interno. Parecer\u00e1 que cambia la clase del objeto. Strategy: Define una familia de algoritmos, encapsula uno de ellos y los hace intercambiables. Permite que un algoritmo var\u00ede independientemente de los clientes que lo usan. Template Method: Define en una operaci\u00f3n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura. Visitor: Representa una operaci\u00f3n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci\u00f3n sin cambiar las clases de los elementos sobre los que opera.","title":"Otros Patrones"},{"location":"patterns/creacionales/","text":"Patrones de creaci\u00f3n Los patrones de creaci\u00f3n abstraen la forma en la que se crean los objetos, permitiendo tratar las clases a crear de forma gen\u00e9rica dejando para m\u00e1s tarde la decisi\u00f3n de qu\u00e9 clases crear o c\u00f3mo crearlas. Singleton Garantiza que una clase s\u00f3lo tenga una instancia, y proporciona un punto de acceso global a ella. # patron class Singleton (): _instance = None _value = 0 @classmethod def get_instance ( cls ): # Constructor alternativo que retorna una nueva instancia if not cls . _instance : cls . _instance = cls () return cls . _instance def get_value ( self ): return self . _value def set_value ( self , v ): self . _value = v # ejemplo class EjemploSingleton : def obtener_nombre ( self ): return \"Singleton\" def operacion ( self ): print ( \"Ejemplo Singleton\" ) x = Singleton . get_instance () y = Singleton . get_instance () print ( x is y ) y . set_value ( 10 ) print ( x . get_value ()) #resultado EjemploSingleton () . operacion () Ejemplo Singleton True 10 Prototype Especifica los tipos de objetos a crear por medio de una instancia protot\u00edpica, y crear nuevos objetos copiando este prototipo. # ejemplo from abc import ABC , abstractmethod from copy import copy , deepcopy class Animal ( ABC ): def __init__ ( self ): self . __description__ = \"\" self . __number_of_legs__ = 0 self . __name__ = \"\" self . __owner__ = None def hello_animal ( self ): return \"hi i am a \" + self . __name__ + \" and i have \" + str ( self . __number_of_legs__ ) + \" legs, property of: \" + self . __owner__ . get_name () def set_owner ( self , owner ): self . __owner__ = owner ; def get_owner ( self ): return self . __owner__ def change_owner ( self , name ): self . __owner__ . set_name ( name ) def set_description ( self , description ): self . __description__ = description ; def get_description ( self ): return self . __description__ def get_name ( self ): return self . __name__ def set_name ( self , name ): self . __name__ = name ; def get_number_of_legs ( self ): return self . __number_of_legs__ def set_number_of_legs ( self , number_of_legs ): self . __number_of_legs__ = number_of_legs def clone ( self ): return deepcopy ( self ) class Sheep ( Animal ): pass class Chicken ( Animal ): pass class Owner (): def __init__ ( self , name ): self . __name__ = name def get_name ( self ): return self . __name__ ; def set_name ( self , name ): self . __name__ = name ; class AnimalCreator (): def __init__ ( self ): self . __chicken__ = Chicken () self . __sheep__ = Sheep () self . __chicken__ . set_owner ( Owner ( \"Juan\" )) self . __chicken__ . set_description ( \"a litle chicken\" ) self . __chicken__ . set_name ( \"chicken\" ) self . __chicken__ . set_number_of_legs ( 2 ) self . __sheep__ . set_owner ( Owner ( \"Juan\" )) self . __sheep__ . set_description ( \"a litle sheep\" ) self . __sheep__ . set_name ( \"sheep\" ) self . __sheep__ . set_number_of_legs ( 4 ) def retrieve_animal ( self , kind_of_animal ): if \"Chicken\" == kind_of_animal : return self . __chicken__ . clone () elif \"Sheep\" == kind_of_animal : return self . __sheep__ . clone () return None # ejemplo class EjemploPrototype : def obtener_nombre ( self ): return \"Prototype\" def operacion ( self ): print ( \"Ejemplo prototype\" ) creator = AnimalCreator () animals = [] for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Chicken\" )) for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Sheep\" )) for i in animals : print ( i . hello_animal ()) animals [ 4 ] . change_owner ( \"Alejandro\" ) for i in animals : print ( i . hello_animal ()) # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan Abstract Factory Proporciona una interfaz para crear familias de objetos o que dependen entre s\u00ed, sin especificar sus clases concretas. # patron from abc import ABC , abstractmethod class Memoria ( ABC ): def implementacion ( self ): print ( \"instalando memoria\" ) @abstractmethod def operacion ( self ): pass class Board ( ABC ): def implementacion ( self ): print ( \"instalando board\" ) @abstractmethod def operacion ( self ): pass class Procesador ( ABC ): def implementacion ( self ): print ( \"instalando procesador\" ) @abstractmethod def operacion ( self ): pass class MemoriaAMD ( Memoria ): def operacion ( self ): print ( \"operando memoria AMD\" ) class BoardAMD ( Board ): def operacion ( self ): print ( \"operando board AMD\" ) class ProcesadorAMD ( Procesador ): def operacion ( self ): print ( \"operando procesador AMD\" ) class MemoriaIntel ( Memoria ): def operacion ( self ): print ( \"operando memoria Intel\" ) class BoardIntel ( Board ): def operacion ( self ): print ( \"operando board Intel\" ) class ProcesadorIntel ( Procesador ): def operacion ( self ): print ( \"operando procesador Intel\" ) class MemoriaAlien ( Memoria ): def operacion ( self ): print ( \"operando memoria Alien\" ) class BoardAlien ( Board ): def operacion ( self ): print ( \"operando board Alien\" ) class ProcesadorAlien ( Procesador ): def operacion ( self ): print ( \"operando procesador Alien\" ) class FabricaAbstracta ( ABC ): @abstractmethod def crearMemoria ( self ): pass @abstractmethod def crearProcesador ( self ): pass @abstractmethod def crearBoard ( self ): pass class FabricaAMD ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAMD () def crearProcesador ( self ): return ProcesadorAMD () def crearBoard ( self ): return BoardAMD () class FabricaIntel ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaIntel () def crearProcesador ( self ): return ProcesadorIntel () def crearBoard ( self ): return BoardIntel () class FabricaAlien ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAlien () def crearProcesador ( self ): return ProcesadorAlien () def crearBoard ( self ): return BoardAlien () # ejemplo class EjemploAbstractFactory : def obtener_nombre ( self ): return \"AbstractFactory\" def operacion ( self ): print ( \"Ejemplo Abstract Factory\" ) print ( \"seleccione una fabrica: \\n\\t 0 - AMD \\n\\t 1 - Intel \\n\\t 2 - Alien \" ) fabricas = [ FabricaAMD (), FabricaIntel (), FabricaAlien ()] fabrica = fabricas [ int ( input ())] partes = [ fabrica . crearMemoria (), fabrica . crearProcesador (), fabrica . crearBoard ()] for p in partes : p . implementacion () p . operacion () # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan Otros patrones Builder: Separa la construcci\u00f3n de un objeto complejo de su representaci\u00f3n, de forma que el mismo proceso de construcci\u00f3n pueda crear diferentes representaciones. Factory Method: Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qu\u00e9 clase instanciar. Permite que una clase delegue en sus subclases la creaci\u00f3n de objetos.","title":"Patrones de creaci\u00f3n"},{"location":"patterns/creacionales/#patrones-de-creacion","text":"Los patrones de creaci\u00f3n abstraen la forma en la que se crean los objetos, permitiendo tratar las clases a crear de forma gen\u00e9rica dejando para m\u00e1s tarde la decisi\u00f3n de qu\u00e9 clases crear o c\u00f3mo crearlas.","title":"Patrones de creaci\u00f3n"},{"location":"patterns/creacionales/#singleton","text":"Garantiza que una clase s\u00f3lo tenga una instancia, y proporciona un punto de acceso global a ella. # patron class Singleton (): _instance = None _value = 0 @classmethod def get_instance ( cls ): # Constructor alternativo que retorna una nueva instancia if not cls . _instance : cls . _instance = cls () return cls . _instance def get_value ( self ): return self . _value def set_value ( self , v ): self . _value = v # ejemplo class EjemploSingleton : def obtener_nombre ( self ): return \"Singleton\" def operacion ( self ): print ( \"Ejemplo Singleton\" ) x = Singleton . get_instance () y = Singleton . get_instance () print ( x is y ) y . set_value ( 10 ) print ( x . get_value ()) #resultado EjemploSingleton () . operacion () Ejemplo Singleton True 10","title":"Singleton"},{"location":"patterns/creacionales/#prototype","text":"Especifica los tipos de objetos a crear por medio de una instancia protot\u00edpica, y crear nuevos objetos copiando este prototipo. # ejemplo from abc import ABC , abstractmethod from copy import copy , deepcopy class Animal ( ABC ): def __init__ ( self ): self . __description__ = \"\" self . __number_of_legs__ = 0 self . __name__ = \"\" self . __owner__ = None def hello_animal ( self ): return \"hi i am a \" + self . __name__ + \" and i have \" + str ( self . __number_of_legs__ ) + \" legs, property of: \" + self . __owner__ . get_name () def set_owner ( self , owner ): self . __owner__ = owner ; def get_owner ( self ): return self . __owner__ def change_owner ( self , name ): self . __owner__ . set_name ( name ) def set_description ( self , description ): self . __description__ = description ; def get_description ( self ): return self . __description__ def get_name ( self ): return self . __name__ def set_name ( self , name ): self . __name__ = name ; def get_number_of_legs ( self ): return self . __number_of_legs__ def set_number_of_legs ( self , number_of_legs ): self . __number_of_legs__ = number_of_legs def clone ( self ): return deepcopy ( self ) class Sheep ( Animal ): pass class Chicken ( Animal ): pass class Owner (): def __init__ ( self , name ): self . __name__ = name def get_name ( self ): return self . __name__ ; def set_name ( self , name ): self . __name__ = name ; class AnimalCreator (): def __init__ ( self ): self . __chicken__ = Chicken () self . __sheep__ = Sheep () self . __chicken__ . set_owner ( Owner ( \"Juan\" )) self . __chicken__ . set_description ( \"a litle chicken\" ) self . __chicken__ . set_name ( \"chicken\" ) self . __chicken__ . set_number_of_legs ( 2 ) self . __sheep__ . set_owner ( Owner ( \"Juan\" )) self . __sheep__ . set_description ( \"a litle sheep\" ) self . __sheep__ . set_name ( \"sheep\" ) self . __sheep__ . set_number_of_legs ( 4 ) def retrieve_animal ( self , kind_of_animal ): if \"Chicken\" == kind_of_animal : return self . __chicken__ . clone () elif \"Sheep\" == kind_of_animal : return self . __sheep__ . clone () return None # ejemplo class EjemploPrototype : def obtener_nombre ( self ): return \"Prototype\" def operacion ( self ): print ( \"Ejemplo prototype\" ) creator = AnimalCreator () animals = [] for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Chicken\" )) for i in range ( 4 ): animals . append ( creator . retrieve_animal ( \"Sheep\" )) for i in animals : print ( i . hello_animal ()) animals [ 4 ] . change_owner ( \"Alejandro\" ) for i in animals : print ( i . hello_animal ()) # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan","title":"Prototype"},{"location":"patterns/creacionales/#abstract-factory","text":"Proporciona una interfaz para crear familias de objetos o que dependen entre s\u00ed, sin especificar sus clases concretas. # patron from abc import ABC , abstractmethod class Memoria ( ABC ): def implementacion ( self ): print ( \"instalando memoria\" ) @abstractmethod def operacion ( self ): pass class Board ( ABC ): def implementacion ( self ): print ( \"instalando board\" ) @abstractmethod def operacion ( self ): pass class Procesador ( ABC ): def implementacion ( self ): print ( \"instalando procesador\" ) @abstractmethod def operacion ( self ): pass class MemoriaAMD ( Memoria ): def operacion ( self ): print ( \"operando memoria AMD\" ) class BoardAMD ( Board ): def operacion ( self ): print ( \"operando board AMD\" ) class ProcesadorAMD ( Procesador ): def operacion ( self ): print ( \"operando procesador AMD\" ) class MemoriaIntel ( Memoria ): def operacion ( self ): print ( \"operando memoria Intel\" ) class BoardIntel ( Board ): def operacion ( self ): print ( \"operando board Intel\" ) class ProcesadorIntel ( Procesador ): def operacion ( self ): print ( \"operando procesador Intel\" ) class MemoriaAlien ( Memoria ): def operacion ( self ): print ( \"operando memoria Alien\" ) class BoardAlien ( Board ): def operacion ( self ): print ( \"operando board Alien\" ) class ProcesadorAlien ( Procesador ): def operacion ( self ): print ( \"operando procesador Alien\" ) class FabricaAbstracta ( ABC ): @abstractmethod def crearMemoria ( self ): pass @abstractmethod def crearProcesador ( self ): pass @abstractmethod def crearBoard ( self ): pass class FabricaAMD ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAMD () def crearProcesador ( self ): return ProcesadorAMD () def crearBoard ( self ): return BoardAMD () class FabricaIntel ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaIntel () def crearProcesador ( self ): return ProcesadorIntel () def crearBoard ( self ): return BoardIntel () class FabricaAlien ( FabricaAbstracta ): def crearMemoria ( self ): return MemoriaAlien () def crearProcesador ( self ): return ProcesadorAlien () def crearBoard ( self ): return BoardAlien () # ejemplo class EjemploAbstractFactory : def obtener_nombre ( self ): return \"AbstractFactory\" def operacion ( self ): print ( \"Ejemplo Abstract Factory\" ) print ( \"seleccione una fabrica: \\n\\t 0 - AMD \\n\\t 1 - Intel \\n\\t 2 - Alien \" ) fabricas = [ FabricaAMD (), FabricaIntel (), FabricaAlien ()] fabrica = fabricas [ int ( input ())] partes = [ fabrica . crearMemoria (), fabrica . crearProcesador (), fabrica . crearBoard ()] for p in partes : p . implementacion () p . operacion () # resultado EjemploPrototype () . operacion () Ejemplo prototype hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a chicken and i have 2 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Alejandro hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan hi i am a sheep and i have 4 legs, property of: Juan","title":"Abstract Factory"},{"location":"patterns/creacionales/#otros-patrones","text":"Builder: Separa la construcci\u00f3n de un objeto complejo de su representaci\u00f3n, de forma que el mismo proceso de construcci\u00f3n pueda crear diferentes representaciones. Factory Method: Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qu\u00e9 clase instanciar. Permite que una clase delegue en sus subclases la creaci\u00f3n de objetos.","title":"Otros patrones"},{"location":"patterns/estructurales/","text":"Patrones estructurales Tratan de conseguir que cambios en los requisitos de la aplicaci\u00f3n no ocasionen cambios en las relaciones entre los objetos. Lo fundamental son las relaciones de uso entre los objetos, y, \u00e9stas est\u00e1n determinadas por las interfaces que soportan los objetos. Estudian como se relacionan los objetos en tiempo de ejecuci\u00f3n. Sirven para dise\u00f1ar las interconexiones entre los objetos. Adapter Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permiten que cooperen clases que de otra manera no podr\u00edan por tener interfaces incompatibles. # patron class Adaptado (): def escribir_reves ( self ): return \"retpada ed olpmeje nU\" class Objetivo (): def escribir ( self ): pass class Original ( Objetivo ): def escribir ( self ): return \"Un ejemplo de adapter\" class Adaptador ( Objetivo ): def __init__ ( self ): self . __adaptado__ = Adaptado () def escribir ( self ): return \"(Traduccion) \" + (( self . __adaptado__ . escribir_reves ())[:: - 1 ]) # ejemplo class EjemploAdapter : def obtener_nombre ( self ): return \"Adapter\" def operacion ( self ): print ( \"Ejemplo adapter\" ) print ( \"Objeto original\" ) original = Original () print ( original . escribir ()) print ( \"Objeto a adaptar\" ) adaptado = Adaptado () print ( adaptado . escribir_reves ()) print ( \"Objeto adaptado\" ) adaptador = Adaptador () print ( adaptador . escribir ()) #resultado EjemploAdapter () . operacion () Ejemplo adapter Objeto original Un ejemplo de adapter Objeto a adaptar retpada ed olpmeje nU Objeto adaptado (Traduccion) Un ejemplo de adapter Bridge Desvincula una abstracci\u00f3n de su implementaci\u00f3n, de manera que ambas puedan variar de forma independiente. # patron class Abstraccion (): def __init__ ( self , implementador ): self . __imp__ = implementador def operacion ( self ): return self . __imp__ . operacion_implementada () class AbstraccionRefinada ( Abstraccion ): def operacion_refinada ( self ): return self . __imp__ . operacion_implementada_refinada () class Implementador (): def operacion_implementada ( self ): pass class ImplementadorRefinado ( Implementador ): def operacion_implementada_refinada ( self ): pass class ImplementadorConcretoA ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta A\" class ImplementadorConcretoB ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta B\" class ImpelmentadorConcretoC ( ImplementadorRefinado ): def operacion_implementada ( self ): return \"operacion concreta C\" def operacion_implementada_refinada ( self ): return \"operacion refinada C\" # ejemplo class EjemploBridge : def obtener_nombre ( self ): return \"Bridge\" def operacion ( self ): print ( \"Ejemplo bridge\" ) objeto = Abstraccion ( ImplementadorConcretoB ()) print ( objeto . operacion ()) objeto_refinado = AbstraccionRefinada ( ImpelmentadorConcretoC ()) print ( objeto_refinado . operacion ()) print ( objeto_refinado . operacion_refinada ()) # resultado EjemploBridge () . operacion () Ejemplo bridge operacion concreta B operacion concreta C operacion refinada C Composite Combina objetos en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos. # patron class Componente (): def operacion ( self ): pass class Compuesto ( Componente ): def __init__ ( self ): self . __elementos__ = [] def operacion ( self ): print ( \"operacion de compuesto\" ) for e in self . __elementos__ : e . operacion () def agregar_elemento ( self , elemento ): self . __elementos__ . append ( elemento ) class Simple ( Componente ): def operacion ( self ): print ( \"operacion simple\" ) # ejemplo class EjemploComposite : def obtener_nombre ( self ): return \"Composite\" def operacion ( self ): print ( \"Ejemplo composite\" ) elemento = Compuesto () for i in range ( 5 ): elemento . agregar_elemento ( Simple ()) elemento2 = Compuesto () elemento2 . agregar_elemento ( Simple ()) elemento . agregar_elemento ( elemento2 ) elemento . operacion () # resultado EjemploComposite () . operacion () Ejemplo composite operacion de compuesto operacion simple operacion simple operacion simple operacion simple operacion simple operacion de compuesto operacion simple Decorator A\u00f1ade din\u00e1micamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad. # patron class Componente (): def operacion ( self ): pass class ComponenteConcreto ( Componente ): def operacion ( self ): print ( \"operacion concreta\" ) class Decorador ( Componente ): def __init__ ( self , componente ): self . __comp__ = componente def operacion ( self ): pass class DecoradorConcretoA ( Decorador ): def operacion ( self ): print ( \"operacion decorada por A\" ) self . __comp__ . operacion () class DecoradorConcretoB ( Decorador ): def operacion ( self ): print ( \"operacion decorada por B\" ) self . __comp__ . operacion () # ejemplo class EjemploDecorator : def obtener_nombre ( self ): return \"Decorator\" def operacion ( self ): print ( \"Ejemplo decorator\" ) objeto = ComponenteConcreto () objeto . operacion () print ( \"-\" * 10 ) decorador1 = DecoradorConcretoA ( objeto ) decorador1 . operacion () print ( \"-\" * 10 ) decorador2 = DecoradorConcretoB ( decorador1 ) decorador2 . operacion () # resultado EjemploDecorator () . operacion () Ejemplo decorator operacion concreta ---------- operacion decorada por A operacion concreta ---------- operacion decorada por B operacion decorada por A operacion concreta Facade Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema se m\u00e1s f\u00e1cil de usar. # patron class BibliotecaLibros : def buscar_libros ( self ): return \"buscando libros\" class BibliotecaMusica : def buscar_musica ( self ): return \"buscando musica\" class BibliotecaVideos : def buscar_videos ( self ): return \"buscando videos\" class Fachada : def __init__ ( self ): self . biblioteca_libros = BibliotecaLibros () self . biblioteca_musica = BibliotecaMusica () self . biblioteca_videos = BibliotecaVideos () def buscar_libros ( self ): return self . biblioteca_libros . buscar_libros () def buscar_musica ( self ): return self . biblioteca_musica . buscar_musica () def buscar_videos ( self ): return self . biblioteca_videos . buscar_videos () # ejemplo class EjemploFachada : def obtener_nombre ( self ): return \"Fachada\" def operacion ( self ): print ( \"Ejemplo fachada\" ) fachada = Fachada () print ( fachada . buscar_libros ()) print ( fachada . buscar_musica ()) print ( fachada . buscar_videos ()) # resultado EjemploFachada () . operacion () Ejemplo fachada buscando libros buscando musica buscando videos Flyweight Usa el compartimiento para permitir un gran n\u00famero de objetos de grano fino de forma eficiente. # patron class Flyweight : def operacion ( self ): pass class ConcreteFlyweight ( Flyweight ): def operacion ( self ): return \"Operaci\u00f3n del peso ligero concreto clear\" class UnshareFlyweight ( Flyweight ): def __init__ ( self , concreto , contador ): self . concreto = concreto self . contador = contador def operacion ( self ): return self . concreto . operacion () + str ( self . contador ) class FlyweightFactory : def __init__ ( self ): self . concreto = None self . contador = 0 def entregar_flyweight ( self ): if self . concreto == None : self . concreto = ConcreteFlyweight () self . contador += 1 return UnshareFlyweight ( self . concreto , self . contador ) # ejemplo class EjemploFlyweight : def obtener_nombre ( self ): return \"Flyweight\" def operacion ( self ): print ( \"Ejemplo flyweight\" ) factoria = FlyweightFactory () flyweights = [] for i in range ( 10 ): flyweights . append ( factoria . entregar_flyweight ()) print ( flyweights [ 0 ] . concreto == flyweights [ 2 ] . concreto ) for f in flyweights : print ( f . operacion ()) # resultado EjemploFlyweight () . operacion () Ejemplo flyweight True Operaci\u00f3n del peso ligero concreto clear1 Operaci\u00f3n del peso ligero concreto clear2 Operaci\u00f3n del peso ligero concreto clear3 Operaci\u00f3n del peso ligero concreto clear4 Operaci\u00f3n del peso ligero concreto clear5 Operaci\u00f3n del peso ligero concreto clear6 Operaci\u00f3n del peso ligero concreto clear7 Operaci\u00f3n del peso ligero concreto clear8 Operaci\u00f3n del peso ligero concreto clear9 Operaci\u00f3n del peso ligero concreto clear10 Proxy Proporciona un sustituto o representante de otro objeto para controlar el acceso a \u00e9ste. # patron class Subject : def peticion ( self ): pass class RealSubject ( Subject ): def peticion ( self ): return \"operaci\u00f3n del objeto real\" class Proxy ( Subject ): def __init__ ( self , objeto ): self . objeto = objeto def peticion ( self ): return \"Mediante el proxy -> \" + self . objeto . peticion () # ejemplo class EjemploProxy : def obtener_nombre ( self ): return \"Proxy\" def operacion ( self ): print ( \"Ejemplo proxy\" ) proxy = Proxy ( RealSubject ()) print ( proxy . peticion ()) # resultado EjemploProxy () . operacion () Ejemplo proxy Mediante el proxy -> operaci\u00f3n del objeto real","title":"Patrones estructurales"},{"location":"patterns/estructurales/#patrones-estructurales","text":"Tratan de conseguir que cambios en los requisitos de la aplicaci\u00f3n no ocasionen cambios en las relaciones entre los objetos. Lo fundamental son las relaciones de uso entre los objetos, y, \u00e9stas est\u00e1n determinadas por las interfaces que soportan los objetos. Estudian como se relacionan los objetos en tiempo de ejecuci\u00f3n. Sirven para dise\u00f1ar las interconexiones entre los objetos.","title":"Patrones estructurales"},{"location":"patterns/estructurales/#adapter","text":"Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permiten que cooperen clases que de otra manera no podr\u00edan por tener interfaces incompatibles. # patron class Adaptado (): def escribir_reves ( self ): return \"retpada ed olpmeje nU\" class Objetivo (): def escribir ( self ): pass class Original ( Objetivo ): def escribir ( self ): return \"Un ejemplo de adapter\" class Adaptador ( Objetivo ): def __init__ ( self ): self . __adaptado__ = Adaptado () def escribir ( self ): return \"(Traduccion) \" + (( self . __adaptado__ . escribir_reves ())[:: - 1 ]) # ejemplo class EjemploAdapter : def obtener_nombre ( self ): return \"Adapter\" def operacion ( self ): print ( \"Ejemplo adapter\" ) print ( \"Objeto original\" ) original = Original () print ( original . escribir ()) print ( \"Objeto a adaptar\" ) adaptado = Adaptado () print ( adaptado . escribir_reves ()) print ( \"Objeto adaptado\" ) adaptador = Adaptador () print ( adaptador . escribir ()) #resultado EjemploAdapter () . operacion () Ejemplo adapter Objeto original Un ejemplo de adapter Objeto a adaptar retpada ed olpmeje nU Objeto adaptado (Traduccion) Un ejemplo de adapter","title":"Adapter"},{"location":"patterns/estructurales/#bridge","text":"Desvincula una abstracci\u00f3n de su implementaci\u00f3n, de manera que ambas puedan variar de forma independiente. # patron class Abstraccion (): def __init__ ( self , implementador ): self . __imp__ = implementador def operacion ( self ): return self . __imp__ . operacion_implementada () class AbstraccionRefinada ( Abstraccion ): def operacion_refinada ( self ): return self . __imp__ . operacion_implementada_refinada () class Implementador (): def operacion_implementada ( self ): pass class ImplementadorRefinado ( Implementador ): def operacion_implementada_refinada ( self ): pass class ImplementadorConcretoA ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta A\" class ImplementadorConcretoB ( Implementador ): def operacion_implementada ( self ): return \"operacion concreta B\" class ImpelmentadorConcretoC ( ImplementadorRefinado ): def operacion_implementada ( self ): return \"operacion concreta C\" def operacion_implementada_refinada ( self ): return \"operacion refinada C\" # ejemplo class EjemploBridge : def obtener_nombre ( self ): return \"Bridge\" def operacion ( self ): print ( \"Ejemplo bridge\" ) objeto = Abstraccion ( ImplementadorConcretoB ()) print ( objeto . operacion ()) objeto_refinado = AbstraccionRefinada ( ImpelmentadorConcretoC ()) print ( objeto_refinado . operacion ()) print ( objeto_refinado . operacion_refinada ()) # resultado EjemploBridge () . operacion () Ejemplo bridge operacion concreta B operacion concreta C operacion refinada C","title":"Bridge"},{"location":"patterns/estructurales/#composite","text":"Combina objetos en estructuras de \u00e1rbol para representar jerarqu\u00edas de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos. # patron class Componente (): def operacion ( self ): pass class Compuesto ( Componente ): def __init__ ( self ): self . __elementos__ = [] def operacion ( self ): print ( \"operacion de compuesto\" ) for e in self . __elementos__ : e . operacion () def agregar_elemento ( self , elemento ): self . __elementos__ . append ( elemento ) class Simple ( Componente ): def operacion ( self ): print ( \"operacion simple\" ) # ejemplo class EjemploComposite : def obtener_nombre ( self ): return \"Composite\" def operacion ( self ): print ( \"Ejemplo composite\" ) elemento = Compuesto () for i in range ( 5 ): elemento . agregar_elemento ( Simple ()) elemento2 = Compuesto () elemento2 . agregar_elemento ( Simple ()) elemento . agregar_elemento ( elemento2 ) elemento . operacion () # resultado EjemploComposite () . operacion () Ejemplo composite operacion de compuesto operacion simple operacion simple operacion simple operacion simple operacion simple operacion de compuesto operacion simple","title":"Composite"},{"location":"patterns/estructurales/#decorator","text":"A\u00f1ade din\u00e1micamente nuevas responsabilidades a un objeto, proporcionando una alternativa flexible a la herencia para extender la funcionalidad. # patron class Componente (): def operacion ( self ): pass class ComponenteConcreto ( Componente ): def operacion ( self ): print ( \"operacion concreta\" ) class Decorador ( Componente ): def __init__ ( self , componente ): self . __comp__ = componente def operacion ( self ): pass class DecoradorConcretoA ( Decorador ): def operacion ( self ): print ( \"operacion decorada por A\" ) self . __comp__ . operacion () class DecoradorConcretoB ( Decorador ): def operacion ( self ): print ( \"operacion decorada por B\" ) self . __comp__ . operacion () # ejemplo class EjemploDecorator : def obtener_nombre ( self ): return \"Decorator\" def operacion ( self ): print ( \"Ejemplo decorator\" ) objeto = ComponenteConcreto () objeto . operacion () print ( \"-\" * 10 ) decorador1 = DecoradorConcretoA ( objeto ) decorador1 . operacion () print ( \"-\" * 10 ) decorador2 = DecoradorConcretoB ( decorador1 ) decorador2 . operacion () # resultado EjemploDecorator () . operacion () Ejemplo decorator operacion concreta ---------- operacion decorada por A operacion concreta ---------- operacion decorada por B operacion decorada por A operacion concreta","title":"Decorator"},{"location":"patterns/estructurales/#facade","text":"Proporciona una interfaz unificada para un conjunto de interfaces de un subsistema. Define una interfaz de alto nivel que hace que el subsistema se m\u00e1s f\u00e1cil de usar. # patron class BibliotecaLibros : def buscar_libros ( self ): return \"buscando libros\" class BibliotecaMusica : def buscar_musica ( self ): return \"buscando musica\" class BibliotecaVideos : def buscar_videos ( self ): return \"buscando videos\" class Fachada : def __init__ ( self ): self . biblioteca_libros = BibliotecaLibros () self . biblioteca_musica = BibliotecaMusica () self . biblioteca_videos = BibliotecaVideos () def buscar_libros ( self ): return self . biblioteca_libros . buscar_libros () def buscar_musica ( self ): return self . biblioteca_musica . buscar_musica () def buscar_videos ( self ): return self . biblioteca_videos . buscar_videos () # ejemplo class EjemploFachada : def obtener_nombre ( self ): return \"Fachada\" def operacion ( self ): print ( \"Ejemplo fachada\" ) fachada = Fachada () print ( fachada . buscar_libros ()) print ( fachada . buscar_musica ()) print ( fachada . buscar_videos ()) # resultado EjemploFachada () . operacion () Ejemplo fachada buscando libros buscando musica buscando videos","title":"Facade"},{"location":"patterns/estructurales/#flyweight","text":"Usa el compartimiento para permitir un gran n\u00famero de objetos de grano fino de forma eficiente. # patron class Flyweight : def operacion ( self ): pass class ConcreteFlyweight ( Flyweight ): def operacion ( self ): return \"Operaci\u00f3n del peso ligero concreto clear\" class UnshareFlyweight ( Flyweight ): def __init__ ( self , concreto , contador ): self . concreto = concreto self . contador = contador def operacion ( self ): return self . concreto . operacion () + str ( self . contador ) class FlyweightFactory : def __init__ ( self ): self . concreto = None self . contador = 0 def entregar_flyweight ( self ): if self . concreto == None : self . concreto = ConcreteFlyweight () self . contador += 1 return UnshareFlyweight ( self . concreto , self . contador ) # ejemplo class EjemploFlyweight : def obtener_nombre ( self ): return \"Flyweight\" def operacion ( self ): print ( \"Ejemplo flyweight\" ) factoria = FlyweightFactory () flyweights = [] for i in range ( 10 ): flyweights . append ( factoria . entregar_flyweight ()) print ( flyweights [ 0 ] . concreto == flyweights [ 2 ] . concreto ) for f in flyweights : print ( f . operacion ()) # resultado EjemploFlyweight () . operacion () Ejemplo flyweight True Operaci\u00f3n del peso ligero concreto clear1 Operaci\u00f3n del peso ligero concreto clear2 Operaci\u00f3n del peso ligero concreto clear3 Operaci\u00f3n del peso ligero concreto clear4 Operaci\u00f3n del peso ligero concreto clear5 Operaci\u00f3n del peso ligero concreto clear6 Operaci\u00f3n del peso ligero concreto clear7 Operaci\u00f3n del peso ligero concreto clear8 Operaci\u00f3n del peso ligero concreto clear9 Operaci\u00f3n del peso ligero concreto clear10","title":"Flyweight"},{"location":"patterns/estructurales/#proxy","text":"Proporciona un sustituto o representante de otro objeto para controlar el acceso a \u00e9ste. # patron class Subject : def peticion ( self ): pass class RealSubject ( Subject ): def peticion ( self ): return \"operaci\u00f3n del objeto real\" class Proxy ( Subject ): def __init__ ( self , objeto ): self . objeto = objeto def peticion ( self ): return \"Mediante el proxy -> \" + self . objeto . peticion () # ejemplo class EjemploProxy : def obtener_nombre ( self ): return \"Proxy\" def operacion ( self ): print ( \"Ejemplo proxy\" ) proxy = Proxy ( RealSubject ()) print ( proxy . peticion ()) # resultado EjemploProxy () . operacion () Ejemplo proxy Mediante el proxy -> operaci\u00f3n del objeto real","title":"Proxy"},{"location":"patterns/intro/","text":"Introducci\u00f3n El dise\u00f1o de software orientado a objetos es, en cierta forma, dif\u00edcil, si a esta tarea sumamos que el software dise\u00f1ado debe tener ciertas caracter\u00edsticas deseables como la reusabilidad, flexibilidad y portabilidad entre otras, la tarea es aun m\u00e1s dif\u00edcil. Algo que conocen muy bien los dise\u00f1adores con cierta experiencia, es que no se puede afrontar cada problema desde cero, por lo general reutilizan soluciones que han trabajado en el pasado y que han representado buenas soluciones a los problemas planteados. Si estas soluciones les sirven de manera recurrente y estas les brindan las caracter\u00edsticas deseables en el software mencionadas arriba, probablemente se encuentran ante un patr\u00f3n de dise\u00f1o. \u00bfQu\u00e9 son los patrones de dise\u00f1o? Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Los patrones de dise\u00f1o son un conjunto de pr\u00e1cticas de \u00f3ptimo dise\u00f1o que se utilizan para abordar problemas recurrentes en la programaci\u00f3n orientada a objetos. El concepto de patrones de dise\u00f1o fue el resultado de un trabajo realizado por un grupo de 4 personas Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides, (Gang of four) que se public\u00f3 en los 90s en un libro titulado \"Design Patterns. Elements of Reusable Object-Oriented Software\" en el que se esbozaban 23 patrones de dise\u00f1o. Un patr\u00f3n de dise\u00f1o puede considerarse como un documento que define una estructura de clases que aborda una situaci\u00f3n particular. Para que una soluci\u00f3n sea considerada un patr\u00f3n debe poseer ciertas caracter\u00edsticas. Una de ellas es que debe haber comprobado su efectividad resolviendo problemas similares en ocasiones anteriores. Otra es que debe ser reusable, lo que significa que es aplicable a diferentes problemas de dise\u00f1o en distintas circunstancias. Los patrones de dise\u00f1o representa un nivel de abstracci\u00f3n un poco mas elevado de lo que hasta ahora el estudiante esta habituado a trabajar, pero una vez entendido su funcionamiento y utilidad, los dise\u00f1os ser\u00e1n mucho m\u00e1s flexibles, modulares y reutilizables. En esencia un patr\u00f3n tiene los siguientes 4 elementos: Nombre del patr\u00f3n: describe el problema de dise\u00f1o, su soluci\u00f3n y consecuencias en una o dos palabras. El problema: describe cuando aplicar el patr\u00f3n, explica el problema y su contexto. La soluci\u00f3n: describe los elementos del dise\u00f1o, sus relaciones, responsabilidades y colaboraciones. No describe la implementaci\u00f3n o un dise\u00f1o particular espec\u00edficamente ya que se adapta mas a una plantilla (template) que puede ser aplicada a varias situaciones. Las consecuencias: son los resultados de aplicar el patr\u00f3n, los pros y contras de su aplicaci\u00f3n. Las consecuencias de la aplicaci\u00f3n de un patr\u00f3n debe incluir el impacto en la flexibilidad, extensibilidad y/o portabilidad del sistema. Estructuras o plantillas de patrones Para describir un patr\u00f3n se utilizan plantillas m\u00e1s o menos estandarizadas, de forma que se expresen uniformemente y puedan constituir efectivamente un medio de comunicaci\u00f3n uniforme entre dise\u00f1adores. La plantilla m\u00e1s com\u00fan es la utilizada precisamente por el \u201cGang of Four\u201d y consta de los siguientes apartados: Nombre del patr\u00f3n: nombre est\u00e1ndar del patr\u00f3n por el cual ser\u00e1 reconocido en la comunidad (normalmente se expresan en ingl\u00e9s). Clasificaci\u00f3n del patr\u00f3n: creacional, estructural o de comportamiento. Intenci\u00f3n: \u00bfQu\u00e9 problema pretende resolver el patr\u00f3n? Tambi\u00e9n conocido como: Otros nombres de uso com\u00fan para el patr\u00f3n. Motivaci\u00f3n: Escenario de ejemplo para la aplicaci\u00f3n del patr\u00f3n. Aplicabilidad: Usos comunes y criterios de aplicabilidad del patr\u00f3n. Estructura: Diagramas de clases oportunos para describir las clases que intervienen en el patr\u00f3n. Participantes: Enumeraci\u00f3n y descripci\u00f3n de las entidades abstractas (y sus roles) que participan en el patr\u00f3n. Colaboraciones: Explicaci\u00f3n de las interrelaciones que se dan entre los participantes. Consecuencias: Consecuencias positivas y negativas en el dise\u00f1o derivadas de la aplicaci\u00f3n del patr\u00f3n. Implementaci\u00f3n: T\u00e9cnicas o comentarios oportunos de cara a la implementaci\u00f3n del patr\u00f3n. C\u00f3digo de ejemplo: C\u00f3digo fuente ejemplo de implementaci\u00f3n del patr\u00f3n. Usos conocidos: Ejemplos de sistemas reales que usan el patr\u00f3n. Patrones relacionados: Referencias cruzadas con otros patrones. Referencias bibliogr\u00e1ficas Design Patterns. Elements of Reusable Object-Oriented Software - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides - Addison Wesley (GoF- Gang of Four) Patrones de Dise\u00f1o, Dise\u00f1o de Software Orientado a Objetos - Joaquin Garcia. http://www.ingenierosoftware.com/analisisydiseno/patrones-diseno.php. Patrones de dise\u00f1o - http://es.kioskea.net/contents/genie-logiciel/design-patterns.php3. Introducci\u00f3n al dise\u00f1o con patrones \u2013 Miguel Lagos Torres. http://www.elrincondelprogramador.com/default.asp?pag=articulos/leer.asp&id=29. Object Oriented Desing \u201cSoftware Desing Principles and Design Patters, http://www.oodesing.com","title":"Introduccion"},{"location":"patterns/intro/#introduccion","text":"El dise\u00f1o de software orientado a objetos es, en cierta forma, dif\u00edcil, si a esta tarea sumamos que el software dise\u00f1ado debe tener ciertas caracter\u00edsticas deseables como la reusabilidad, flexibilidad y portabilidad entre otras, la tarea es aun m\u00e1s dif\u00edcil. Algo que conocen muy bien los dise\u00f1adores con cierta experiencia, es que no se puede afrontar cada problema desde cero, por lo general reutilizan soluciones que han trabajado en el pasado y que han representado buenas soluciones a los problemas planteados. Si estas soluciones les sirven de manera recurrente y estas les brindan las caracter\u00edsticas deseables en el software mencionadas arriba, probablemente se encuentran ante un patr\u00f3n de dise\u00f1o.","title":"Introducci\u00f3n"},{"location":"patterns/intro/#que-son-los-patrones-de-diseno","text":"Los patrones de dise\u00f1o son la base para la b\u00fasqueda de soluciones a problemas comunes en el desarrollo de software y otros \u00e1mbitos referentes al dise\u00f1o de interacci\u00f3n o interfaces. Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema de dise\u00f1o. Los patrones de dise\u00f1o son un conjunto de pr\u00e1cticas de \u00f3ptimo dise\u00f1o que se utilizan para abordar problemas recurrentes en la programaci\u00f3n orientada a objetos. El concepto de patrones de dise\u00f1o fue el resultado de un trabajo realizado por un grupo de 4 personas Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides, (Gang of four) que se public\u00f3 en los 90s en un libro titulado \"Design Patterns. Elements of Reusable Object-Oriented Software\" en el que se esbozaban 23 patrones de dise\u00f1o. Un patr\u00f3n de dise\u00f1o puede considerarse como un documento que define una estructura de clases que aborda una situaci\u00f3n particular. Para que una soluci\u00f3n sea considerada un patr\u00f3n debe poseer ciertas caracter\u00edsticas. Una de ellas es que debe haber comprobado su efectividad resolviendo problemas similares en ocasiones anteriores. Otra es que debe ser reusable, lo que significa que es aplicable a diferentes problemas de dise\u00f1o en distintas circunstancias. Los patrones de dise\u00f1o representa un nivel de abstracci\u00f3n un poco mas elevado de lo que hasta ahora el estudiante esta habituado a trabajar, pero una vez entendido su funcionamiento y utilidad, los dise\u00f1os ser\u00e1n mucho m\u00e1s flexibles, modulares y reutilizables. En esencia un patr\u00f3n tiene los siguientes 4 elementos: Nombre del patr\u00f3n: describe el problema de dise\u00f1o, su soluci\u00f3n y consecuencias en una o dos palabras. El problema: describe cuando aplicar el patr\u00f3n, explica el problema y su contexto. La soluci\u00f3n: describe los elementos del dise\u00f1o, sus relaciones, responsabilidades y colaboraciones. No describe la implementaci\u00f3n o un dise\u00f1o particular espec\u00edficamente ya que se adapta mas a una plantilla (template) que puede ser aplicada a varias situaciones. Las consecuencias: son los resultados de aplicar el patr\u00f3n, los pros y contras de su aplicaci\u00f3n. Las consecuencias de la aplicaci\u00f3n de un patr\u00f3n debe incluir el impacto en la flexibilidad, extensibilidad y/o portabilidad del sistema.","title":"\u00bfQu\u00e9 son los patrones de dise\u00f1o?"},{"location":"patterns/intro/#estructuras-o-plantillas-de-patrones","text":"Para describir un patr\u00f3n se utilizan plantillas m\u00e1s o menos estandarizadas, de forma que se expresen uniformemente y puedan constituir efectivamente un medio de comunicaci\u00f3n uniforme entre dise\u00f1adores. La plantilla m\u00e1s com\u00fan es la utilizada precisamente por el \u201cGang of Four\u201d y consta de los siguientes apartados: Nombre del patr\u00f3n: nombre est\u00e1ndar del patr\u00f3n por el cual ser\u00e1 reconocido en la comunidad (normalmente se expresan en ingl\u00e9s). Clasificaci\u00f3n del patr\u00f3n: creacional, estructural o de comportamiento. Intenci\u00f3n: \u00bfQu\u00e9 problema pretende resolver el patr\u00f3n? Tambi\u00e9n conocido como: Otros nombres de uso com\u00fan para el patr\u00f3n. Motivaci\u00f3n: Escenario de ejemplo para la aplicaci\u00f3n del patr\u00f3n. Aplicabilidad: Usos comunes y criterios de aplicabilidad del patr\u00f3n. Estructura: Diagramas de clases oportunos para describir las clases que intervienen en el patr\u00f3n. Participantes: Enumeraci\u00f3n y descripci\u00f3n de las entidades abstractas (y sus roles) que participan en el patr\u00f3n. Colaboraciones: Explicaci\u00f3n de las interrelaciones que se dan entre los participantes. Consecuencias: Consecuencias positivas y negativas en el dise\u00f1o derivadas de la aplicaci\u00f3n del patr\u00f3n. Implementaci\u00f3n: T\u00e9cnicas o comentarios oportunos de cara a la implementaci\u00f3n del patr\u00f3n. C\u00f3digo de ejemplo: C\u00f3digo fuente ejemplo de implementaci\u00f3n del patr\u00f3n. Usos conocidos: Ejemplos de sistemas reales que usan el patr\u00f3n. Patrones relacionados: Referencias cruzadas con otros patrones.","title":"Estructuras o plantillas de patrones"},{"location":"patterns/intro/#referencias-bibliograficas","text":"Design Patterns. Elements of Reusable Object-Oriented Software - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides - Addison Wesley (GoF- Gang of Four) Patrones de Dise\u00f1o, Dise\u00f1o de Software Orientado a Objetos - Joaquin Garcia. http://www.ingenierosoftware.com/analisisydiseno/patrones-diseno.php. Patrones de dise\u00f1o - http://es.kioskea.net/contents/genie-logiciel/design-patterns.php3. Introducci\u00f3n al dise\u00f1o con patrones \u2013 Miguel Lagos Torres. http://www.elrincondelprogramador.com/default.asp?pag=articulos/leer.asp&id=29. Object Oriented Desing \u201cSoftware Desing Principles and Design Patters, http://www.oodesing.com","title":"Referencias bibliogr\u00e1ficas"},{"location":"setup/poetry/","text":"Poetry Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted. Instalaci\u00f3n Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda. osx / linux / bashonwindows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python - windows powershell (Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python - Crear un proyecto con poetry Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml . Una configuraci\u00f3n para manejar todo Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite. Poetry CLI La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml . Instalaci\u00f3n y gesti\u00f3n de dependencias poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Poetry"},{"location":"setup/poetry/#poetry","text":"Poetry es una herramienta para la gesti\u00f3n de dependencias y el empaquetado en Python. Le permite declarar las bibliotecas de las que depende su proyecto y las administrar\u00e1 (instalar\u00e1 / actualizar\u00e1) por usted.","title":"Poetry"},{"location":"setup/poetry/#instalacion","text":"Poetry proporciona un instalador personalizado que instalar\u00e1 poetry aislado del resto de su sistema al vender sus dependencias. Esta es la forma recomendada de instalar poes\u00eda.","title":"Instalaci\u00f3n"},{"location":"setup/poetry/#osx-linux-bashonwindows","text":"curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -","title":"osx / linux / bashonwindows"},{"location":"setup/poetry/#windows-powershell","text":"(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python -","title":"windows powershell"},{"location":"setup/poetry/#crear-un-proyecto-con-poetry","text":"Poetry agiliza no solo la gesti\u00f3n de dependencias, sino casi todo lo que implica la estructuraci\u00f3n de un proyecto Python. Poetry tiene una CLI robusta, que nos permite crear y configurar proyectos Python f\u00e1cilmente. As\u00ed es como se ve empezar de cero: poetry new poetry-tutorial-project Esta es una forma absurdamente conveniente de generar una estructura de carpetas est\u00e1ndar de Python para nuestro nuevo proyecto llamado poetry-tutorial-project : /poetry-tutorial-project \u251c\u2500\u2500 README.md \u251c\u2500\u2500 poetry_tutorial_project \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_tutorial_project.py Esto nos ahorra la molestia de crear manualmente esta estructura de carpetas est\u00e1ndar nosotros mismos. La mayor parte del contenido del archivo est\u00e1 vac\u00edo, con una excepci\u00f3n: pyproject.toml .","title":"Crear un proyecto con poetry"},{"location":"setup/poetry/#una-configuracion-para-manejar-todo","text":"Cada proyecto de Poetry est\u00e1 contenida en un archivo llamado pyproject.toml . Aqu\u00ed es donde definimos todo, desde los metadatos, las dependencias, los scripts y m\u00e1s de nuestro proyecto. Si est\u00e1 familiarizado con Node, piense en pyproject.toml como el equivalente en Python de package.json. Comenzar un nuevo proyecto de poes\u00eda crea autom\u00e1ticamente una versi\u00f3n m\u00ednima de este archivo. [tool.poetry] name = \"poetry-tutorial-project\" version = \"0.1.0\" description = \"\" authors = [ \"Todd Birchard <todd@example.com>\" ] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^4.6\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" La configuraci\u00f3n anterior tiene informaci\u00f3n b\u00e1sica, pero a\u00fan no es suficiente para ser \u00fatil. Un archivo pyproject.toml completo se ver\u00eda as\u00ed: [tool.poetry] name = \"poetry_tutorial_project\" version = \"0.1.0\" description = \"Simple Python project built with Poetry.\" authors = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] maintainers = [ \"Todd Birchard <toddbirchard@gmail.com>\" ] license = \"MIT\" readme = \"README.md\" homepage = \"\" repository = \"https://github.com/hackersandslackers/python-poetry-tutorial/\" documentation = \"https://hackersandslackers.com/python-poetry/\" keywords = [ \"Poetry\" , \"Virtual Environments\" , \"Tutorial\" , \"Packages\" , \"Packaging\" ] [tool.poetry.dependencies] python = \"^3.7\" loguru = \"*\" psutil = \"*\" [tool.poetry.dev-dependencies] pytest = \"*\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" [tool.poetry.scripts] run = \"wsgi:main\" [tool.poetry.urls] issues = \"https://github.com/hackersandslackers/python-poetry-tutorial/issues\" Ahora estamos cocinando con gas! Nuestro archivo .toml ahora se compone de 6 secciones, donde cada secci\u00f3n contiene valores de configuraci\u00f3n para nuestro proyecto: [tool.poetry] : La primera secci\u00f3n de pyproject.toml es simplemente metadatos informativos sobre nuestro paquete, como el nombre del paquete, la descripci\u00f3n, los detalles del autor, etc. La mayor\u00eda de los valores de configuraci\u00f3n aqu\u00ed son opcionales a menos que est\u00e9 planeando publicar esto proyecto como paquete oficial de PyPi. Proporcionar valores para el repositorio y las palabras clave no importar\u00e1 si no distribuye este paquete. A\u00fan as\u00ed, este tipo de metadatos ser\u00eda fundamental si alguna vez espera distribuir su paquete. [tool.poetry.dependencies] : Aqu\u00ed es donde definimos las dependencias que nuestra aplicaci\u00f3n debe descargar para ejecutarse. Puede especificar n\u00fameros de versi\u00f3n espec\u00edficos para los paquetes requeridos (como Flask = \"1.0.0\" ), o si simplemente desea obtener la \u00faltima versi\u00f3n, configurar la versi\u00f3n en \"*\" har\u00e1 precisamente eso. Tambi\u00e9n notar\u00e1 que la versi\u00f3n de Python a la que nos dirigimos para nuestro proyecto tambi\u00e9n se proporciona aqu\u00ed: esto especifica la versi\u00f3n m\u00ednima requerida para ejecutar nuestra aplicaci\u00f3n. En el ejemplo anterior, un usuario que ejecute Python 3.6 no podr\u00e1 ejecutar esta aplicaci\u00f3n, ya que especificamos que Python 3.7 es la versi\u00f3n m\u00e1s baja requerida. [tool.poetry.dev-dependencies] : las dependencias de desarrollo son paquetes que los desarrolladores que contribuyen deben descargar para iterar en este proyecto. Las dependencias de desarrollo no son necesarias para ejecutar la aplicaci\u00f3n y no se descargar\u00e1n cuando la aplicaci\u00f3n se compile de forma predeterminada. [build-system] : Rara vez es una secci\u00f3n que necesitar\u00e1s tocar a menos que actualices tu versi\u00f3n de poetry. [tool.poetry.scripts] : Aqu\u00ed es donde especificamos d\u00f3nde est\u00e1n los puntos de entrada de nuestra aplicaci\u00f3n asignando una funci\u00f3n dentro de los m\u00f3dulos al nombre de un script que se ejecutar\u00e1. El ejemplo run = \"wsgi: main\" especifica que queremos crear un comando llamado \"run\", que buscar\u00e1 en wsgi.py una funci\u00f3n llamada main() . Con este conjunto, podemos lanzar nuestra aplicaci\u00f3n a trav\u00e9s de la poetry CLI escribiendo poetry run (m\u00e1s sobre esto en un momento). [tool.poetry.urls] : Esta es una secci\u00f3n completamente opcional donde puede agregar cualquier n\u00famero de enlaces o recursos \u00fatiles que alguien que descargue este paquete pueda encontrar \u00fatil. Una configuraci\u00f3n como la anterior es m\u00e1s que suficiente para tener una aplicaci\u00f3n empaquetada limpia y funcional. Poetry tambi\u00e9n admite otros tipos de valores de configuraci\u00f3n, aunque es probable que rara vez los necesite.","title":"Una configuraci\u00f3n para manejar todo"},{"location":"setup/poetry/#poetry-cli","text":"La interfaz de l\u00ednea de comandos de Poetry es impresionantemente simplista para el alcance de lo que logra. Poetry cubre la funcionalidad equivalente de Pipenv y setup.py , as\u00ed como muchas otras caracter\u00edsticas relacionadas con la administraci\u00f3n de la configuraci\u00f3n y la publicaci\u00f3n de paquetes. Comenzaremos instalando y administrando las dependencias que acabamos de configurar en pyproject.toml .","title":"Poetry CLI"},{"location":"setup/poetry/#instalacion-y-gestion-de-dependencias","text":"poetry shell : la primera vez que se ejecuta este comando en el directorio de su proyecto, Poetry crea un entorno virtual de Python que estar\u00e1 asociado para siempre con este proyecto. En lugar de crear una carpeta que contenga sus bibliotecas de dependencia (como hace virtualenv), Poetry crea un entorno en una ruta de sistema global, por lo tanto, separa el c\u00f3digo fuente de dependencia de su proyecto. Una vez que se crea este entorno virtual, se puede activar de nuevo en cualquier momento simplemente ejecutando poetry shell en el directorio de su proyecto en el futuro. Intente comparar la salida que python antes y despu\u00e9s de activar el shell de su proyecto para ver c\u00f3mo Poetry maneja los entornos virtuales. poetry install : instala las dependencias especificadas en pyproject.toml . La primera vez que se instalan las dependencias de un proyecto, se crea un archivo poetry.lock , que contiene los n\u00fameros de versi\u00f3n reales de cada paquete que se instal\u00f3 (es decir, si Flask = \"*\" result\u00f3 en la descarga de Flask versi\u00f3n 1.0.0 , el n\u00famero de versi\u00f3n real se almacenar\u00eda en poetry.lock ). Si hay un archivo poetry.lock , los n\u00fameros de versi\u00f3n en poetry.lock siempre tendr\u00e1n prioridad sobre lo que est\u00e1 en pyproject.toml . C\u00f3mo buena pr\u00e1ctica, se debe mantener tanto pyproject.toml como poetry.lock en tu control de versi\u00f3n poetry update : imita la funcionalidad de install , con la excepci\u00f3n de que los n\u00fameros de versi\u00f3n en .lock NO se respetar\u00e1n. Si existen versiones m\u00e1s nuevas para los paquetes en pyproject.toml, se instalar\u00e1n versiones m\u00e1s nuevas y .lock se actualizar\u00e1 en consecuencia. poetry add [package-name] : Un atajo para agregar una dependencia a pyproject.toml. El paquete se instala inmediatamente despu\u00e9s de agregarlo. poetry remove [package-name] : Lo contrario de lo anterior. poetry export -f requirements.txt> requirements.txt : exporta el contenido del archivo .lock de su proyecto a requirements.txt. Resulta \u00fatil cuando se entrega el trabajo a los desarrolladores que todav\u00eda usan requirements.txt por alguna raz\u00f3n.","title":"Instalaci\u00f3n y gesti\u00f3n de dependencias"},{"location":"setup/pyenv/","text":"Pyenv Introducci\u00f3n Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables. Instalaci\u00f3n Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer Uso Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta. Recomendaciones Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Pyenv"},{"location":"setup/pyenv/#pyenv","text":"","title":"Pyenv"},{"location":"setup/pyenv/#introduccion","text":"Al instalar un sistema operativo, es probable que ya venga con una distribuci\u00f3n de Python pre-existente; en el caso de distribuciones de Linux basadas en Debian y Mac \u00e9sta suele ser Python 2.7; otras traen tanto Python 2.7 como Python 3.6; mientras que Windows no trae Python pre-instalado. \u00c9stas instalaciones suelen llamarse como System Python o la versi\u00f3n de Python del sistema, y posee todas las librerias que el Sistema Operativo utiliza durante su funcionamiento regular. Cuando queremos desarrollar software en Python, un riesgo que queremos mitigar es el de instalar err\u00f3neamente un paquete en System Python y modificar las librerias que el sistema operativo utiliza para su correcto funcionamiento , lo que podr\u00eda tener consecuencias catastr\u00f3ficas si no sabemos qu\u00e9 es lo que estamos haciendo. Por otro lado adem\u00e1s nos gustar\u00eda usar distintas versiones de Python que la pre-instalada en el sistema operativo y tener un mecanismo para instalar dependencias de forma segura sobre esas instalaciones espec\u00edficas y no sobre System Python . Esto es especialmente importante cuando se desarrollan librer\u00edas que deben probarse para varias versiones de Python distintas de manera simult\u00e1nea. html_img_enable=true, Pyenv nos ayuda a resolver ambos problemas, y entre sus utilidades nos permite instalar distintas versiones de Python en un directorio aparte, y adem\u00e1s nos permite configurar que versi\u00f3n de Python deseamos usar para cada caso. Consiste en una herramienta que construye de manera nativa cualquier versi\u00f3n de Python desde su codigo fuente y luego la instala de manera local en el computador, permiti\u00e9ndonos usar desde las versiones m\u00e1s antiguas de Python (por si tenemos que mantener algun desarrollo legacy ) hasta las versiones m\u00e1s experimentales que a\u00fan no se consideran estables.","title":"Introducci\u00f3n"},{"location":"setup/pyenv/#instalacion","text":"Para Linux y Mac lo recomendable es instalar todos los pre-requisitos gui\u00e1ndose en esta guia y luego usar pyenv-installer","title":"Instalaci\u00f3n"},{"location":"setup/pyenv/#uso","text":"Si necesitamos una versi\u00f3n de Python espec\u00edfica podemos usar pyenv para instalarla de la siguiente forma: pyenv install < VERSION > Tambi\u00e9n podemos ver qu\u00e9 versiones de Python se pueden instalar usando: pyenv install - l La lista es muy bastante amplia; Miniconda, Anaconda, Cython, Pypy, Jython, entre otras est\u00e1n disponibles para ser instaladas usando esta herramienta.","title":"Uso"},{"location":"setup/pyenv/#recomendaciones","text":"Luego de instalar pyenv y alguna version de Python con la que te sientas c\u00f3modo, configura pyenv para que desde ahora en adelante cuando llames a Python (a menos que especifiques otra cosa) se llame siempre por defecto a la nueva instalaci\u00f3n y no a System Python . Para esto ejecuta: pyenv global <VERSION> Una vez que tienes tu(s) int\u00e9rprete(s) de Python listo(s), puedes manejar ambientes virtuales sobre estos mismos usando herramientas como Poetry o Pipenv.","title":"Recomendaciones"},{"location":"setup/virtualenv/","text":"Venv Introducci\u00f3n Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas: \u00bfPara qu\u00e9 se usan los entornos virtuales? Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios. \u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python? No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js \u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3? Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI . Creando ambientes virtuales Forma tradicional La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt Referencias venv \u2014 Creation of virtual environments","title":"Venv"},{"location":"setup/virtualenv/#venv","text":"","title":"Venv"},{"location":"setup/virtualenv/#introduccion","text":"Un entorno de desarrollo virtual python o simplemente entorno virtual python es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administraci\u00f3n, es decir, cualquier usuario sin privilegios puede tener uno o m\u00e1s espacios aislados (ya veremos m\u00e1s adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Antes de empezar a crear nuestros entornos, deber\u00edamos hacernos las siguientes preguntas:","title":"Introducci\u00f3n"},{"location":"setup/virtualenv/#para-que-se-usan-los-entornos-virtuales","text":"Utilizar versiones de paquetes python que no son las que vienen empaquetadas oficialmente en nuestra OS. Una soluci\u00f3n puede ser usar pip como administrador: esta soluci\u00f3n nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y alg\u00fan paquete puede dejar de funcionar. En el caso del desarrollo y despliegue de aplicaciones web, cada vez es m\u00e1s importante acercar los entornos de desarrollo, prueba y producci\u00f3n, es decir, que estos tres entornos sean los m\u00e1s parecidos posible, para no tener sorpresas a la hora de desplegar la aplicaci\u00f3n en producci\u00f3n. Los ciclos de desarrollo de aplicaciones son cada vez m\u00e1s r\u00e1pidos, esto puede suponer que en una misma m\u00e1quina podamos tener aplicaciones que utilicen diferentes dependencias y versiones de un mismo paquete. Por ejemplo, podemos tener dos aplicaciones web en producci\u00f3n, una que est\u00e9 desarrollada con django 1.8 y otra con django 1.10. Los entornos virtuales son una herramienta que favorecen las nuevas metodolog\u00edas de trabajo que se denominan DevOps, que tratan de gestionar y automatizar la configuraci\u00f3n. Es muy sencillo distribuir la configuraci\u00f3n de nuetro en torno virtual y automatizar la creaci\u00f3n de ellos en diferentes infraestructuras y escenarios.","title":"\u00bfPara qu\u00e9 se usan los entornos virtuales?"},{"location":"setup/virtualenv/#los-entornos-virtuales-son-propios-solo-del-lenguaje-python","text":"No, existen herramientas parecidas en distintos lenguajes que nos ofrecen una funcionalidad parecida: phpenv para php plen y perlbrew para perl rbenv y RVM para ruby nodeenv , nvm , n y nave para node.js","title":"\u00bfLos entornos virtuales son propios s\u00f3lo del lenguaje python?"},{"location":"setup/virtualenv/#que-programa-necesito-para-crear-un-entorno-virtual-con-python-3","text":"Tradicionalmente se utiliza la herramienta virtualenv para crear nuestros entornos virtuales. Sin embargo, desde la versi\u00f3n 3.3 de Python tenemos a nuestra disposici\u00f3n un m\u00f3dulo del sistema venv que podemos utilizar para crear nuestro entorno virtual. Por otro lado, existen otras formas de crear ambientes virtuales, por ejemplo ocupando conda , pipenv y/o poetry , sin emabargo, estos pueden ser un poco m\u00e1s complejo de comeprender en un comienzo (sobre todo pipenv o poetry ), aunque con costo/benefificio de poder tener un gestor de paquetes mejor que un simple requirements.txt . Comprendamos algunos conceptos b\u00e1sicos: virtualenv : software que se encuentra en el Python Package Index o PyPI , que es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programaci\u00f3n Python. venv : m\u00f3dulo oficial de Python que a partir de la versi\u00f3n 3.3 nos permite crear entornos virtuales. pip : Independientemente de la manera en que creamos el entorno virtual, utilizando una de las dos herramientas anteriores, vamos a utilizar este sistema de gesti\u00f3n de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI .","title":"\u00bfQu\u00e9 programa necesito para crear un entorno virtual con python 3?"},{"location":"setup/virtualenv/#creando-ambientes-virtuales","text":"","title":"Creando ambientes virtuales"},{"location":"setup/virtualenv/#forma-tradicional","text":"La instalaci\u00f3n y configuraci\u00f3n se realizar\u00e1 en una distribuci\u00f3n GNU/Linux Debian Jessie, en otra versi\u00f3n del sistema u otra distribuci\u00f3n puede haber algunas diferencias. Instalamos los paquetes necesarios como root: # apt-get install python-virtualenv Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con el interprete Python (2.7 o 3.X): $ virtualenv entorno1 Se ha creado un directorio, donde se instalar\u00e1n posteriormente los paquetes que necesitemos: $ cd entorno1 $ ls Independientemente el interprete que utilicemos en nuestro entorno para activarlo tenemos que ejecutar la siguiente instrucci\u00f3n: $ source entorno1/bin/activate$ Para desactivar el ambiente virtual, ejecutamos: $ deactivate Para poder instalar alguna librer\u00eda, simplemente ocupamos la herramienta de pip (en python 3 se ocupa pip3 ) $ pip install numpy Tambi\u00e9n podemos instalar alguna versi\u00f3n en espec\u00edfica, simplemente se realiza: $ pip install numpy==\"1.0.0\" Si necesitamos borrar un paquete podemos ejecutar: $ pip uninstall numpy Para terminar de repasar la herramienta pip , vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt ) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra m\u00e1quina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opci\u00f3n de pip : $ pip freeze numpy==1.0.0 De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera: pip install -r requirements.txt","title":"Forma tradicional"},{"location":"setup/virtualenv/#referencias","text":"venv \u2014 Creation of virtual environments","title":"Referencias"},{"location":"solid/1_srp/","text":"Single Responsibility Principle \"... Ten\u00edas un trabajo\" - Loki a Skurge en Thor: Ragnarok. Una clase debe tener un solo trabajo. Si una clase tiene m\u00e1s de una responsabilidad, se acopla. Un cambio a una responsabilidad resulta en la modificaci\u00f3n de la otra responsabilidad. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def save ( self , animal : Animal ): pass La clase Animal viola el SRP. \u00bfC\u00f3mo viola SRP? SRP establece que las clases deben tener una responsabilidad, aqu\u00ed podemos establecer dos responsabilidades: gesti\u00f3n de bases de datos de animales y gesti\u00f3n de animales. El constructor y get_name administran las propiedades de la clase Animal mientras que el guardado administra el almacenamiento de la clase Animal en una base de datos. \u00bfC\u00f3mo causar\u00e1 problemas este dise\u00f1o en el futuro? Si la aplicaci\u00f3n cambia de una manera que afecta las funciones de administraci\u00f3n de la base de datos. Las clases que hacen uso de las propiedades de los animales deber\u00e1n modificarse y recompilarse para compensar los nuevos cambios. Es como un efecto domin\u00f3, toca una carta y afecta a todas las dem\u00e1s cartas en l\u00ednea. Para que esto se ajuste a SRP, creamos otra clase que manejar\u00e1 la responsabilidad exclusiva de almacenar un animal en una base de datos: class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ): pass class AnimalDB : def get_animal ( self , id ) -> Animal : pass def save ( self , animal : Animal ): pass Al dise\u00f1ar nuestras clases, debemos apuntar a juntar caracter\u00edsticas relacionadas, de modo que siempre que tiendan a cambiar, cambien por la misma raz\u00f3n. Y deber\u00edamos intentar separar las caracter\u00edsticas si cambian por diferentes razones. - Steve Fenton La desventaja de esta soluci\u00f3n es que los clientes de este c\u00f3digo tienen que lidiar con dos clases. Una soluci\u00f3n com\u00fan a este dilema es aplicar el patr\u00f3n de dise\u00f1o Facade . La clase de animales ser\u00e1 la fachada para la gesti\u00f3n de bases de datos de animales y la gesti\u00f3n de propiedades animales. class Animal : def __init__ ( self , name : str ): self . name = name self . db = AnimalDB () def get_name ( self ): return self . name def get ( self , id ): return self . db . get_animal ( id ) def save ( self ): self . db . save ( animal = self ) Los m\u00e9todos m\u00e1s importantes se guardan en la clase Animal y se utilizan como fachada para las funciones menores.","title":"Single Responsibility Principle"},{"location":"solid/1_srp/#single-responsibility-principle","text":"\"... Ten\u00edas un trabajo\" - Loki a Skurge en Thor: Ragnarok. Una clase debe tener un solo trabajo. Si una clase tiene m\u00e1s de una responsabilidad, se acopla. Un cambio a una responsabilidad resulta en la modificaci\u00f3n de la otra responsabilidad. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def save ( self , animal : Animal ): pass La clase Animal viola el SRP. \u00bfC\u00f3mo viola SRP? SRP establece que las clases deben tener una responsabilidad, aqu\u00ed podemos establecer dos responsabilidades: gesti\u00f3n de bases de datos de animales y gesti\u00f3n de animales. El constructor y get_name administran las propiedades de la clase Animal mientras que el guardado administra el almacenamiento de la clase Animal en una base de datos. \u00bfC\u00f3mo causar\u00e1 problemas este dise\u00f1o en el futuro? Si la aplicaci\u00f3n cambia de una manera que afecta las funciones de administraci\u00f3n de la base de datos. Las clases que hacen uso de las propiedades de los animales deber\u00e1n modificarse y recompilarse para compensar los nuevos cambios. Es como un efecto domin\u00f3, toca una carta y afecta a todas las dem\u00e1s cartas en l\u00ednea. Para que esto se ajuste a SRP, creamos otra clase que manejar\u00e1 la responsabilidad exclusiva de almacenar un animal en una base de datos: class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ): pass class AnimalDB : def get_animal ( self , id ) -> Animal : pass def save ( self , animal : Animal ): pass Al dise\u00f1ar nuestras clases, debemos apuntar a juntar caracter\u00edsticas relacionadas, de modo que siempre que tiendan a cambiar, cambien por la misma raz\u00f3n. Y deber\u00edamos intentar separar las caracter\u00edsticas si cambian por diferentes razones. - Steve Fenton La desventaja de esta soluci\u00f3n es que los clientes de este c\u00f3digo tienen que lidiar con dos clases. Una soluci\u00f3n com\u00fan a este dilema es aplicar el patr\u00f3n de dise\u00f1o Facade . La clase de animales ser\u00e1 la fachada para la gesti\u00f3n de bases de datos de animales y la gesti\u00f3n de propiedades animales. class Animal : def __init__ ( self , name : str ): self . name = name self . db = AnimalDB () def get_name ( self ): return self . name def get ( self , id ): return self . db . get_animal ( id ) def save ( self ): self . db . save ( animal = self ) Los m\u00e9todos m\u00e1s importantes se guardan en la clase Animal y se utilizan como fachada para las funciones menores.","title":"Single Responsibility Principle"},{"location":"solid/2_ocp/","text":"Open-Closed Principle Las entidades de software (clases, m\u00f3dulos, funciones) deben estar abiertas para extensi\u00f3n, no modificaci\u00f3n. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass animals = [ Animal ( 'lion' ), Animal ( 'mouse' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) animal_sound ( animals ) roar squeak La funci\u00f3n animal_sound no se ajusta al principio ocp puesto que no puede cerrarse frente a nuevos tipos de animales. Si agregamos un nuevo animal, Snake , tenemos que modificar la funci\u00f3n animal_sound . Ver\u00e1, para cada nuevo animal, se agrega una nueva l\u00f3gica a la funci\u00f3n animal_sound. \u00c9ste es un ejemplo bastante simple. Cuando su aplicaci\u00f3n crezca y se vuelva compleja, ver\u00e1 que la instrucci\u00f3n if se repetir\u00e1 una y otra vez en la funci\u00f3n animal_sound cada vez que se agregue un nuevo animal, en toda la aplicaci\u00f3n. animals = [ Animal ( 'lion' ), Animal ( 'mouse' ), Animal ( 'snake' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) elif animal . name == 'snake' : print ( 'hiss' ) animal_sound ( animals ) roar squeak hiss \u00bfC\u00f3mo lo hacemos (animal_sound) conforme a OCP? class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def make_sound ( self ): pass class Lion ( Animal ): def make_sound ( self ): return 'roar' class Mouse ( Animal ): def make_sound ( self ): return 'squeak' class Snake ( Animal ): def make_sound ( self ): return 'hiss' def animal_sound ( animals : list ): for animal in animals : print ( animal . make_sound ()) animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Snake ( name = \"Snake\" ), ] animal_sound ( animals ) roar squeak hiss Animal ahora tiene un m\u00e9todo virtual make_sound . Hacemos que cada animal extienda la clase Animal e implementemos el m\u00e9todo virtual make_sound . Cada animal agrega su propia implementaci\u00f3n sobre c\u00f3mo hace un sonido en make_sound . animal_sound itera a trav\u00e9s de la matriz de animal y simplemente llama a su m\u00e9todo make_sound . Ahora, si agregamos un nuevo animal, animal_sound no necesita cambiar. Todo lo que tenemos que hacer es agregar el nuevo animal a la matriz de animales. animal_sound ahora se ajusta al principio OCP. Otro ejemplo: Imaginemos que tiene una tienda y ofrece un descuento del 20% a sus clientes favoritos que usan esta clase: cuando decide ofrecer el doble del 20% de descuento a los clientes VIP. Puede modificar la clase de esta manera: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def give_discount ( self ): if self . customer == 'fav' : return self . price * 0.2 if self . customer == 'vip' : return self . price * 0.4 No, esto no cumple con el principio OCP. OCP lo proh\u00edbe. Si queremos dar un nuevo porcentaje de descuento, tal vez, a un diferencial. tipo de clientes, ver\u00e1 que se agregar\u00e1 una nueva l\u00f3gica. Para que siga el principio OCP, agregaremos una nueva clase que extender\u00e1 el descuento. En esta nueva clase, implementar\u00edamos su nuevo comportamiento: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def get_discount ( self ): return self . price * 0.2 class VIPDiscount ( Discount ): def get_discount ( self ): return super () . get_discount () * 2 Si decide un 80% de descuento para clientes super VIP, deber\u00eda ser as\u00ed: Ver\u00e1, extensi\u00f3n sin modificaci\u00f3n. class SuperVIPDiscount ( VIPDiscount ): def get_discount ( self ): return super () . get_discount () * 2","title":"Single Responsibility Principle"},{"location":"solid/2_ocp/#open-closed-principle","text":"Las entidades de software (clases, m\u00f3dulos, funciones) deben estar abiertas para extensi\u00f3n, no modificaci\u00f3n. class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass animals = [ Animal ( 'lion' ), Animal ( 'mouse' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) animal_sound ( animals ) roar squeak La funci\u00f3n animal_sound no se ajusta al principio ocp puesto que no puede cerrarse frente a nuevos tipos de animales. Si agregamos un nuevo animal, Snake , tenemos que modificar la funci\u00f3n animal_sound . Ver\u00e1, para cada nuevo animal, se agrega una nueva l\u00f3gica a la funci\u00f3n animal_sound. \u00c9ste es un ejemplo bastante simple. Cuando su aplicaci\u00f3n crezca y se vuelva compleja, ver\u00e1 que la instrucci\u00f3n if se repetir\u00e1 una y otra vez en la funci\u00f3n animal_sound cada vez que se agregue un nuevo animal, en toda la aplicaci\u00f3n. animals = [ Animal ( 'lion' ), Animal ( 'mouse' ), Animal ( 'snake' ) ] def animal_sound ( animals : list ): for animal in animals : if animal . name == 'lion' : print ( 'roar' ) elif animal . name == 'mouse' : print ( 'squeak' ) elif animal . name == 'snake' : print ( 'hiss' ) animal_sound ( animals ) roar squeak hiss \u00bfC\u00f3mo lo hacemos (animal_sound) conforme a OCP? class Animal : def __init__ ( self , name : str ): self . name = name def get_name ( self ) -> str : pass def make_sound ( self ): pass class Lion ( Animal ): def make_sound ( self ): return 'roar' class Mouse ( Animal ): def make_sound ( self ): return 'squeak' class Snake ( Animal ): def make_sound ( self ): return 'hiss' def animal_sound ( animals : list ): for animal in animals : print ( animal . make_sound ()) animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Snake ( name = \"Snake\" ), ] animal_sound ( animals ) roar squeak hiss Animal ahora tiene un m\u00e9todo virtual make_sound . Hacemos que cada animal extienda la clase Animal e implementemos el m\u00e9todo virtual make_sound . Cada animal agrega su propia implementaci\u00f3n sobre c\u00f3mo hace un sonido en make_sound . animal_sound itera a trav\u00e9s de la matriz de animal y simplemente llama a su m\u00e9todo make_sound . Ahora, si agregamos un nuevo animal, animal_sound no necesita cambiar. Todo lo que tenemos que hacer es agregar el nuevo animal a la matriz de animales. animal_sound ahora se ajusta al principio OCP. Otro ejemplo: Imaginemos que tiene una tienda y ofrece un descuento del 20% a sus clientes favoritos que usan esta clase: cuando decide ofrecer el doble del 20% de descuento a los clientes VIP. Puede modificar la clase de esta manera: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def give_discount ( self ): if self . customer == 'fav' : return self . price * 0.2 if self . customer == 'vip' : return self . price * 0.4 No, esto no cumple con el principio OCP. OCP lo proh\u00edbe. Si queremos dar un nuevo porcentaje de descuento, tal vez, a un diferencial. tipo de clientes, ver\u00e1 que se agregar\u00e1 una nueva l\u00f3gica. Para que siga el principio OCP, agregaremos una nueva clase que extender\u00e1 el descuento. En esta nueva clase, implementar\u00edamos su nuevo comportamiento: class Discount : def __init__ ( self , customer , price ): self . customer = customer self . price = price def get_discount ( self ): return self . price * 0.2 class VIPDiscount ( Discount ): def get_discount ( self ): return super () . get_discount () * 2 Si decide un 80% de descuento para clientes super VIP, deber\u00eda ser as\u00ed: Ver\u00e1, extensi\u00f3n sin modificaci\u00f3n. class SuperVIPDiscount ( VIPDiscount ): def get_discount ( self ): return super () . get_discount () * 2","title":"Open-Closed Principle"},{"location":"solid/3_lsp/","text":"Liskov Substitution Principle Una subclase debe ser sustituible por su superclase. El objetivo de este principio es determinar que una subclase pueda asumir el lugar de su superclase sin errores. Si el c\u00f3digo se encuentra comprobando el tipo de clase, entonces debe haber violado este principio. Usemos nuestro ejemplo Animal . class Animal : def __init__ ( self , name : str ): self . name = name class Lion ( Animal ): pass class Mouse ( Animal ): pass class Pigeon ( Animal ): pass animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Pigeon ( name = \"Pigeon\" ), ] def animal_leg_count ( animals : list ): for animal in animals : if isinstance ( animal , Lion ): print ( lion_leg_count ( animal )) elif isinstance ( animal , Mouse ): print ( mouse_leg_count ( animal )) elif isinstance ( animal , Pigeon ): print ( pigeon_leg_count ( animal )) animal_leg_count ( animals ) --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-19-aad1b5d27670> in <module> 8 print(pigeon_leg_count(animal)) 9 ---> 10 animal_leg_count(animals) <ipython-input-19-aad1b5d27670> in animal_leg_count(animals) 2 for animal in animals: 3 if isinstance(animal, Lion): ----> 4 print(lion_leg_count(animal)) 5 elif isinstance(animal, Mouse): 6 print(mouse_leg_count(animal)) NameError: name 'lion_leg_count' is not defined Para que esta funci\u00f3n siga el principio LSP, seguiremos estos requisitos LSP postulados por Steve Fenton: Si la superclase ( Animal ) tiene un m\u00e9todo que acepta un par\u00e1metro de tipo de superclase ( Animal ). Su subclase ( Pigeon ) debe aceptar como argumento un tipo de superclase (tipo Animal ) o un tipo de subclase (tipo Pigeon ). Si la superclase devuelve un tipo de superclase ( Animal ). Su subclase deber\u00eda devolver un tipo de superclase (tipo Animal ) o un tipo de subclase ( Pigeon ). Ahora, podemos volver a implementar la funci\u00f3n animal_leg_count : def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animal_leg_count ( animals ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-17-98b6adbc243d> in <module> 3 print(animal.leg_count()) 4 ----> 5 animal_leg_count(animals) <ipython-input-17-98b6adbc243d> in animal_leg_count(animals) 1 def animal_leg_count(animals: list): 2 for animal in animals: ----> 3 print(animal.leg_count()) 4 5 animal_leg_count(animals) AttributeError: 'Lion' object has no attribute 'leg_count' A la funci\u00f3n animal_leg_count le importa menos el tipo de Animal pasado, simplemente llama al m\u00e9todo leg_count . Todo lo que sabe es que el par\u00e1metro debe ser de un tipo Animal , ya sea la clase Animal o su subclase. La clase Animal ahora tiene que implementar/definir un m\u00e9todo leg_count . Y sus subclases deben implementar el m\u00e9todo leg_count : class Animal : def leg_count ( self ): pass class Lion ( Animal ): def leg_count ( self ): return 4 class Mouse ( Animal ): def leg_count ( self ): return 4 class Pigeon ( Animal ): def leg_count ( self ): return 2 def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animals = [ Lion (), Mouse (), Pigeon (), ] animal_leg_count ( animals ) 4 4 2 Cuando se pasa a la funci\u00f3n animal_leg_count , devuelve el n\u00famero de patas que tiene un le\u00f3n. Ver\u00e1, animal_leg_count no necesita saber el tipo de Animal para devolver su recuento de patas, solo llama al m\u00e9todo leg_count del tipo Animal porque por contrato una subclase de la clase Animal debe implementar la funci\u00f3n leg_count .","title":"Liskov Substitution Principle"},{"location":"solid/3_lsp/#liskov-substitution-principle","text":"Una subclase debe ser sustituible por su superclase. El objetivo de este principio es determinar que una subclase pueda asumir el lugar de su superclase sin errores. Si el c\u00f3digo se encuentra comprobando el tipo de clase, entonces debe haber violado este principio. Usemos nuestro ejemplo Animal . class Animal : def __init__ ( self , name : str ): self . name = name class Lion ( Animal ): pass class Mouse ( Animal ): pass class Pigeon ( Animal ): pass animals = [ Lion ( name = \"Lion\" ), Mouse ( name = \"Mouse\" ), Pigeon ( name = \"Pigeon\" ), ] def animal_leg_count ( animals : list ): for animal in animals : if isinstance ( animal , Lion ): print ( lion_leg_count ( animal )) elif isinstance ( animal , Mouse ): print ( mouse_leg_count ( animal )) elif isinstance ( animal , Pigeon ): print ( pigeon_leg_count ( animal )) animal_leg_count ( animals ) --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-19-aad1b5d27670> in <module> 8 print(pigeon_leg_count(animal)) 9 ---> 10 animal_leg_count(animals) <ipython-input-19-aad1b5d27670> in animal_leg_count(animals) 2 for animal in animals: 3 if isinstance(animal, Lion): ----> 4 print(lion_leg_count(animal)) 5 elif isinstance(animal, Mouse): 6 print(mouse_leg_count(animal)) NameError: name 'lion_leg_count' is not defined Para que esta funci\u00f3n siga el principio LSP, seguiremos estos requisitos LSP postulados por Steve Fenton: Si la superclase ( Animal ) tiene un m\u00e9todo que acepta un par\u00e1metro de tipo de superclase ( Animal ). Su subclase ( Pigeon ) debe aceptar como argumento un tipo de superclase (tipo Animal ) o un tipo de subclase (tipo Pigeon ). Si la superclase devuelve un tipo de superclase ( Animal ). Su subclase deber\u00eda devolver un tipo de superclase (tipo Animal ) o un tipo de subclase ( Pigeon ). Ahora, podemos volver a implementar la funci\u00f3n animal_leg_count : def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animal_leg_count ( animals ) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-17-98b6adbc243d> in <module> 3 print(animal.leg_count()) 4 ----> 5 animal_leg_count(animals) <ipython-input-17-98b6adbc243d> in animal_leg_count(animals) 1 def animal_leg_count(animals: list): 2 for animal in animals: ----> 3 print(animal.leg_count()) 4 5 animal_leg_count(animals) AttributeError: 'Lion' object has no attribute 'leg_count' A la funci\u00f3n animal_leg_count le importa menos el tipo de Animal pasado, simplemente llama al m\u00e9todo leg_count . Todo lo que sabe es que el par\u00e1metro debe ser de un tipo Animal , ya sea la clase Animal o su subclase. La clase Animal ahora tiene que implementar/definir un m\u00e9todo leg_count . Y sus subclases deben implementar el m\u00e9todo leg_count : class Animal : def leg_count ( self ): pass class Lion ( Animal ): def leg_count ( self ): return 4 class Mouse ( Animal ): def leg_count ( self ): return 4 class Pigeon ( Animal ): def leg_count ( self ): return 2 def animal_leg_count ( animals : list ): for animal in animals : print ( animal . leg_count ()) animals = [ Lion (), Mouse (), Pigeon (), ] animal_leg_count ( animals ) 4 4 2 Cuando se pasa a la funci\u00f3n animal_leg_count , devuelve el n\u00famero de patas que tiene un le\u00f3n. Ver\u00e1, animal_leg_count no necesita saber el tipo de Animal para devolver su recuento de patas, solo llama al m\u00e9todo leg_count del tipo Animal porque por contrato una subclase de la clase Animal debe implementar la funci\u00f3n leg_count .","title":"Liskov Substitution Principle"},{"location":"solid/4_isp/","text":"Interface Segregation Principle Cree interfaces de grano fino que sean espec\u00edficas del cliente. Los clientes no deben verse obligados a depender de interfaces que no utilizan. Este principio se ocupa de las desventajas de implementar grandes interfaces. Veamos la siguiente interfaz de IShape : class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError Esta interfaz dibuja cuadrados, c\u00edrculos, rect\u00e1ngulos. La clase Circle , Square o Rectangle que implementa la interfaz IShape debe definir los m\u00e9todos draw_square() , draw_rectangle() , draw_circle() . class Circle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Square ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Rectangle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass La clase Rectangle implementa m\u00e9todos ( draw_circle y draw_square ) de los que no tiene uso, del mismo modo que Square implementa draw_circle , y draw_rectangle , y la clase Circle ( draw_square , draw_rectangle ). Si agregamos otro m\u00e9todo a la interfaz IShape , como draw_triangle() , class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError def draw_triangle ( self ): raise NotImplementedError Las clases deben implementar el nuevo m\u00e9todo o se lanzar\u00e1 un error. Vemos que es imposible implementar una forma que pueda dibujar un c\u00edrculo pero no un rect\u00e1ngulo o un cuadrado o un tri\u00e1ngulo. Podemos simplemente implementar los m\u00e9todos para generar un error que muestre que la operaci\u00f3n no se puede realizar. ISP frunce el ce\u00f1o contra el dise\u00f1o de esta interfaz IShape. Los clientes (aqu\u00ed Circle , Square o Rectangle ) no deber\u00edan verse obligados a depender de m\u00e9todos que no necesitan o utilizan. Adem\u00e1s, el ISP establece que las interfaces deben realizar solo un trabajo (al igual que el principio SRP), cualquier agrupaci\u00f3n adicional de comportamiento debe abstraerse a otra interfaz. La interfaz IShape realiza acciones que deber\u00edan ser manejadas de forma independiente por otras interfaces. La interfaz IShape se ajuste al principio de ISP, segregamos las acciones en diferentes interfaces. Las clases ( Circle , Square , Rectangle , etc) pueden simplemente heredar de la interfaz IShape e implementar su propio comportamiento de dibujo. class IShape : def draw ( self ): raise NotImplementedError class Circle ( IShape ): def draw ( self ): pass class Square ( IShape ): def draw ( self ): pass class Rectangle ( IShape ): def draw ( self ): pass Luego podemos usar las I-interfaces para crear formas espec\u00edficas como semic\u00edrculo, tri\u00e1ngulo en \u00e1ngulo recto, tri\u00e1ngulo equil\u00e1tero, etc.","title":"Interface Segregation Principle"},{"location":"solid/4_isp/#interface-segregation-principle","text":"Cree interfaces de grano fino que sean espec\u00edficas del cliente. Los clientes no deben verse obligados a depender de interfaces que no utilizan. Este principio se ocupa de las desventajas de implementar grandes interfaces. Veamos la siguiente interfaz de IShape : class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError Esta interfaz dibuja cuadrados, c\u00edrculos, rect\u00e1ngulos. La clase Circle , Square o Rectangle que implementa la interfaz IShape debe definir los m\u00e9todos draw_square() , draw_rectangle() , draw_circle() . class Circle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Square ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass class Rectangle ( IShape ): def draw_square ( self ): pass def draw_rectangle ( self ): pass def draw_circle ( self ): pass La clase Rectangle implementa m\u00e9todos ( draw_circle y draw_square ) de los que no tiene uso, del mismo modo que Square implementa draw_circle , y draw_rectangle , y la clase Circle ( draw_square , draw_rectangle ). Si agregamos otro m\u00e9todo a la interfaz IShape , como draw_triangle() , class IShape : def draw_square ( self ): raise NotImplementedError def draw_rectangle ( self ): raise NotImplementedError def draw_circle ( self ): raise NotImplementedError def draw_triangle ( self ): raise NotImplementedError Las clases deben implementar el nuevo m\u00e9todo o se lanzar\u00e1 un error. Vemos que es imposible implementar una forma que pueda dibujar un c\u00edrculo pero no un rect\u00e1ngulo o un cuadrado o un tri\u00e1ngulo. Podemos simplemente implementar los m\u00e9todos para generar un error que muestre que la operaci\u00f3n no se puede realizar. ISP frunce el ce\u00f1o contra el dise\u00f1o de esta interfaz IShape. Los clientes (aqu\u00ed Circle , Square o Rectangle ) no deber\u00edan verse obligados a depender de m\u00e9todos que no necesitan o utilizan. Adem\u00e1s, el ISP establece que las interfaces deben realizar solo un trabajo (al igual que el principio SRP), cualquier agrupaci\u00f3n adicional de comportamiento debe abstraerse a otra interfaz. La interfaz IShape realiza acciones que deber\u00edan ser manejadas de forma independiente por otras interfaces. La interfaz IShape se ajuste al principio de ISP, segregamos las acciones en diferentes interfaces. Las clases ( Circle , Square , Rectangle , etc) pueden simplemente heredar de la interfaz IShape e implementar su propio comportamiento de dibujo. class IShape : def draw ( self ): raise NotImplementedError class Circle ( IShape ): def draw ( self ): pass class Square ( IShape ): def draw ( self ): pass class Rectangle ( IShape ): def draw ( self ): pass Luego podemos usar las I-interfaces para crear formas espec\u00edficas como semic\u00edrculo, tri\u00e1ngulo en \u00e1ngulo recto, tri\u00e1ngulo equil\u00e1tero, etc.","title":"Interface Segregation Principle"},{"location":"solid/5_dip/","text":"Dependency Inversion Principle La dependencia debe estar en abstracciones, no en concreciones. Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deber\u00edan depender de abstracciones. Las abstracciones no deben depender de los detalles. Los detalles deben depender de abstracciones. Llega un punto en el desarrollo de software en el que nuestra aplicaci\u00f3n estar\u00e1 compuesta en gran parte por m\u00f3dulos. Cuando esto sucede, tenemos que aclarar las cosas usando la inyecci\u00f3n de dependencia. Componentes de alto nivel dependiendo de los componentes de bajo nivel para funcionar. class XMLHttpService (): pass class Http : def __init__ ( self , xml_http_service : XMLHttpService ): self . xml_http_service = xml_http_service def get ( self , url : str , options : dict ): self . xml_http_service . request ( url , 'GET' ) def post ( self , url , options : dict ): self . xml_http_service . request ( url , 'POST' ) Aqu\u00ed, Http es el componente de alto nivel mientras que XMLHttpService es el componente de bajo nivel. Este dise\u00f1o viola DIP : los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Deber\u00eda depender de su abstracci\u00f3n. Esta clase Http est\u00e1 obligada a depender de la clase XMLHttpService . Si tuvi\u00e9ramos que cambiar el servicio de conexi\u00f3n Http, tal vez queramos conectarnos a Internet a trav\u00e9s de cURL o incluso simular el servicio http. Tendremos que movernos minuciosamente por todas las instancias de Http para editar el c\u00f3digo y esto viola el principio OCP . La clase Http deber\u00eda preocuparse menos por el tipo de servicio Http que est\u00e1 utilizando. Hacemos una interfaz de conexi\u00f3n: class Connection : def request ( self , url : str , options : dict ): raise NotImplementedError La interfaz Connection tiene un m\u00e9todo de solicitud. Con esto, pasamos un argumento de tipo Connection a nuestra clase Http : class Http : def __init__ ( self , http_connection : Connection ): self . http_connection = http_connection def get ( self , url : str , options : dict ): self . http_connection . request ( url , 'GET' ) def post ( self , url , options : dict ): self . http_connection . request ( url , 'POST' ) As\u00ed que ahora, sin importar el tipo de servicio de conexi\u00f3n Http pasado a Http , puede conectarse f\u00e1cilmente a una red sin molestarse en saber el tipo de conexi\u00f3n de red. Ahora podemos volver a implementar nuestra clase XMLHttpService para implementar la interfaz de conexi\u00f3n: class XMLHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Podemos crear muchos tipos de conexi\u00f3n Http y pasarlos a nuestra clase Http sin ning\u00fan problema por los errores. class NodeHttpService ( Connection ): def request ( self , url : str , options : dict ): pass class MockHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Ahora, podemos ver que tanto los m\u00f3dulos de alto nivel como los de bajo nivel dependen de abstracciones. La clase Http (m\u00f3dulo de alto nivel) depende de la interfaz de Connection (abstracci\u00f3n) y los tipos de servicio Http (m\u00f3dulos de bajo nivel), a su vez, depende de la interfaz de Connection (abstracci\u00f3n). Adem\u00e1s, este DIP nos obligar\u00e1 a no violar el principio de sustituci\u00f3n de Liskov : los tipos de conexi\u00f3n Node-XML-MockHttpService son sustituibles por su tipo de conexi\u00f3n principal.","title":"Dependency Inversion Principle"},{"location":"solid/5_dip/#dependency-inversion-principle","text":"La dependencia debe estar en abstracciones, no en concreciones. Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deber\u00edan depender de abstracciones. Las abstracciones no deben depender de los detalles. Los detalles deben depender de abstracciones. Llega un punto en el desarrollo de software en el que nuestra aplicaci\u00f3n estar\u00e1 compuesta en gran parte por m\u00f3dulos. Cuando esto sucede, tenemos que aclarar las cosas usando la inyecci\u00f3n de dependencia. Componentes de alto nivel dependiendo de los componentes de bajo nivel para funcionar. class XMLHttpService (): pass class Http : def __init__ ( self , xml_http_service : XMLHttpService ): self . xml_http_service = xml_http_service def get ( self , url : str , options : dict ): self . xml_http_service . request ( url , 'GET' ) def post ( self , url , options : dict ): self . xml_http_service . request ( url , 'POST' ) Aqu\u00ed, Http es el componente de alto nivel mientras que XMLHttpService es el componente de bajo nivel. Este dise\u00f1o viola DIP : los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Deber\u00eda depender de su abstracci\u00f3n. Esta clase Http est\u00e1 obligada a depender de la clase XMLHttpService . Si tuvi\u00e9ramos que cambiar el servicio de conexi\u00f3n Http, tal vez queramos conectarnos a Internet a trav\u00e9s de cURL o incluso simular el servicio http. Tendremos que movernos minuciosamente por todas las instancias de Http para editar el c\u00f3digo y esto viola el principio OCP . La clase Http deber\u00eda preocuparse menos por el tipo de servicio Http que est\u00e1 utilizando. Hacemos una interfaz de conexi\u00f3n: class Connection : def request ( self , url : str , options : dict ): raise NotImplementedError La interfaz Connection tiene un m\u00e9todo de solicitud. Con esto, pasamos un argumento de tipo Connection a nuestra clase Http : class Http : def __init__ ( self , http_connection : Connection ): self . http_connection = http_connection def get ( self , url : str , options : dict ): self . http_connection . request ( url , 'GET' ) def post ( self , url , options : dict ): self . http_connection . request ( url , 'POST' ) As\u00ed que ahora, sin importar el tipo de servicio de conexi\u00f3n Http pasado a Http , puede conectarse f\u00e1cilmente a una red sin molestarse en saber el tipo de conexi\u00f3n de red. Ahora podemos volver a implementar nuestra clase XMLHttpService para implementar la interfaz de conexi\u00f3n: class XMLHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Podemos crear muchos tipos de conexi\u00f3n Http y pasarlos a nuestra clase Http sin ning\u00fan problema por los errores. class NodeHttpService ( Connection ): def request ( self , url : str , options : dict ): pass class MockHttpService ( Connection ): def request ( self , url : str , options : dict ): pass Ahora, podemos ver que tanto los m\u00f3dulos de alto nivel como los de bajo nivel dependen de abstracciones. La clase Http (m\u00f3dulo de alto nivel) depende de la interfaz de Connection (abstracci\u00f3n) y los tipos de servicio Http (m\u00f3dulos de bajo nivel), a su vez, depende de la interfaz de Connection (abstracci\u00f3n). Adem\u00e1s, este DIP nos obligar\u00e1 a no violar el principio de sustituci\u00f3n de Liskov : los tipos de conexi\u00f3n Node-XML-MockHttpService son sustituibles por su tipo de conexi\u00f3n principal.","title":"Dependency Inversion Principle"},{"location":"solid/intro/","text":"Introducci\u00f3n El objetivo de este art\u00edculo es que el lector aprenda aplicar los principios SOLID con el lenguaje Python. SOLID es un acro\u0301nimo creado por Michael Feathers para los principios publicados por Robert C. Martin , en su libro Agile Software Development: Principles, Patterns, and Practices . Se trata de cinco principios de dise\u00f1o orientado a objetos que nos ayudar\u00e1n a crear mejor c\u00f3digo, m\u00e1s estructurado, con clases de responsabilidad m\u00e1s definida y m\u00e1s desacopladas entre s\u00ed: Single Responsibility : Responsabilidad u\u0301nica. Open/Closed : Abierto/Cerrado. Liskov substitution : Sustitucio\u0301n de Liskov. Interface segregation : Segregacio\u0301n de interfaz. Dependency Inversion : Inversio\u0301n de dependencia. Es importante resaltar que se trata de principios, no de reglas. Una regla es de obligatorio cumplimiento, en cambio, los principios son recomendaciones que pueden ayudar a hacer las cosas mejor. Adem\u00e1s, siempre puedes encontrar alg\u00fan contexto en el que te los puedas saltar, lo importante es hacerlo de forma consciente.","title":"Introduccion"},{"location":"solid/intro/#introduccion","text":"El objetivo de este art\u00edculo es que el lector aprenda aplicar los principios SOLID con el lenguaje Python. SOLID es un acro\u0301nimo creado por Michael Feathers para los principios publicados por Robert C. Martin , en su libro Agile Software Development: Principles, Patterns, and Practices . Se trata de cinco principios de dise\u00f1o orientado a objetos que nos ayudar\u00e1n a crear mejor c\u00f3digo, m\u00e1s estructurado, con clases de responsabilidad m\u00e1s definida y m\u00e1s desacopladas entre s\u00ed: Single Responsibility : Responsabilidad u\u0301nica. Open/Closed : Abierto/Cerrado. Liskov substitution : Sustitucio\u0301n de Liskov. Interface segregation : Segregacio\u0301n de interfaz. Dependency Inversion : Inversio\u0301n de dependencia. Es importante resaltar que se trata de principios, no de reglas. Una regla es de obligatorio cumplimiento, en cambio, los principios son recomendaciones que pueden ayudar a hacer las cosas mejor. Adem\u00e1s, siempre puedes encontrar alg\u00fan contexto en el que te los puedas saltar, lo importante es hacerlo de forma consciente.","title":"Introducci\u00f3n"},{"location":"testing/hypothesis/","text":"Property-based Testing: Hypothesis Introducci\u00f3n Cuando escribe pruebas unitarias, es dif\u00edcil encontrar los casos de prueba correctos. Desea estar seguro de haber cubierto todos los casos interesantes, pero simplemente no puede conocer u olvidar uno de ellos. Por ejemplo, si realiza una prueba unitaria de una funci\u00f3n que recibe un n\u00famero entero, podr\u00eda pensar en probar 0, 1 y 2. \u00bfPero pens\u00f3 en n\u00fameros negativos? \u00bfQu\u00e9 pasa con los n\u00fameros grandes? Property-based Testing se refiere a la idea de escribir declaraciones que deber\u00edan ser verdaderas para su c\u00f3digo (\"propiedades\"), y luego usar herramientas automatizadas para generar entradas de prueba (t\u00edpicamente, entradas generadas al azar de un tipo apropiado), y observar si las propiedades son v\u00e1lidas para eso entrada. Si una entrada viola una propiedad, ha demostrado un error, as\u00ed como un ejemplo conveniente que lo demuestra. En esta seccion se muetra un poco las estrategias de Property-based Testing ocupando la librer\u00eda Hypothesis . Ejemplo: factorizaci\u00f3n de enteros Tenemos una funci\u00f3n factorize(n: int) -> List[int] que toma un n\u00famero entero y devuelve los factores primos: Un entero \\(n\\) se llama n\u00famero primo si es positivo y divisible exactamente por dos n\u00fameros: 1 y n. Queremos que el producto de los enteros devueltos sea el n\u00famero en s\u00ed. As\u00ed es como dise\u00f1amos el comportamiento de las funciones: * factorize(0) = [0] - una excepci\u00f3n tambi\u00e9n habr\u00eda sido razonable * factorize(1) = [1] - estrictamente hablando, 1 no es primo. * factorize(-1) = [-1] -\u2026 y ninguno es -1 * factorize(-n) = [-1] + factorizar (n) para n> 1 Una implementaci\u00f3n podr\u00eda verse as\u00ed: %% writefile factorize . py from typing import List import math def factorize ( number : int ) -> List [ int ]: if number in [ - 1 , 0 , 1 ]: return [ number ] if number < 0 : return [ - 1 ] + factorize ( - number ) factors = [] # Treat the factor 2 on its own while number % 2 == 0 : factors . append ( 2 ) number = number // 2 if number == 1 : return factors # Now we only need to check uneven numbers # up to the square root of the number i = 3 while i <= int ( math . ceil ( number ** 0.5 )) + 1 : while number % i == 0 : factors . append ( i ) number = number // i i += 2 return factors Overwriting factorize.py Es posible que se sienta un poco inc\u00f3modo por la condici\u00f3n en: while i <= int ( math . ceil ( number ** 0.5 )) + 1 : entonces escribes una prueba para verificar los casos importantes: %% writefile test_factorize_parametrize . py import pytest from factorize import factorize @pytest . mark . parametrize ( \"n,expected\" , [ ( 0 , [ 0 ]), # 0 ( 1 , [ 1 ]), # 1 ( - 1 , [ - 1 ]), # -1 ( - 2 , [ - 1 , 2 ]), # A prime, but negative ( 2 , [ 2 ]), # Just one prime ( 3 , [ 3 ]), # A different prime ( 6 , [ 2 , 3 ]), # Different primes ( 8 , [ 2 , 2 , 2 ]), # Multiple times the same prime ], ) def test_factorize ( n , expected ): assert factorize ( n ) == expected Overwriting test_factorize_parametrize.py Si la parametrizaci\u00f3n de la prueba no le resulta familiar, es posible que desee leer sobre pytest.mark.parametrize . Es incre\u00edble y esas pocas l\u00edneas ejecutan 8 pruebas: ! pytest test_factorize_parametrize . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 0 items / 1 error \u001b[0m ==================================== ERRORS ==================================== \u001b[31m\u001b[1m________________ ERROR collecting test_factorize_parametrize.py ________________\u001b[0m \u001b[31mImportError while importing test module '/home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD/test_factorize_parametrize.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: test_factorize_parametrize.py:2: in <module> from factorize import factorize E ModuleNotFoundError: No module named 'factorize'\u001b[0m =========================== short test summary info ============================ ERROR test_factorize_parametrize.py !!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!! \u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.09s\u001b[0m\u001b[31m ===============================\u001b[0m \u00bfC\u00f3mo ser\u00eda una prueba basada en propiedades para factorize ? Primero, debemos pensar en la propiedad que queremos probar. Para factorize como lo dise\u00f1amos, sabemos que el producto de los n\u00fameros devueltos es igual al n\u00famero en s\u00ed. Podemos introducir cualquier n\u00famero entero, pero si los n\u00fameros enteros se vuelven demasiado grandes, el tiempo de ejecuci\u00f3n ser\u00e1 demasiado largo. As\u00ed que limit\u00e9moslos en un rango razonable de +/- un mill\u00f3n: %% writefile test_factorize_property . py import hypothesis.strategies as st from hypothesis import given from factorize import factorize @given ( st . integers ( min_value =- ( 10 ** 6 ), max_value = 10 ** 6 )) def test_factorize_multiplication_property ( n ): \"\"\"The product of the integers returned by factorize(n) needs to be n.\"\"\" factors = factorize ( n ) product = 1 for factor in factors : product *= factor assert product == n , f \"factorize( { n } ) returned { factors } \" Writing test_factorize_property.py Puede ejecutar las pruebas desde la terminal (python -m pytest test_my_function.py), o si usa un IDE como Pycharm, especificando la configuraci\u00f3n de pytest adecuada para su c\u00f3digo. ! pytest test_factorize_property . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 0 items / 1 error \u001b[0m ==================================== ERRORS ==================================== \u001b[31m\u001b[1m_________________ ERROR collecting test_factorize_property.py __________________\u001b[0m \u001b[31mImportError while importing test module '/home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD/test_factorize_property.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: test_factorize_property.py:3: in <module> from factorize import factorize E ModuleNotFoundError: No module named 'factorize'\u001b[0m =========================== short test summary info ============================ ERROR test_factorize_property.py !!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!! \u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.10s\u001b[0m\u001b[31m ===============================\u001b[0m Como puede ver en el ejemplo anterior, la hip\u00f3tesis descubri\u00f3 que factorize(5) devolvi\u00f3 una lista vac\u00eda que no se multiplica por 5. Entonces podemos ver r\u00e1pidamente que en realidad cometimos un error para todos los n\u00fameros primos: necesitamos sumar el n\u00famero primo. Despu\u00e9s de agregar la siguiente l\u00ednea, las pruebas funcionan bien: if number != 1 : factors . append ( number ) Tests m\u00e1s elaborados Este c\u00f3digo es bastante sencillo: devolver un flotante a un tipo entero. %% writefile my_functions . py def convert_to_integer ( value : float ) -> int : return int ( value ) Writing my_functions.py Decoradores \u00fatiles Existen varias funcionalidades que nos ofrece hypothesis , dentro de las cuales se destacan: given : convierte una funci\u00f3n de prueba que acepta argumentos en una prueba aleatoria. example : asegura que siempre se prueba un ejemplo espec\u00edfico. assume : es como una afirmaci\u00f3n que marca el ejemplo como malo, en lugar de fallar en la prueba. Veamos un ejemplo sencillo que mezcle estos tres atributos: %% writefile test_my_function . py import numpy as np import hypothesis.strategies as st from hypothesis import given , example , assume from my_functions import convert_to_integer @example ( np . inf ) @given ( st . floats ( allow_nan = False )) def test_convert_to_integer ( my_float ): assume ( my_float != np . inf ) assume ( my_float !=- np . inf ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Writing test_my_function.py Corremos los test correspondientes asociados a este ejemplo: ! python - m pytest test_my_function . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: < 1ms, ~ 43% in data generation - 2 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.14 seconds): - Typical runtimes: 0-1 ms, ~ 42% in data generation - 98 passing examples, 0 failing examples, 21 invalid examples - Stopped because settings.max_examples=100 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.29s\u001b[0m\u001b[32m ===============================\u001b[0m Estrategias Una estrategia define los datos que genera Hypothesis para las pruebas y c\u00f3mo se \u201csimplifican\u201d los ejemplos. En nuestro c\u00f3digo, solo definimos los par\u00e1metros de los datos; la simplificaci\u00f3n (o: \"shrinking\") es interna de Hypothesis. Comenzaremos con una estrategia que genera un valor flotante entre 0.0 y 10.0 (inclusive). Definimos esto en un archivo separado llamado data_strategies.py . Usar una clase de datos para esto puede parecer una exageraci\u00f3n, pero es \u00fatil cuando est\u00e1 trabajando con un c\u00f3digo m\u00e1s complejo que requiere un mont\u00f3n de par\u00e1metros diferentes. %% writefile data_strategies . py from pydantic import BaseModel import hypothesis.strategies as st class GeneratedData ( BaseModel ): float_value : st . SearchStrategy [ float ] class Config : arbitrary_types_allowed = True generated_data = GeneratedData ( float_value = st . floats ( min_value = 0.0 , max_value = 10.0 )) Writing data_strategies.py Una vez que hemos definido nuestra estrategia, agregamos un peque\u00f1o fragmento de c\u00f3digo para pasar los ejemplos generados por la hip\u00f3tesis a nuestra funci\u00f3n y afirmar algo sobre el resultado requerido (la \"propiedad\") del c\u00f3digo que queremos probar. El siguiente c\u00f3digo extrae un valor flotante del objeto de clase de datos generate_data que definimos en el archivo data_strategies.py anterior, pasa ese valor a trav\u00e9s de nuestra funci\u00f3n convert_to_integer y finalmente afirma que se mantiene la propiedad esperada. %% writefile test_my_function . py import hypothesis.strategies as st from hypothesis import given from my_functions import convert_to_integer from data_strategies import generated_data @given ( st . data ()) def test_convert_to_integer ( test_data : st . DataObject ): my_float = test_data . draw ( generated_data . float_value ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Overwriting test_my_function.py Se corren las respectivas pruebas, agregando el comando extra --hypothesis-show-statistics , que muestra estad\u00edsticas relacionadas de las pruebas hechas por Hypothesis . ! python - m pytest test_my_function . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: ~ 1ms, ~ 68% in data generation - 1 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.09 seconds): - Typical runtimes: < 1ms, ~ 39% in data generation - 99 passing examples, 0 failing examples, 0 invalid examples - Stopped because settings.max_examples=100 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.15s\u001b[0m\u001b[32m ===============================\u001b[0m Configuraciones Antes de ejecutar el m\u00f3dulo de prueba que desarrollamos anteriormente, revisemos algunas de las configuraciones que podemos usar para adaptar la hip\u00f3tesis a nuestro caso de uso. La hip\u00f3tesis viene con un mont\u00f3n de configuraciones. Estas configuraciones se pueden pasar a su funci\u00f3n de prueba usando el decorador settings() , o registrando las configuraciones en un perfil y pasando el perfil usando el decorador (vea el c\u00f3digo de ejemplo a continuaci\u00f3n). Algunas configuraciones \u00fatiles incluyen: max_examples : controla cu\u00e1ntos ejemplos de aprobaci\u00f3n se requieren antes de que concluya la prueba. Esto es \u00fatil si tiene algunas pautas internas para el volumen de pruebas que se requieren para que un nuevo fragmento de c\u00f3digo pase la revisi\u00f3n. Como regla general: cuanto m\u00e1s complejo sea el c\u00f3digo, m\u00e1s ejemplos querr\u00e1 ejecutar (los autores de Hypothesis se\u00f1alan que lograron encontrar nuevos errores despu\u00e9s de varios millones de ejemplos mientras probaban SymPy); deadline : especifica cu\u00e1nto tiempo puede tomar un ejemplo individual. Deber\u00e1 aumentar este valor si tiene un c\u00f3digo muy complejo en el que un ejemplo puede tardar m\u00e1s que el tiempo predeterminado en ejecutarse; suppress_health_check : le permite especificar qu\u00e9 \"controles de salud\" ignorar. \u00datil cuando est\u00e1 trabajando con grandes conjuntos de datos ( HealthCheck.data_too_large ) o datos que tardan mucho en generarse ( HealthCheck.too_slow ) %% writefile test_my_function_with_settings . py from hypothesis import given , settings , HealthCheck import hypothesis.strategies as st from my_functions import convert_to_integer from data_strategies import generated_data settings . register_profile ( \"my_profile\" , max_examples = 200 , deadline = 60 * 1000 , # Allow 1 min per example (deadline is specified in milliseconds) suppress_health_check = ( HealthCheck . too_slow , HealthCheck . data_too_large ), ) @given ( st . data ()) @settings ( settings . load_profile ( \"my_profile\" )) def test_convert_to_integer ( test_data : st . DataObject ): my_float = test_data . draw ( generated_data . float_value ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Writing test_my_function_with_settings.py Corremos los respectivos tests: ! python - m pytest test_my_function_with_settings . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function_with_settings.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function_with_settings.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: < 1ms, ~ 57% in data generation - 1 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.12 seconds): - Typical runtimes: < 1ms, ~ 39% in data generation - 199 passing examples, 0 failing examples, 0 invalid examples - Stopped because settings.max_examples=200 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.18s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Hypothesis"},{"location":"testing/hypothesis/#property-based-testing-hypothesis","text":"","title":"Property-based Testing: Hypothesis"},{"location":"testing/hypothesis/#introduccion","text":"Cuando escribe pruebas unitarias, es dif\u00edcil encontrar los casos de prueba correctos. Desea estar seguro de haber cubierto todos los casos interesantes, pero simplemente no puede conocer u olvidar uno de ellos. Por ejemplo, si realiza una prueba unitaria de una funci\u00f3n que recibe un n\u00famero entero, podr\u00eda pensar en probar 0, 1 y 2. \u00bfPero pens\u00f3 en n\u00fameros negativos? \u00bfQu\u00e9 pasa con los n\u00fameros grandes? Property-based Testing se refiere a la idea de escribir declaraciones que deber\u00edan ser verdaderas para su c\u00f3digo (\"propiedades\"), y luego usar herramientas automatizadas para generar entradas de prueba (t\u00edpicamente, entradas generadas al azar de un tipo apropiado), y observar si las propiedades son v\u00e1lidas para eso entrada. Si una entrada viola una propiedad, ha demostrado un error, as\u00ed como un ejemplo conveniente que lo demuestra. En esta seccion se muetra un poco las estrategias de Property-based Testing ocupando la librer\u00eda Hypothesis .","title":"Introducci\u00f3n"},{"location":"testing/hypothesis/#ejemplo-factorizacion-de-enteros","text":"Tenemos una funci\u00f3n factorize(n: int) -> List[int] que toma un n\u00famero entero y devuelve los factores primos: Un entero \\(n\\) se llama n\u00famero primo si es positivo y divisible exactamente por dos n\u00fameros: 1 y n. Queremos que el producto de los enteros devueltos sea el n\u00famero en s\u00ed. As\u00ed es como dise\u00f1amos el comportamiento de las funciones: * factorize(0) = [0] - una excepci\u00f3n tambi\u00e9n habr\u00eda sido razonable * factorize(1) = [1] - estrictamente hablando, 1 no es primo. * factorize(-1) = [-1] -\u2026 y ninguno es -1 * factorize(-n) = [-1] + factorizar (n) para n> 1 Una implementaci\u00f3n podr\u00eda verse as\u00ed: %% writefile factorize . py from typing import List import math def factorize ( number : int ) -> List [ int ]: if number in [ - 1 , 0 , 1 ]: return [ number ] if number < 0 : return [ - 1 ] + factorize ( - number ) factors = [] # Treat the factor 2 on its own while number % 2 == 0 : factors . append ( 2 ) number = number // 2 if number == 1 : return factors # Now we only need to check uneven numbers # up to the square root of the number i = 3 while i <= int ( math . ceil ( number ** 0.5 )) + 1 : while number % i == 0 : factors . append ( i ) number = number // i i += 2 return factors Overwriting factorize.py Es posible que se sienta un poco inc\u00f3modo por la condici\u00f3n en: while i <= int ( math . ceil ( number ** 0.5 )) + 1 : entonces escribes una prueba para verificar los casos importantes: %% writefile test_factorize_parametrize . py import pytest from factorize import factorize @pytest . mark . parametrize ( \"n,expected\" , [ ( 0 , [ 0 ]), # 0 ( 1 , [ 1 ]), # 1 ( - 1 , [ - 1 ]), # -1 ( - 2 , [ - 1 , 2 ]), # A prime, but negative ( 2 , [ 2 ]), # Just one prime ( 3 , [ 3 ]), # A different prime ( 6 , [ 2 , 3 ]), # Different primes ( 8 , [ 2 , 2 , 2 ]), # Multiple times the same prime ], ) def test_factorize ( n , expected ): assert factorize ( n ) == expected Overwriting test_factorize_parametrize.py Si la parametrizaci\u00f3n de la prueba no le resulta familiar, es posible que desee leer sobre pytest.mark.parametrize . Es incre\u00edble y esas pocas l\u00edneas ejecutan 8 pruebas: ! pytest test_factorize_parametrize . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 0 items / 1 error \u001b[0m ==================================== ERRORS ==================================== \u001b[31m\u001b[1m________________ ERROR collecting test_factorize_parametrize.py ________________\u001b[0m \u001b[31mImportError while importing test module '/home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD/test_factorize_parametrize.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: test_factorize_parametrize.py:2: in <module> from factorize import factorize E ModuleNotFoundError: No module named 'factorize'\u001b[0m =========================== short test summary info ============================ ERROR test_factorize_parametrize.py !!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!! \u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.09s\u001b[0m\u001b[31m ===============================\u001b[0m \u00bfC\u00f3mo ser\u00eda una prueba basada en propiedades para factorize ? Primero, debemos pensar en la propiedad que queremos probar. Para factorize como lo dise\u00f1amos, sabemos que el producto de los n\u00fameros devueltos es igual al n\u00famero en s\u00ed. Podemos introducir cualquier n\u00famero entero, pero si los n\u00fameros enteros se vuelven demasiado grandes, el tiempo de ejecuci\u00f3n ser\u00e1 demasiado largo. As\u00ed que limit\u00e9moslos en un rango razonable de +/- un mill\u00f3n: %% writefile test_factorize_property . py import hypothesis.strategies as st from hypothesis import given from factorize import factorize @given ( st . integers ( min_value =- ( 10 ** 6 ), max_value = 10 ** 6 )) def test_factorize_multiplication_property ( n ): \"\"\"The product of the integers returned by factorize(n) needs to be n.\"\"\" factors = factorize ( n ) product = 1 for factor in factors : product *= factor assert product == n , f \"factorize( { n } ) returned { factors } \" Writing test_factorize_property.py Puede ejecutar las pruebas desde la terminal (python -m pytest test_my_function.py), o si usa un IDE como Pycharm, especificando la configuraci\u00f3n de pytest adecuada para su c\u00f3digo. ! pytest test_factorize_property . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 0 items / 1 error \u001b[0m ==================================== ERRORS ==================================== \u001b[31m\u001b[1m_________________ ERROR collecting test_factorize_property.py __________________\u001b[0m \u001b[31mImportError while importing test module '/home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD/test_factorize_property.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: test_factorize_property.py:3: in <module> from factorize import factorize E ModuleNotFoundError: No module named 'factorize'\u001b[0m =========================== short test summary info ============================ ERROR test_factorize_property.py !!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!! \u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.10s\u001b[0m\u001b[31m ===============================\u001b[0m Como puede ver en el ejemplo anterior, la hip\u00f3tesis descubri\u00f3 que factorize(5) devolvi\u00f3 una lista vac\u00eda que no se multiplica por 5. Entonces podemos ver r\u00e1pidamente que en realidad cometimos un error para todos los n\u00fameros primos: necesitamos sumar el n\u00famero primo. Despu\u00e9s de agregar la siguiente l\u00ednea, las pruebas funcionan bien: if number != 1 : factors . append ( number )","title":"Ejemplo: factorizaci\u00f3n de enteros"},{"location":"testing/hypothesis/#tests-mas-elaborados","text":"Este c\u00f3digo es bastante sencillo: devolver un flotante a un tipo entero. %% writefile my_functions . py def convert_to_integer ( value : float ) -> int : return int ( value ) Writing my_functions.py","title":"Tests m\u00e1s elaborados"},{"location":"testing/hypothesis/#decoradores-utiles","text":"Existen varias funcionalidades que nos ofrece hypothesis , dentro de las cuales se destacan: given : convierte una funci\u00f3n de prueba que acepta argumentos en una prueba aleatoria. example : asegura que siempre se prueba un ejemplo espec\u00edfico. assume : es como una afirmaci\u00f3n que marca el ejemplo como malo, en lugar de fallar en la prueba. Veamos un ejemplo sencillo que mezcle estos tres atributos: %% writefile test_my_function . py import numpy as np import hypothesis.strategies as st from hypothesis import given , example , assume from my_functions import convert_to_integer @example ( np . inf ) @given ( st . floats ( allow_nan = False )) def test_convert_to_integer ( my_float ): assume ( my_float != np . inf ) assume ( my_float !=- np . inf ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Writing test_my_function.py Corremos los test correspondientes asociados a este ejemplo: ! python - m pytest test_my_function . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: < 1ms, ~ 43% in data generation - 2 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.14 seconds): - Typical runtimes: 0-1 ms, ~ 42% in data generation - 98 passing examples, 0 failing examples, 21 invalid examples - Stopped because settings.max_examples=100 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.29s\u001b[0m\u001b[32m ===============================\u001b[0m","title":"Decoradores \u00fatiles"},{"location":"testing/hypothesis/#estrategias","text":"Una estrategia define los datos que genera Hypothesis para las pruebas y c\u00f3mo se \u201csimplifican\u201d los ejemplos. En nuestro c\u00f3digo, solo definimos los par\u00e1metros de los datos; la simplificaci\u00f3n (o: \"shrinking\") es interna de Hypothesis. Comenzaremos con una estrategia que genera un valor flotante entre 0.0 y 10.0 (inclusive). Definimos esto en un archivo separado llamado data_strategies.py . Usar una clase de datos para esto puede parecer una exageraci\u00f3n, pero es \u00fatil cuando est\u00e1 trabajando con un c\u00f3digo m\u00e1s complejo que requiere un mont\u00f3n de par\u00e1metros diferentes. %% writefile data_strategies . py from pydantic import BaseModel import hypothesis.strategies as st class GeneratedData ( BaseModel ): float_value : st . SearchStrategy [ float ] class Config : arbitrary_types_allowed = True generated_data = GeneratedData ( float_value = st . floats ( min_value = 0.0 , max_value = 10.0 )) Writing data_strategies.py Una vez que hemos definido nuestra estrategia, agregamos un peque\u00f1o fragmento de c\u00f3digo para pasar los ejemplos generados por la hip\u00f3tesis a nuestra funci\u00f3n y afirmar algo sobre el resultado requerido (la \"propiedad\") del c\u00f3digo que queremos probar. El siguiente c\u00f3digo extrae un valor flotante del objeto de clase de datos generate_data que definimos en el archivo data_strategies.py anterior, pasa ese valor a trav\u00e9s de nuestra funci\u00f3n convert_to_integer y finalmente afirma que se mantiene la propiedad esperada. %% writefile test_my_function . py import hypothesis.strategies as st from hypothesis import given from my_functions import convert_to_integer from data_strategies import generated_data @given ( st . data ()) def test_convert_to_integer ( test_data : st . DataObject ): my_float = test_data . draw ( generated_data . float_value ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Overwriting test_my_function.py Se corren las respectivas pruebas, agregando el comando extra --hypothesis-show-statistics , que muestra estad\u00edsticas relacionadas de las pruebas hechas por Hypothesis . ! python - m pytest test_my_function . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: ~ 1ms, ~ 68% in data generation - 1 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.09 seconds): - Typical runtimes: < 1ms, ~ 39% in data generation - 99 passing examples, 0 failing examples, 0 invalid examples - Stopped because settings.max_examples=100 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.15s\u001b[0m\u001b[32m ===============================\u001b[0m","title":"Estrategias"},{"location":"testing/hypothesis/#configuraciones","text":"Antes de ejecutar el m\u00f3dulo de prueba que desarrollamos anteriormente, revisemos algunas de las configuraciones que podemos usar para adaptar la hip\u00f3tesis a nuestro caso de uso. La hip\u00f3tesis viene con un mont\u00f3n de configuraciones. Estas configuraciones se pueden pasar a su funci\u00f3n de prueba usando el decorador settings() , o registrando las configuraciones en un perfil y pasando el perfil usando el decorador (vea el c\u00f3digo de ejemplo a continuaci\u00f3n). Algunas configuraciones \u00fatiles incluyen: max_examples : controla cu\u00e1ntos ejemplos de aprobaci\u00f3n se requieren antes de que concluya la prueba. Esto es \u00fatil si tiene algunas pautas internas para el volumen de pruebas que se requieren para que un nuevo fragmento de c\u00f3digo pase la revisi\u00f3n. Como regla general: cuanto m\u00e1s complejo sea el c\u00f3digo, m\u00e1s ejemplos querr\u00e1 ejecutar (los autores de Hypothesis se\u00f1alan que lograron encontrar nuevos errores despu\u00e9s de varios millones de ejemplos mientras probaban SymPy); deadline : especifica cu\u00e1nto tiempo puede tomar un ejemplo individual. Deber\u00e1 aumentar este valor si tiene un c\u00f3digo muy complejo en el que un ejemplo puede tardar m\u00e1s que el tiempo predeterminado en ejecutarse; suppress_health_check : le permite especificar qu\u00e9 \"controles de salud\" ignorar. \u00datil cuando est\u00e1 trabajando con grandes conjuntos de datos ( HealthCheck.data_too_large ) o datos que tardan mucho en generarse ( HealthCheck.too_slow ) %% writefile test_my_function_with_settings . py from hypothesis import given , settings , HealthCheck import hypothesis.strategies as st from my_functions import convert_to_integer from data_strategies import generated_data settings . register_profile ( \"my_profile\" , max_examples = 200 , deadline = 60 * 1000 , # Allow 1 min per example (deadline is specified in milliseconds) suppress_health_check = ( HealthCheck . too_slow , HealthCheck . data_too_large ), ) @given ( st . data ()) @settings ( settings . load_profile ( \"my_profile\" )) def test_convert_to_integer ( test_data : st . DataObject ): my_float = test_data . draw ( generated_data . float_value ) float_to_int = convert_to_integer ( my_float ) assert isinstance ( float_to_int , int ) Writing test_my_function_with_settings.py Corremos los respectivos tests: ! python - m pytest test_my_function_with_settings . py -- hypothesis - show - statistics \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.7.3, pytest-5.4.3, py-1.9.0, pluggy-0.13.1 rootdir: /home/falfaro/PycharmProjects/python_development_tools/python_development_tools/TDD plugins: cov-2.10.1, hypothesis-5.36.1 collected 1 item \u001b[0m test_my_function_with_settings.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ============================ Hypothesis Statistics ============================= test_my_function_with_settings.py::test_convert_to_integer: - during reuse phase (0.00 seconds): - Typical runtimes: < 1ms, ~ 57% in data generation - 1 passing examples, 0 failing examples, 0 invalid examples - during generate phase (0.12 seconds): - Typical runtimes: < 1ms, ~ 39% in data generation - 199 passing examples, 0 failing examples, 0 invalid examples - Stopped because settings.max_examples=200 \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.18s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r *. py","title":"Configuraciones"},{"location":"testing/intro/","text":"Introducci\u00f3n \u00bfQu\u00e9 es el Test Driven Development ? En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el coraz\u00f3n de nuestro trabajo. En su forma m\u00e1s simple consiste en un proceso iterativo de 3 fases: Red : Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla Green : Escribe el c\u00f3digo m\u00ednimo necesario para pasar ese test Refactor : Refactoriza de ser necesario Ejemplo sencillo A modo de ejemplo, vamos a testear la funci\u00f3n paridad , que determina si un n\u00famero natural es par o no. Lo primero que se debe hacer es crear el test, para ello se ocupar\u00e1 la librer\u00eda pytest . Nota : No es necesario conocer previamente la librer\u00eda pytest para entender el ejemplo. @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected El test nos dice que si el input es el n\u00famero 2 , la funci\u00f3n paridad devuelve el output 'par' . C\u00f3mo a\u00fan no hemos escrito la funci\u00f3n, el test fallar\u00e1 ( fase red ). ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py F [100%] ========= 1 failed in 0.14s =============================================== Ahora, se escribe la funci\u00f3n paridad ( fase green ): def paridad ( n : int ) -> str : \"\"\" Determina si un numero natural es par o no. :param n: numero entero :return: 'par' si es el numero es par; 'impar' en otro caso \"\"\" return 'par' if n % 2 == 0 else 'impar' Volvemos a correr el test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py . [100%] ========= 1 passed in 0.06s =============================================== Hemos cometido un descuido a proposito, no hemos testeado el caso si el n\u00famero fuese impar, por lo cual reescribimos el test ( fase refactor ) @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ( 3 , 'impar' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected y corremos nuevamente los test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 2 items temp/test_funcion.py .. [100%] ========= 2 passed in 0.06s =============================================== Listo, nuestra funci\u00f3n paridad ha sido testeado correctamente!. \u00bfPorqu\u00e9 deber\u00eda usarlo? Existen varias razones por las que uno deber\u00eda usar TDD. Entre ellas podemos encontrar: - Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los l\u00edmites del problema y c\u00f3mo podemos resolverlo. Con el tiempo esto ayuda a obtener un dise\u00f1o modular y reusable del c\u00f3digo. - Escribir tests ayuda la forma en que escribimos c\u00f3digo, haci\u00e9ndolo m\u00e1s legible a otros. Sin embargo, no es un acto de altruismo, la mayor\u00eda de las veces ese otro es tu futuro yo. - Verifica que el c\u00f3digo funciona de la manera que se espera, y lo hace de forma autom\u00e1tica. - Te permite realizar refactoring con la certeza de que no has roto nada. - Los tests escritos sirven como documentaci\u00f3n para otros desarrolladores. - Es una pr\u00e1ctica requerida en metodolog\u00edas de desarrollo de software agile . Evidencia emp\u00edrica El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de c\u00f3digo hasta las 155k. Estas son parte de sus conclusiones: Todos los equipos demostraron una baja considerable en la densidad de defectos: 40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. Como todo en la vida, nada es gratis: Incremento del tiempo de desarrollo var\u00eda entre un 15% a 35%. Sin embargo Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantenci\u00f3n reducidos debido al incremento en calidad. Adem\u00e1s, es importante escribir tests junto con la implementaci\u00f3n en peque\u00f1as iteraciones. George y Williams encontraron que escribir tests despu\u00e9s de que la aplicaci\u00f3n est\u00e1 mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y adem\u00e1s la aplicaci\u00f3n se vuelve menos testeable. Otra conclusi\u00f3n interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un dise\u00f1o m\u00e1s simple. \u00bfPuedo usar TDD siempre? No, pero puedes usarlo casi siempre. El an\u00e1lisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementaci\u00f3n v\u00eda testing. Librer\u00edas disponibles Ac\u00e1 listamos algunas librer\u00edas de TDD en Python: - unittest : M\u00f3dulo dentro de la librer\u00eda est\u00e1ndar de Python. Permite realizar tests unitarios, de integraci\u00f3n y end to end. - doctest : Permite realizar test de la documentaci\u00f3n del c\u00f3digo (ejemplos: Numpy o Pandas ). - pytest : Librer\u00eda de testing ampliamente usada en proyectos nuevos de Python. - nose : Librer\u00eda que extiende unittest para hacerlo m\u00e1s simple. - coverage : Herramienta para medir la cobertura de c\u00f3digo de los proyectos. - tox : Herramienta para facilitar el test de una librer\u00eda en diferentes versiones e int\u00e9rpretes de Python. - hypothesis : Librer\u00eda para escribir tests v\u00eda reglas que ayuda a encontrar casos borde. - behave : Permite utilizar Behavior Driven Development , un proceso de desarrollo derivado del TDD. Knowledge base / Lecturas recomendadas Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , es una buena lectura, sobretodo los consejos que dan en las conclusiones. Google Testing Blog : Poseen varios art\u00edculos sobre c\u00f3mo abordar problemas tipo, buenas pr\u00e1cticas de dise\u00f1o para generar c\u00f3digo testeable, entre otros. En particular destaca la serie Testing on the Toilet . Cualquier art\u00edculo de Martin Fowler sobre testing , empezando por \u00e9ste Design Patterns : Los patrones de dise\u00f1o de software tienen en consideraci\u00f3n que el c\u00f3digo sea testeable .","title":"Introducci\u00f3n"},{"location":"testing/intro/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"testing/intro/#que-es-el-test-driven-development","text":"En palabras simples, el desarrollo guiado por pruebas pone las pruebas en el coraz\u00f3n de nuestro trabajo. En su forma m\u00e1s simple consiste en un proceso iterativo de 3 fases: Red : Escribe un test que ponga a prueba una nueva funcionalidad y asegurate de que el test falla Green : Escribe el c\u00f3digo m\u00ednimo necesario para pasar ese test Refactor : Refactoriza de ser necesario","title":"\u00bfQu\u00e9 es el Test Driven Development?"},{"location":"testing/intro/#ejemplo-sencillo","text":"A modo de ejemplo, vamos a testear la funci\u00f3n paridad , que determina si un n\u00famero natural es par o no. Lo primero que se debe hacer es crear el test, para ello se ocupar\u00e1 la librer\u00eda pytest . Nota : No es necesario conocer previamente la librer\u00eda pytest para entender el ejemplo. @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected El test nos dice que si el input es el n\u00famero 2 , la funci\u00f3n paridad devuelve el output 'par' . C\u00f3mo a\u00fan no hemos escrito la funci\u00f3n, el test fallar\u00e1 ( fase red ). ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py F [100%] ========= 1 failed in 0.14s =============================================== Ahora, se escribe la funci\u00f3n paridad ( fase green ): def paridad ( n : int ) -> str : \"\"\" Determina si un numero natural es par o no. :param n: numero entero :return: 'par' si es el numero es par; 'impar' en otro caso \"\"\" return 'par' if n % 2 == 0 else 'impar' Volvemos a correr el test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 1 item temp/test_funcion.py . [100%] ========= 1 passed in 0.06s =============================================== Hemos cometido un descuido a proposito, no hemos testeado el caso si el n\u00famero fuese impar, por lo cual reescribimos el test ( fase refactor ) @pytest . mark . parametrize ( \"number, expected\" , [ ( 2 , 'par' ), ( 3 , 'impar' ), ]) def test_paridad ( number , expected ): assert paridad ( number ) == expected y corremos nuevamente los test: ========= test session starts ============================================ platform linux -- Python 3.8.10, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/ds_blog plugins: anyio-3.3.0 collected 2 items temp/test_funcion.py .. [100%] ========= 2 passed in 0.06s =============================================== Listo, nuestra funci\u00f3n paridad ha sido testeado correctamente!.","title":"Ejemplo sencillo"},{"location":"testing/intro/#porque-deberia-usarlo","text":"Existen varias razones por las que uno deber\u00eda usar TDD. Entre ellas podemos encontrar: - Formular bien nuestros pensamientos mediante la escritura de un test significativo antes de ponernos a solucionar el problema nos ayuda a clarificar los l\u00edmites del problema y c\u00f3mo podemos resolverlo. Con el tiempo esto ayuda a obtener un dise\u00f1o modular y reusable del c\u00f3digo. - Escribir tests ayuda la forma en que escribimos c\u00f3digo, haci\u00e9ndolo m\u00e1s legible a otros. Sin embargo, no es un acto de altruismo, la mayor\u00eda de las veces ese otro es tu futuro yo. - Verifica que el c\u00f3digo funciona de la manera que se espera, y lo hace de forma autom\u00e1tica. - Te permite realizar refactoring con la certeza de que no has roto nada. - Los tests escritos sirven como documentaci\u00f3n para otros desarrolladores. - Es una pr\u00e1ctica requerida en metodolog\u00edas de desarrollo de software agile .","title":"\u00bfPorqu\u00e9 deber\u00eda usarlo?"},{"location":"testing/intro/#evidencia-empirica","text":"El 2008, Nagappan, Maximilien, Bhat y Williams publicaron el paper llamado Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , en donde estudiaron 4 equipos de trabajo (3 de Microsoft y 1 de IBM), con proyectos que variaban entre las 6000 lineas de c\u00f3digo hasta las 155k. Estas son parte de sus conclusiones: Todos los equipos demostraron una baja considerable en la densidad de defectos: 40% para el equipo de IBM, y entre 60-90% para los equipos de Microsoft. Como todo en la vida, nada es gratis: Incremento del tiempo de desarrollo var\u00eda entre un 15% a 35%. Sin embargo Desde un punto de vista de eficacia este incremento en tiempo de desarrollo se compensa por los costos de mantenci\u00f3n reducidos debido al incremento en calidad. Adem\u00e1s, es importante escribir tests junto con la implementaci\u00f3n en peque\u00f1as iteraciones. George y Williams encontraron que escribir tests despu\u00e9s de que la aplicaci\u00f3n est\u00e1 mas o menos lista hace que se testee menos porque los desarrolladores piensan en menos casos, y adem\u00e1s la aplicaci\u00f3n se vuelve menos testeable. Otra conclusi\u00f3n interesante del estudio de George y Williams es que un 79% de los desarrolladores experimentaron que el uso de TDD conlleva a un dise\u00f1o m\u00e1s simple.","title":"Evidencia emp\u00edrica"},{"location":"testing/intro/#puedo-usar-tdd-siempre","text":"No, pero puedes usarlo casi siempre. El an\u00e1lisis exploratorio es un caso en que el uso de TDD no hace sentido. Una vez que tenemos definido el problema a solucionar y un mejor entendimiento del problema podemos aterrizar nuestras ideas a la implementaci\u00f3n v\u00eda testing.","title":"\u00bfPuedo usar TDD siempre?"},{"location":"testing/intro/#librerias-disponibles","text":"Ac\u00e1 listamos algunas librer\u00edas de TDD en Python: - unittest : M\u00f3dulo dentro de la librer\u00eda est\u00e1ndar de Python. Permite realizar tests unitarios, de integraci\u00f3n y end to end. - doctest : Permite realizar test de la documentaci\u00f3n del c\u00f3digo (ejemplos: Numpy o Pandas ). - pytest : Librer\u00eda de testing ampliamente usada en proyectos nuevos de Python. - nose : Librer\u00eda que extiende unittest para hacerlo m\u00e1s simple. - coverage : Herramienta para medir la cobertura de c\u00f3digo de los proyectos. - tox : Herramienta para facilitar el test de una librer\u00eda en diferentes versiones e int\u00e9rpretes de Python. - hypothesis : Librer\u00eda para escribir tests v\u00eda reglas que ayuda a encontrar casos borde. - behave : Permite utilizar Behavior Driven Development , un proceso de desarrollo derivado del TDD.","title":"Librer\u00edas disponibles"},{"location":"testing/intro/#knowledge-base-lecturas-recomendadas","text":"Realizing Quality Improvement Through Test Driven Development - Results and Experiences of Four Industrial Teams , es una buena lectura, sobretodo los consejos que dan en las conclusiones. Google Testing Blog : Poseen varios art\u00edculos sobre c\u00f3mo abordar problemas tipo, buenas pr\u00e1cticas de dise\u00f1o para generar c\u00f3digo testeable, entre otros. En particular destaca la serie Testing on the Toilet . Cualquier art\u00edculo de Martin Fowler sobre testing , empezando por \u00e9ste Design Patterns : Los patrones de dise\u00f1o de software tienen en consideraci\u00f3n que el c\u00f3digo sea testeable .","title":"Knowledge base / Lecturas recomendadas"},{"location":"testing/mocker/","text":"Mocking functions: Mocker Introducci\u00f3n A veces, durante las pruebas, necesita algunos datos falsos. Tal vez est\u00e9 haciendo una llamada de API de terceros que puede ser costosa de ejecutar o tiene alg\u00fan l\u00edmite que no desea arriesgarse a alcanzar. O tal vez necesite crear un objeto completo sobre la marcha solo para una o dos funciones, pero ese objeto puede ser dif\u00edcil de construir desde cero. O tal vez tus necesidades sean m\u00e1s sencillas. Por estas razones y m\u00e1s, existe la biblioteca mock . Actualmente estamos usando pytest , por lo que no tenemos que preocuparnos por acceder a mock desde la biblioteca unittest ; podemos usar pytest-mock . Si este paquete est\u00e1 instalado, cuando ejecutemos py.test tendremos acceso al accesorio mocker , que ha adjuntado toda la funcionalidad de la biblioteca unittest.mock . Esta no ser\u00e1 una explicaci\u00f3n exhaustiva de lo que se puede hacer con la biblioteca pytest-mock , pero cubrir\u00e1 algunos de los casos de uso m\u00e1s comunes. Monkey Patching monkeypatch le permite interceptar lo que har\u00eda normalmente una funci\u00f3n, sustituyendo su ejecuci\u00f3n completa con un valor de retorno de su propia especificaci\u00f3n. Tenga en cuenta que el monkey patching en una llamada de funci\u00f3n no cuenta como una prueba de esa llamada de funci\u00f3n. En realidad, no est\u00e1 usando la funci\u00f3n que ha parcheado; est\u00e1 rechazando su comportamiento predeterminado y sustituy\u00e9ndolo por un nuevo comportamiento. Tomemos como ejemplo las siguientes funciones para obtener y analizar datos de GitHub %% writefile users . py import requests import json def get_user_followers ( username ): \"\"\"Grab the JSON object from a given user's followers.\"\"\" response = requests . get ( 'https://api.github.com/users/ {} /followers' . format ( username )) return response . content def get_follower_names ( username ): \"\"\"Given a username of a GitHub user, return a list of follower usernames.\"\"\" json_out = get_user_followers ( username ) as_dict = json . loads ( json_out ) return list ( map ( lambda x : x [ \"login\" ], as_dict )) Overwriting users.py GitHub establece un l\u00edmite en la velocidad a la que puede acceder a sus datos. Sin embargo, a medida que probamos get_follower_names y otro c\u00f3digo que pueda llamar a get_user_followers , tendremos que llamar a esta funci\u00f3n una y otra vez. %% writefile test_users . py from users import get_follower_names def test_get_follower_names_returns_name_list (): assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py En poco tiempo, alcanzaremos nuestro l\u00edmite de frecuencia (incluso con un token de API). Cualquier prueba que ejecutemos con esta funci\u00f3n despu\u00e9s de este punto fallar\u00e1 autom\u00e1ticamente. \u00bfEntonces lo que hay que hacer? En nuestro archivo de prueba, podemos \"parchear\" la llamada a la API de GitHub. Podemos hacer esto usando el accesorio monkeypatch proporcionado por pytest-mock . No es necesario que lo importe al archivo. %% writefile test_users . py import users def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' def test_get_follower_names_returns_name_list ( monkeypatch ): monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) assert 'jradavenport' in users . get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py monkeypatch es un objeto en s\u00ed mismo con una variedad de m\u00e9todos para falsificar atributos de otros objetos o espacios de nombres completos. En el ejemplo anterior, usamos el m\u00e9todo .setattr para intercambiar nuestra funci\u00f3n users.get_user_followers real con alguna otra funci\u00f3n sustituta, substitute_func . Al tratar el m\u00f3dulo de usuarios como un objeto, monkeypatch cambia el comportamiento de la funci\u00f3n get_user_followers dentro del m\u00f3dulo cuando se llama para esta prueba. La funci\u00f3n sustituta, a su vez, simplemente devuelve lo que le digamos para los prop\u00f3sitos de la(s) prueba(s). En el ejemplo anterior, codificamos una cadena que es un objeto JSON adecuado, tal como lo espera users.get_follower_names . De lo contrario, la funci\u00f3n sustituta no realiza ning\u00fan trabajo que no est\u00e9 especificado en la definici\u00f3n de la funci\u00f3n. El resultado final es que, para esta prueba , siempre que hagamos la solicitud HTTP completa a GitHub para sus datos, en su lugar, obtendremos el valor de retorno de substitute_func() . Fuera de esta prueba, a menos que usemos monkeypatch nuevamente, users.get_user_followers funcionar\u00e1 como se supone que debe hacerlo. Como ocurre con la mayor\u00eda de los problemas de prueba, si queremos que ocurra el mismo comportamiento en una variedad de pruebas, siempre podemos configurar un fixture . Recuerde que cada vez que incluye un fixture en su funci\u00f3n de prueba, el c\u00f3digo dentro del dispositivo se ejecuta en su totalidad antes de ejecutar la prueba. Podemos usar eso a nuestro favor. %% writefile test_users . py import pytest def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' @pytest . fixture def gh_patched ( monkeypatch ): import users monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) def test_get_follower_names_returns_name_list ( gh_patched ): from users import get_follower_names assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py Si queremos que en cada prueba este comportamiento sea parcheado sin que tengamos que pensar en ello, podemos establecer el argumento de palabra clave autouse de pytest.fixture en True . %% writefile test_users . py import pytest import users def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' @pytest . fixture ( autouse = True ) def gh_patched ( monkeypatch ): monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) def test_get_follower_names_returns_name_list (): from users import get_follower_names assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py Tenga en cuenta que la prueba ya no incluye nuestro fixture en la lista de par\u00e1metros. Tenga cuidado con los cambios de comportamiento universalmente. Si parcheamos el comportamiento de get_user_followers autom\u00e1ticamente para cada prueba, corremos el riesgo de no poder probar la funci\u00f3n despu\u00e9s de todo. MagicMock and Faking Objects A veces no es suficiente parchear una sola funci\u00f3n; a veces necesitas una instancia de un objeto completo, pero construir ese objeto no es un esfuerzo trivial. Considere el siguiente ejemplo: %% writefile request . py def some_view ( request ): if request . method == \"GET\" : return {} if request . method == \"POST\" : new_entry = Entry ( title = request . POST [ 'title' ], body = request . POST [ 'body' ] ) request . dbsession . add ( new_entry ) return HTTPFound ( request . route_url ( 'entry_list' )) Overwriting request.py Aqu\u00ed tenemos una funci\u00f3n de vista que maneja las solicitudes GET y POST . Se espera como argumento alg\u00fan tipo de objeto de solicitud, pero normalmente solo podemos construir objetos de solicitud a partir de una solicitud HTTP real. Por lo tanto, debemos tener configurado alg\u00fan tipo de cliente de prueba que pueda enviar solicitudes o recibir solicitudes reales para probar nuestra vista. (Ignore el hecho de que esto se basa en el patr\u00f3n de Pyramid para las solicitudes de construcci\u00f3n y que Pyramid tiene su propio objeto DummyRequest integrado) Con el objeto MagicMock , podemos construir un objeto que pueda actuar como una request sin tener que ser realmente una instancia real de ninguna clase de request . En ese objeto podemos definir cualquier m\u00e9todo o atributo que pueda ser \u00fatil para la prueba. De esta manera, nos preocupamos menos por la configuraci\u00f3n que implica probar una funci\u00f3n y, en cambio, nos enfocamos solo en darle a la funci\u00f3n lo que necesita para funcionar. Para obtener acceso al objeto MagicMock de pytest-mock , primero tenemos que incluir el accesorio de burla que nos proporciona pytest-mock . El objeto MagicMock es un atributo de ese dispositivo y se puede utilizar como desee desde all\u00ed. En nuestra prueba para some_view , podr\u00edamos escribir %% writefile test_request_get . py def test_some_view_get_req_returns_dict ( mocker ): from views import some_view req = mocker . MagicMock () req . method = 'GET' assert some_view ( req ) == {} Writing test_request_get.py De esta forma probamos que la funci\u00f3n some_view dado un objeto con un m\u00e9todo de GET devuelve el diccionario que esperamos. De manera similar, podemos escribir m\u00e1s pruebas asumiendo que cualquier objeto simulado por el que pasamos es el objeto real. %% writefile test_request_post . py def test_some_view_post_returns_redirect ( mocker ): from views import some_view req = mocker . MagicMock () req . method = 'POST' req . POST = { 'title' : 'some title' , 'body' : 'some body text' } req . dbsession . add = lambda arg : None assert isinstance ( some_view ( req ), HTTPFound ) Overwriting test_request_post.py Aqu\u00ed hemos creado un objeto con un atributo de m\u00e9todo que tiene un valor de 'POST', un atributo POST que es un diccionario que contiene algunos valores y un atributo dbsession que tiene su propio m\u00e9todo falso, add() . Ninguno de estos est\u00e1 obligado a funcionar realmente para que nuestra prueba pase. Omitimos la sobrecarga de tener que configurar esa funcionalidad solo para ejecutar estas pruebas. En cambio, nos aseguramos de que nuestro objeto falso tenga todos los atributos que necesitamos para que la funci\u00f3n funcione. Luego lo pasamos a la funci\u00f3n sin que la funci\u00f3n sea m\u00e1s sabia. Como podemos ver, el objeto MagicMock es pr\u00e1cticamente arcilla para esculpir, adoptando cualquier forma y funcionalidad que necesitemos por el momento. Es bueno para pruebas unitarias de funciones que no requieren que tambi\u00e9n verifiquemos los efectos secundarios. Dependiendo del efecto secundario que esperemos, es posible que incluso podamos burlarnos de eso proporcionando el argumento de la palabra clave side_effect al inicializar MagicMock , pero si estamos llegando al punto de probar la funcionalidad interconectada, es posible que deseemos elegir un m\u00e9todo de prueba diferente. mocker.spy for Tracking Your Methods A veces no quieres apropiarte completamente de una funci\u00f3n. A veces, solo desea realizar un seguimiento del uso de una funci\u00f3n en su aplicaci\u00f3n o base de c\u00f3digo. Para eso, hay mocker.spy . mocker.spy permitir\u00e1 que su objeto o funci\u00f3n act\u00fae exactamente como lo har\u00eda normalmente en todos los casos. El beneficio es que puede utilizar algunas de las caracter\u00edsticas de un objeto MagicMock junto con las operaciones habituales de su funci\u00f3n u objeto. Por ejemplo, considere el siguiente objeto masivamente ineficiente %% writefile visits . py class Numbers ( object ): def __init__ ( self , iterable ): self . _container = iterable def make_unique ( self ): i = 0 visited = [] while i < len ( self . _container ): if self . _container [ i ] in visited : self . _drop_val ( i ) i = 0 continue visited . append ( self . _container [ i ]) i += 1 def _drop_val ( self , idx ): self . _container . pop ( idx ) Overwriting visits.py Se debe llamar al m\u00e9todo _drop_val siempre que haya un valor para eliminar de la lista de contenedores. Quiz\u00e1s para una lista determinada de valores (es decir, \\([1,2,1,2,1,2]\\) ) quiero asegurarme de que _drop_val se llame un n\u00famero espec\u00edfico de veces (es decir, 4). Puedo incorporar eso en mis pruebas espiando _drop_val y verificando la cantidad de veces que se llam\u00f3 a este m\u00e9todo. %% writefile test_visits . py def test_values_are_dropped_if_already_seen ( mocker ): nums = Numbers ([ 1 , 2 , 1 , 2 , 1 , 2 ]) mocker . spy ( nums , '_drop_val' ) nums . make_unique () assert nums . _make_unique . call_count == 4 Overwriting test_visits.py Y ahora, cada vez que se llam\u00f3 a _drop_val , ese recuento se mantuvo y se puede verificar m\u00e1s adelante. Adem\u00e1s de espiar el recuento de llamadas, los m\u00e9todos de espionaje tienen otras funciones \u00fatiles: assert_called_with( args, *kwargs) assert_any_call( args, *kwargs) called mock_calls Consulte la documentaci\u00f3n de Mock Class para conocer todos los detalles. Puede usar esto de varias maneras, como encontrar cuellos de botella en la ejecuci\u00f3n de su c\u00f3digo buscando m\u00e9todos que se llaman un mont\u00f3n de veces, solucionar problemas de ejecuci\u00f3n de la funci\u00f3n verificando con qu\u00e9 se llama, descubrir qu\u00e9 funciones / m\u00e9todos est\u00e1n llamando al est\u00e1s interesado, etc.","title":"Mocker"},{"location":"testing/mocker/#mocking-functions-mocker","text":"","title":"Mocking functions: Mocker"},{"location":"testing/mocker/#introduccion","text":"A veces, durante las pruebas, necesita algunos datos falsos. Tal vez est\u00e9 haciendo una llamada de API de terceros que puede ser costosa de ejecutar o tiene alg\u00fan l\u00edmite que no desea arriesgarse a alcanzar. O tal vez necesite crear un objeto completo sobre la marcha solo para una o dos funciones, pero ese objeto puede ser dif\u00edcil de construir desde cero. O tal vez tus necesidades sean m\u00e1s sencillas. Por estas razones y m\u00e1s, existe la biblioteca mock . Actualmente estamos usando pytest , por lo que no tenemos que preocuparnos por acceder a mock desde la biblioteca unittest ; podemos usar pytest-mock . Si este paquete est\u00e1 instalado, cuando ejecutemos py.test tendremos acceso al accesorio mocker , que ha adjuntado toda la funcionalidad de la biblioteca unittest.mock . Esta no ser\u00e1 una explicaci\u00f3n exhaustiva de lo que se puede hacer con la biblioteca pytest-mock , pero cubrir\u00e1 algunos de los casos de uso m\u00e1s comunes.","title":"Introducci\u00f3n"},{"location":"testing/mocker/#monkey-patching","text":"monkeypatch le permite interceptar lo que har\u00eda normalmente una funci\u00f3n, sustituyendo su ejecuci\u00f3n completa con un valor de retorno de su propia especificaci\u00f3n. Tenga en cuenta que el monkey patching en una llamada de funci\u00f3n no cuenta como una prueba de esa llamada de funci\u00f3n. En realidad, no est\u00e1 usando la funci\u00f3n que ha parcheado; est\u00e1 rechazando su comportamiento predeterminado y sustituy\u00e9ndolo por un nuevo comportamiento. Tomemos como ejemplo las siguientes funciones para obtener y analizar datos de GitHub %% writefile users . py import requests import json def get_user_followers ( username ): \"\"\"Grab the JSON object from a given user's followers.\"\"\" response = requests . get ( 'https://api.github.com/users/ {} /followers' . format ( username )) return response . content def get_follower_names ( username ): \"\"\"Given a username of a GitHub user, return a list of follower usernames.\"\"\" json_out = get_user_followers ( username ) as_dict = json . loads ( json_out ) return list ( map ( lambda x : x [ \"login\" ], as_dict )) Overwriting users.py GitHub establece un l\u00edmite en la velocidad a la que puede acceder a sus datos. Sin embargo, a medida que probamos get_follower_names y otro c\u00f3digo que pueda llamar a get_user_followers , tendremos que llamar a esta funci\u00f3n una y otra vez. %% writefile test_users . py from users import get_follower_names def test_get_follower_names_returns_name_list (): assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py En poco tiempo, alcanzaremos nuestro l\u00edmite de frecuencia (incluso con un token de API). Cualquier prueba que ejecutemos con esta funci\u00f3n despu\u00e9s de este punto fallar\u00e1 autom\u00e1ticamente. \u00bfEntonces lo que hay que hacer? En nuestro archivo de prueba, podemos \"parchear\" la llamada a la API de GitHub. Podemos hacer esto usando el accesorio monkeypatch proporcionado por pytest-mock . No es necesario que lo importe al archivo. %% writefile test_users . py import users def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' def test_get_follower_names_returns_name_list ( monkeypatch ): monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) assert 'jradavenport' in users . get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py monkeypatch es un objeto en s\u00ed mismo con una variedad de m\u00e9todos para falsificar atributos de otros objetos o espacios de nombres completos. En el ejemplo anterior, usamos el m\u00e9todo .setattr para intercambiar nuestra funci\u00f3n users.get_user_followers real con alguna otra funci\u00f3n sustituta, substitute_func . Al tratar el m\u00f3dulo de usuarios como un objeto, monkeypatch cambia el comportamiento de la funci\u00f3n get_user_followers dentro del m\u00f3dulo cuando se llama para esta prueba. La funci\u00f3n sustituta, a su vez, simplemente devuelve lo que le digamos para los prop\u00f3sitos de la(s) prueba(s). En el ejemplo anterior, codificamos una cadena que es un objeto JSON adecuado, tal como lo espera users.get_follower_names . De lo contrario, la funci\u00f3n sustituta no realiza ning\u00fan trabajo que no est\u00e9 especificado en la definici\u00f3n de la funci\u00f3n. El resultado final es que, para esta prueba , siempre que hagamos la solicitud HTTP completa a GitHub para sus datos, en su lugar, obtendremos el valor de retorno de substitute_func() . Fuera de esta prueba, a menos que usemos monkeypatch nuevamente, users.get_user_followers funcionar\u00e1 como se supone que debe hacerlo. Como ocurre con la mayor\u00eda de los problemas de prueba, si queremos que ocurra el mismo comportamiento en una variedad de pruebas, siempre podemos configurar un fixture . Recuerde que cada vez que incluye un fixture en su funci\u00f3n de prueba, el c\u00f3digo dentro del dispositivo se ejecuta en su totalidad antes de ejecutar la prueba. Podemos usar eso a nuestro favor. %% writefile test_users . py import pytest def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' @pytest . fixture def gh_patched ( monkeypatch ): import users monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) def test_get_follower_names_returns_name_list ( gh_patched ): from users import get_follower_names assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py Si queremos que en cada prueba este comportamiento sea parcheado sin que tengamos que pensar en ello, podemos establecer el argumento de palabra clave autouse de pytest.fixture en True . %% writefile test_users . py import pytest import users def substitute_func ( username ): return '[{\"login\": \"aishapectyo\"},{\"login\": \"jradavenport\"},{\"login\": \"kridicule\"}]' @pytest . fixture ( autouse = True ) def gh_patched ( monkeypatch ): monkeypatch . setattr ( users , 'get_user_followers' , substitute_func ) def test_get_follower_names_returns_name_list (): from users import get_follower_names assert 'jradavenport' in get_follower_names ( 'nhuntwalker' ) Overwriting test_users.py Tenga en cuenta que la prueba ya no incluye nuestro fixture en la lista de par\u00e1metros. Tenga cuidado con los cambios de comportamiento universalmente. Si parcheamos el comportamiento de get_user_followers autom\u00e1ticamente para cada prueba, corremos el riesgo de no poder probar la funci\u00f3n despu\u00e9s de todo.","title":"Monkey Patching"},{"location":"testing/mocker/#magicmock-and-faking-objects","text":"A veces no es suficiente parchear una sola funci\u00f3n; a veces necesitas una instancia de un objeto completo, pero construir ese objeto no es un esfuerzo trivial. Considere el siguiente ejemplo: %% writefile request . py def some_view ( request ): if request . method == \"GET\" : return {} if request . method == \"POST\" : new_entry = Entry ( title = request . POST [ 'title' ], body = request . POST [ 'body' ] ) request . dbsession . add ( new_entry ) return HTTPFound ( request . route_url ( 'entry_list' )) Overwriting request.py Aqu\u00ed tenemos una funci\u00f3n de vista que maneja las solicitudes GET y POST . Se espera como argumento alg\u00fan tipo de objeto de solicitud, pero normalmente solo podemos construir objetos de solicitud a partir de una solicitud HTTP real. Por lo tanto, debemos tener configurado alg\u00fan tipo de cliente de prueba que pueda enviar solicitudes o recibir solicitudes reales para probar nuestra vista. (Ignore el hecho de que esto se basa en el patr\u00f3n de Pyramid para las solicitudes de construcci\u00f3n y que Pyramid tiene su propio objeto DummyRequest integrado) Con el objeto MagicMock , podemos construir un objeto que pueda actuar como una request sin tener que ser realmente una instancia real de ninguna clase de request . En ese objeto podemos definir cualquier m\u00e9todo o atributo que pueda ser \u00fatil para la prueba. De esta manera, nos preocupamos menos por la configuraci\u00f3n que implica probar una funci\u00f3n y, en cambio, nos enfocamos solo en darle a la funci\u00f3n lo que necesita para funcionar. Para obtener acceso al objeto MagicMock de pytest-mock , primero tenemos que incluir el accesorio de burla que nos proporciona pytest-mock . El objeto MagicMock es un atributo de ese dispositivo y se puede utilizar como desee desde all\u00ed. En nuestra prueba para some_view , podr\u00edamos escribir %% writefile test_request_get . py def test_some_view_get_req_returns_dict ( mocker ): from views import some_view req = mocker . MagicMock () req . method = 'GET' assert some_view ( req ) == {} Writing test_request_get.py De esta forma probamos que la funci\u00f3n some_view dado un objeto con un m\u00e9todo de GET devuelve el diccionario que esperamos. De manera similar, podemos escribir m\u00e1s pruebas asumiendo que cualquier objeto simulado por el que pasamos es el objeto real. %% writefile test_request_post . py def test_some_view_post_returns_redirect ( mocker ): from views import some_view req = mocker . MagicMock () req . method = 'POST' req . POST = { 'title' : 'some title' , 'body' : 'some body text' } req . dbsession . add = lambda arg : None assert isinstance ( some_view ( req ), HTTPFound ) Overwriting test_request_post.py Aqu\u00ed hemos creado un objeto con un atributo de m\u00e9todo que tiene un valor de 'POST', un atributo POST que es un diccionario que contiene algunos valores y un atributo dbsession que tiene su propio m\u00e9todo falso, add() . Ninguno de estos est\u00e1 obligado a funcionar realmente para que nuestra prueba pase. Omitimos la sobrecarga de tener que configurar esa funcionalidad solo para ejecutar estas pruebas. En cambio, nos aseguramos de que nuestro objeto falso tenga todos los atributos que necesitamos para que la funci\u00f3n funcione. Luego lo pasamos a la funci\u00f3n sin que la funci\u00f3n sea m\u00e1s sabia. Como podemos ver, el objeto MagicMock es pr\u00e1cticamente arcilla para esculpir, adoptando cualquier forma y funcionalidad que necesitemos por el momento. Es bueno para pruebas unitarias de funciones que no requieren que tambi\u00e9n verifiquemos los efectos secundarios. Dependiendo del efecto secundario que esperemos, es posible que incluso podamos burlarnos de eso proporcionando el argumento de la palabra clave side_effect al inicializar MagicMock , pero si estamos llegando al punto de probar la funcionalidad interconectada, es posible que deseemos elegir un m\u00e9todo de prueba diferente.","title":"MagicMock and Faking Objects"},{"location":"testing/mocker/#mockerspy-for-tracking-your-methods","text":"A veces no quieres apropiarte completamente de una funci\u00f3n. A veces, solo desea realizar un seguimiento del uso de una funci\u00f3n en su aplicaci\u00f3n o base de c\u00f3digo. Para eso, hay mocker.spy . mocker.spy permitir\u00e1 que su objeto o funci\u00f3n act\u00fae exactamente como lo har\u00eda normalmente en todos los casos. El beneficio es que puede utilizar algunas de las caracter\u00edsticas de un objeto MagicMock junto con las operaciones habituales de su funci\u00f3n u objeto. Por ejemplo, considere el siguiente objeto masivamente ineficiente %% writefile visits . py class Numbers ( object ): def __init__ ( self , iterable ): self . _container = iterable def make_unique ( self ): i = 0 visited = [] while i < len ( self . _container ): if self . _container [ i ] in visited : self . _drop_val ( i ) i = 0 continue visited . append ( self . _container [ i ]) i += 1 def _drop_val ( self , idx ): self . _container . pop ( idx ) Overwriting visits.py Se debe llamar al m\u00e9todo _drop_val siempre que haya un valor para eliminar de la lista de contenedores. Quiz\u00e1s para una lista determinada de valores (es decir, \\([1,2,1,2,1,2]\\) ) quiero asegurarme de que _drop_val se llame un n\u00famero espec\u00edfico de veces (es decir, 4). Puedo incorporar eso en mis pruebas espiando _drop_val y verificando la cantidad de veces que se llam\u00f3 a este m\u00e9todo. %% writefile test_visits . py def test_values_are_dropped_if_already_seen ( mocker ): nums = Numbers ([ 1 , 2 , 1 , 2 , 1 , 2 ]) mocker . spy ( nums , '_drop_val' ) nums . make_unique () assert nums . _make_unique . call_count == 4 Overwriting test_visits.py Y ahora, cada vez que se llam\u00f3 a _drop_val , ese recuento se mantuvo y se puede verificar m\u00e1s adelante. Adem\u00e1s de espiar el recuento de llamadas, los m\u00e9todos de espionaje tienen otras funciones \u00fatiles: assert_called_with( args, *kwargs) assert_any_call( args, *kwargs) called mock_calls Consulte la documentaci\u00f3n de Mock Class para conocer todos los detalles. Puede usar esto de varias maneras, como encontrar cuellos de botella en la ejecuci\u00f3n de su c\u00f3digo buscando m\u00e9todos que se llaman un mont\u00f3n de veces, solucionar problemas de ejecuci\u00f3n de la funci\u00f3n verificando con qu\u00e9 se llama, descubrir qu\u00e9 funciones / m\u00e9todos est\u00e1n llamando al est\u00e1s interesado, etc.","title":"mocker.spy for Tracking Your Methods"},{"location":"testing/plugins/","text":"Pytest Plugins Introducci\u00f3n Esta secci\u00f3n habla sobre la instalaci\u00f3n y el uso de complementos de terceros. La instalaci\u00f3n de un complemento de terceros se puede hacer f\u00e1cilmente con pip : pip install pytest-NAME pip uninstall pytest-NAME Si se instala un complemento, pytest lo encuentra e integra autom\u00e1ticamente, no es necesario activarlo. Aqu\u00ed hay una peque\u00f1a lista anotada de algunos complementos populares: pytest-django : write tests for django apps, using pytest integration. pytest-twisted : write tests for twisted apps, starting a reactor and processing deferreds from test functions. pytest-cov : coverage reporting, compatible with distributed testing pytest-xdist : to distribute tests to CPUs and remote hosts, to run in boxed mode which allows to survive segmentation faults, to run in looponfailing mode, automatically re-running failing tests on file changes. pytest-instafail : to report failures while the test run is happening. pytest-bdd : to write tests using behaviour-driven testing. pytest-timeout : to timeout tests based on function marks or global definitions. pytest-pep8 : a --pep8 option to enable PEP8 compliance checking. pytest-flakes : check source code with pyflakes. oejskit : a plugin to run javascript unittests in live browsers. Para ver una lista completa de todos los complementos con su \u00faltimo estado de prueba contra diferentes versiones de pytest y Python, visite plugincompat . Pytest Coverage Este plugin produce informes de cobertura. En comparaci\u00f3n con el uso de coverage run , este complemento tiene algunos extras: Soporte de subprocesos: puede bifurcar o ejecutar cosas en un subproceso y estar\u00e1 cubierto sin ning\u00fan problema. Soporte de Xdist : puede usar todas las funciones de pytest-xdist y a\u00fan obtener cobertura. Comportamiento constante de Pytest. Si ejecuta la sentencia coverage run -m pytest , tendr\u00e1 sys.path ligeramente diferente (CWD estar\u00e1 en \u00e9l, a diferencia de cuando se ejecuta pytest ). Reporting Es posible generar cualquier combinaci\u00f3n de informes para una sola ejecuci\u00f3n de test. Los informes disponibles son terminales (con o sin los n\u00fameros de l\u00ednea que faltan), HTML, XML y c\u00f3digo fuente anotado. Lo primero es replicar el ejemplo de la seci\u00f3n Unit testing: Pytest : 1.- El informe del terminal sin n\u00fameros de l\u00ednea (default): ! pytest -- cov - report term -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover -------------------------------------------- src/tests/__init__.py 0 0 100% src/tests/algo_test.py 15 0 100% src/tests/srel_test.py 6 0 100% src/utils/__init__.py 0 0 100% src/utils/algo.py 24 0 100% src/utils/srel.py 2 0 100% -------------------------------------------- TOTAL 47 0 100% \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.09s\u001b[0m\u001b[32m ===============================\u001b[0m 2.- El informe de la terminal con n\u00fameros de l\u00ednea: ! pytest -- cov - report term - missing -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover Missing ------------------------------------------------------ src/tests/__init__.py 0 0 100% src/tests/algo_test.py 15 0 100% src/tests/srel_test.py 6 0 100% src/utils/__init__.py 0 0 100% src/utils/algo.py 24 0 100% src/utils/srel.py 2 0 100% ------------------------------------------------------ TOTAL 47 0 100% \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.10s\u001b[0m\u001b[32m ===============================\u001b[0m 3.- El informe de la terminal con skip covered : ! pytest -- cov - report term : skip - covered -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover --------------------------- --------------------------- TOTAL 47 0 100% 6 files skipped due to complete coverage. \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.10s\u001b[0m\u001b[32m ===============================\u001b[0m 4.- Estas tres opciones de informe se env\u00edan a archivos sin mostrar nada en el terminal: ! pytest -- cov - report html \\ -- cov - report xml \\ -- cov - report annotate \\ -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Coverage annotated source written next to source Coverage HTML written to dir htmlcov Coverage XML written to file coverage.xml \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.15s\u001b[0m\u001b[32m ===============================\u001b[0m 5.- Se puede especificar la ubicaci\u00f3n de salida para cada uno de estos informes. La ubicaci\u00f3n de salida del informe XML es un archivo. Donde, como ubicaci\u00f3n de salida para los informes HTML y de c\u00f3digo fuente anotado son directorios: ! pytest -- cov - report html : cov_html \\ -- cov - report xml : cov . xml \\ -- cov - report annotate : cov_annotate \\ -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Coverage annotated source written to dir cov_annotate Coverage HTML written to dir cov_html Coverage XML written to file cov.xml \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.17s\u001b[0m\u001b[32m ===============================\u001b[0m 6.- La opci\u00f3n de informe final tambi\u00e9n puede suprimir la impresi\u00f3n en el terminal: ! pytest -- cov - report = -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.12s\u001b[0m\u001b[32m ===============================\u001b[0m Este modo puede ser especialmente \u00fatil en servidores de integraci\u00f3n continua, donde se necesita un archivo de cobertura para el procesamiento posterior, pero no es necesario ver un informe local. Por ejemplo, las pruebas realizadas en Travis-CI podr\u00edan generar un archivo .coverage para usar con Coveralls . Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r cov_annotate cov_html htmlcov src *. py *. xml","title":"Plugins"},{"location":"testing/plugins/#pytest-plugins","text":"","title":"Pytest Plugins"},{"location":"testing/plugins/#introduccion","text":"Esta secci\u00f3n habla sobre la instalaci\u00f3n y el uso de complementos de terceros. La instalaci\u00f3n de un complemento de terceros se puede hacer f\u00e1cilmente con pip : pip install pytest-NAME pip uninstall pytest-NAME Si se instala un complemento, pytest lo encuentra e integra autom\u00e1ticamente, no es necesario activarlo. Aqu\u00ed hay una peque\u00f1a lista anotada de algunos complementos populares: pytest-django : write tests for django apps, using pytest integration. pytest-twisted : write tests for twisted apps, starting a reactor and processing deferreds from test functions. pytest-cov : coverage reporting, compatible with distributed testing pytest-xdist : to distribute tests to CPUs and remote hosts, to run in boxed mode which allows to survive segmentation faults, to run in looponfailing mode, automatically re-running failing tests on file changes. pytest-instafail : to report failures while the test run is happening. pytest-bdd : to write tests using behaviour-driven testing. pytest-timeout : to timeout tests based on function marks or global definitions. pytest-pep8 : a --pep8 option to enable PEP8 compliance checking. pytest-flakes : check source code with pyflakes. oejskit : a plugin to run javascript unittests in live browsers. Para ver una lista completa de todos los complementos con su \u00faltimo estado de prueba contra diferentes versiones de pytest y Python, visite plugincompat .","title":"Introducci\u00f3n"},{"location":"testing/plugins/#pytest-coverage","text":"Este plugin produce informes de cobertura. En comparaci\u00f3n con el uso de coverage run , este complemento tiene algunos extras: Soporte de subprocesos: puede bifurcar o ejecutar cosas en un subproceso y estar\u00e1 cubierto sin ning\u00fan problema. Soporte de Xdist : puede usar todas las funciones de pytest-xdist y a\u00fan obtener cobertura. Comportamiento constante de Pytest. Si ejecuta la sentencia coverage run -m pytest , tendr\u00e1 sys.path ligeramente diferente (CWD estar\u00e1 en \u00e9l, a diferencia de cuando se ejecuta pytest ).","title":"Pytest Coverage"},{"location":"testing/plugins/#reporting","text":"Es posible generar cualquier combinaci\u00f3n de informes para una sola ejecuci\u00f3n de test. Los informes disponibles son terminales (con o sin los n\u00fameros de l\u00ednea que faltan), HTML, XML y c\u00f3digo fuente anotado. Lo primero es replicar el ejemplo de la seci\u00f3n Unit testing: Pytest : 1.- El informe del terminal sin n\u00fameros de l\u00ednea (default): ! pytest -- cov - report term -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover -------------------------------------------- src/tests/__init__.py 0 0 100% src/tests/algo_test.py 15 0 100% src/tests/srel_test.py 6 0 100% src/utils/__init__.py 0 0 100% src/utils/algo.py 24 0 100% src/utils/srel.py 2 0 100% -------------------------------------------- TOTAL 47 0 100% \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.09s\u001b[0m\u001b[32m ===============================\u001b[0m 2.- El informe de la terminal con n\u00fameros de l\u00ednea: ! pytest -- cov - report term - missing -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover Missing ------------------------------------------------------ src/tests/__init__.py 0 0 100% src/tests/algo_test.py 15 0 100% src/tests/srel_test.py 6 0 100% src/utils/__init__.py 0 0 100% src/utils/algo.py 24 0 100% src/utils/srel.py 2 0 100% ------------------------------------------------------ TOTAL 47 0 100% \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.10s\u001b[0m\u001b[32m ===============================\u001b[0m 3.- El informe de la terminal con skip covered : ! pytest -- cov - report term : skip - covered -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Name Stmts Miss Cover --------------------------- --------------------------- TOTAL 47 0 100% 6 files skipped due to complete coverage. \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.10s\u001b[0m\u001b[32m ===============================\u001b[0m 4.- Estas tres opciones de informe se env\u00edan a archivos sin mostrar nada en el terminal: ! pytest -- cov - report html \\ -- cov - report xml \\ -- cov - report annotate \\ -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Coverage annotated source written next to source Coverage HTML written to dir htmlcov Coverage XML written to file coverage.xml \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.15s\u001b[0m\u001b[32m ===============================\u001b[0m 5.- Se puede especificar la ubicaci\u00f3n de salida para cada uno de estos informes. La ubicaci\u00f3n de salida del informe XML es un archivo. Donde, como ubicaci\u00f3n de salida para los informes HTML y de c\u00f3digo fuente anotado son directorios: ! pytest -- cov - report html : cov_html \\ -- cov - report xml : cov . xml \\ -- cov - report annotate : cov_annotate \\ -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m ----------- coverage: platform linux, python 3.8.5-final-0 ----------- Coverage annotated source written to dir cov_annotate Coverage HTML written to dir cov_html Coverage XML written to file cov.xml \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.17s\u001b[0m\u001b[32m ===============================\u001b[0m 6.- La opci\u00f3n de informe final tambi\u00e9n puede suprimir la impresi\u00f3n en el terminal: ! pytest -- cov - report = -- cov = src \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.12s\u001b[0m\u001b[32m ===============================\u001b[0m Este modo puede ser especialmente \u00fatil en servidores de integraci\u00f3n continua, donde se necesita un archivo de cobertura para el procesamiento posterior, pero no es necesario ver un informe local. Por ejemplo, las pruebas realizadas en Travis-CI podr\u00edan generar un archivo .coverage para usar con Coveralls . Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales ! rm - r cov_annotate cov_html htmlcov src *. py *. xml","title":"Reporting"},{"location":"testing/pytest/","text":"Unit testing: Pytest Introducci\u00f3n El framework pytest facilita la escritura de peque\u00f1os tests, pero escala para admitir test funcionales complejas para aplicaciones y librerias. Si ha escrito pruebas unitarias para su c\u00f3digo Python antes, es posible que haya utilizado el m\u00f3dulo unittest integrado de Python. unittest proporciona una base s\u00f3lida sobre la cual construir su suite de pruebas, pero tiene algunas deficiencias. Varios marcos de prueba de terceros intentan abordar algunos de los problemas con unittest, y pytest ha demostrado ser uno de los m\u00e1s populares. pytest es un ecosistema basado en complementos y rico en funciones para probar su c\u00f3digo Python. Uso de Pytest Si no se especifican argumentos, los archivos de tests se buscan en ubicaciones desde las rutas de tests (si est\u00e1n configuradas) o el directorio actual. Alternativamente, los argumentos de la l\u00ednea de comandos se pueden utilizar en cualquier combinaci\u00f3n de directorios, nombres de archivos o ID de nodo. En los directorios seleccionados, pytest busca archivos de test _ *.py o *_test.py . En los archivos seleccionados, pytest busca funciones de test con prefijo test. Veamos un ejemplo sencillo de esto: a) Escribir funciones a testear %% writefile algo . py def max ( values ): _max = values [ 0 ] for val in values : if val > _max : _max = val return _max def min ( values ): _min = values [ 0 ] for val in values : if val < _min : _min = val return _min Writing algo.py b) Escribir los tests %% writefile test_min_max . py import algo def test_min (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . min ( values ) assert val == 1 def test_max (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . max ( values ) assert val == 6 Writing test_min_max.py El archivo test_min_max.py tiene una palabra de test en su nombre. Nos sirve para diferenciar entre un script de python gen\u00e9rico respecto a uno de testeo. ! pytest test_min_max . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 2 items \u001b[0m test_min_max.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m2 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m ===============================\u001b[0m Esta es la salida. Hubo dos pruebas y ambas han pasado con \u00e9xito. Se muestra una salida m\u00e1s detallada con pytest -v test_min_max.py . Pytest skip Con el decorador de skip , podemos omitir los test especificados. Hay varias razones para saltarse el test; por ejemplo, una base de datos/servicio en l\u00ednea no est\u00e1 disponible en este momento o nos saltamos los test espec\u00edficas de Linux en Windows. %% writefile skipping . py import algo import pytest @pytest . mark . skip def test_min (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . min ( values ) assert val == 1 def test_max (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . max ( values ) assert val == 6 Writing skipping.py En el ejemplo, se omite test_min() . ! pytest skipping . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 2 items \u001b[0m skipping.py \u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m========================= \u001b[32m\u001b[1m1 passed\u001b[0m, \u001b[33m1 skipped\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m =========================\u001b[0m Pytest Xfail Podemos usar el marcador xfail para indicar que espera que falle una prueba. Un caso de uso com\u00fan para esto es cuando encuentra un error en su software y escribe una prueba para documentar c\u00f3mo deber\u00eda comportarse el software. Esta prueba, por supuesto, fallar\u00e1 hasta que corrija el error. Para evitar tener una prueba fallida, marca la prueba como xfail . Una vez que se corrige el error, elimina el marcador xfail y tiene una prueba de regresi\u00f3n que asegura que el error no se repita. %% writefile xfail . py import pytest xfail = pytest . mark . xfail @xfail def test_hello (): assert 0 @xfail ( run = False ) def test_hello2 (): assert 0 @xfail ( \"hasattr(os, 'sep')\" ) def test_hello3 (): assert 0 @xfail ( reason = \"bug 110\" ) def test_hello4 (): assert 0 @xfail ( 'pytest.__version__[0] != \"17\"' ) def test_hello5 (): assert 0 def test_hello6 (): pytest . xfail ( \"reason\" ) @xfail ( raises = IndexError ) def test_hello7 (): x = [] x [ 1 ] = 1 Writing xfail.py En este caso, todos los test ser\u00e1n ignorados (con una x ), lo cu\u00e1l no afectar\u00e1 al resto de los tests (suponiendo que los tests pasen correctamente). ! pytest xfail . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m xfail.py \u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m============================== \u001b[33m\u001b[1m7 xfailed\u001b[0m\u001b[33m in 0.13s\u001b[0m\u001b[33m ==============================\u001b[0m Pytest marking Podemos usar marcadores para organizar los test unitarios. %% writefile marking . py import pytest @pytest . mark . a def test_a1 (): assert ( 1 ) == ( 1 ) @pytest . mark . a def test_a2 (): assert ( 1 , 2 ) == ( 1 , 2 ) @pytest . mark . a def test_a3 (): assert ( 1 , 2 , 3 ) == ( 1 , 2 , 3 ) @pytest . mark . b def test_b1 (): assert \"falcon\" == \"fal\" + \"con\" @pytest . mark . b def test_b2 (): assert \"falcon\" == f \"fal { 'con' } \" Writing marking.py Tenemos dos grupos de tests identificados por marcadores, \\(a\\) y \\(b\\) . Estas unidades son ejecutadas por pytest -m a marking.py y pytest -m b marking.py . ! pytest - m a marking . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 5 items / 2 deselected / 3 selected \u001b[0m marking.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m=============================== warnings summary ===============================\u001b[0m marking.py:3 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:3: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:8 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:13 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:18 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b marking.py:23 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:23: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b -- Docs: https://docs.pytest.org/en/latest/warnings.html \u001b[33m================= \u001b[32m3 passed\u001b[0m, \u001b[33m\u001b[1m2 deselected\u001b[0m, \u001b[33m\u001b[1m5 warnings\u001b[0m\u001b[33m in 0.02s\u001b[0m\u001b[33m ==================\u001b[0m ! pytest - m b marking . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 5 items / 3 deselected / 2 selected \u001b[0m marking.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m=============================== warnings summary ===============================\u001b[0m marking.py:3 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:3: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:8 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:13 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:18 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b marking.py:23 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:23: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b -- Docs: https://docs.pytest.org/en/latest/warnings.html \u001b[33m================= \u001b[32m2 passed\u001b[0m, \u001b[33m\u001b[1m3 deselected\u001b[0m, \u001b[33m\u001b[1m5 warnings\u001b[0m\u001b[33m in 0.02s\u001b[0m\u001b[33m ==================\u001b[0m Pytest parameterized tests Con los tests parametrizados, podemos agregar m\u00faltiples valores a nuestras afirmaciones. Usamos el decorador @pytest.mark.parametrize . %% writefile parameterized . py import algo import pytest @pytest . mark . parametrize ( \"data, expected\" , [(( 2 , 3 , 1 , 4 , 6 ), 1 ), (( 5 , - 2 , 0 , 9 , 12 ), - 2 ), (( 200 , 100 , 0 , 300 , 400 ), 0 )]) def test_min ( data , expected ): val = algo . min ( data ) assert val == expected @pytest . mark . parametrize ( \"data, expected\" , [(( 2 , 3 , 1 , 4 , 6 ), 6 ), (( 5 , - 2 , 0 , 9 , 12 ), 12 ), (( 200 , 100 , 0 , 300 , 400 ), 400 )]) def test_max ( data , expected ): val = algo . max ( data ) assert val == expected Writing parameterized.py Pasamos dos valores a la funci\u00f3n de testeo: los datos y el valor esperado. En nuestro caso, probamos la funci\u00f3n min() con tres tuplas de datos. ! pytest parameterized . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 6 items \u001b[0m parameterized.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m6 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m ===============================\u001b[0m Pytest fixtures Los tests deben ejecutarse en el contexto de un conjunto conocido de objetos. Este conjunto de objetos se denomina test fixture . %% writefile algo2 . py def sel_sort ( data ): if not isinstance ( data , list ): vals = list ( data ) else : vals = data size = len ( vals ) for i in range ( 0 , size ): for j in range ( i + 1 , size ): if vals [ j ] < vals [ i ]: _min = vals [ j ] vals [ j ] = vals [ i ] vals [ i ] = _min return vals Writing algo2.py %% writefile fixtures . py import algo2 import pytest # fijar valor data @pytest . fixture def data (): return [ 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ] # pasar data como argumento del test def test_sel_sort ( data ): sorted_vals = algo2 . sel_sort ( data ) assert sorted_vals == sorted ( data ) Writing fixtures.py ! pytest fixtures . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 1 item \u001b[0m fixtures.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : para realizar los siguientes ejemplos, es necesario eliminar todos los archivos .py previos. # eliminar archivos .py ! rm *. py Pytest layouts Los tests de Python se pueden organizar de varias formas. Los tests se pueden integrar en el paquete de Python o pueden descansar fuera de la librer\u00eda. Integrated tests A continuaci\u00f3n, mostramos c\u00f3mo ejecutar pruebas dentro de un paquete de Python. setup.py utils \u2502 algo.py \u2502 srel.py \u2502 __init__.py \u2502 \u2514\u2500\u2500\u2500tests algo_test.py srel_test.py __init__.py Tenemos este dise\u00f1o del paquete. Los test se encuentran en el subdirectorio de tests dentro del paquete. a) crear archivos previos del ejemplos # crear carpetas ! mkdir utils tests # agregar archivo __init__.py ! touch utils / __init__ . py # agregar archivo __init__.py ! touch tests / __init__ . py b) crear archivos .py a testear %% writefile setup . py from setuptools import setup , find_packages setup ( name = \"utils\" , packages = find_packages ()) Writing setup.py %% writefile utils / algo . py def sel_sort ( data ): if not isinstance ( data , list ): vals = list ( data ) else : vals = data size = len ( vals ) for i in range ( 0 , size ): for j in range ( i + 1 , size ): if vals [ j ] < vals [ i ]: _min = vals [ j ] vals [ j ] = vals [ i ] vals [ i ] = _min return vals def max ( values ): _max = values [ 0 ] for val in values : if val > _max : _max = val return _max def min ( values ): _min = values [ 0 ] for val in values : if val < _min : _min = val return _min Writing utils/algo.py %% writefile utils / srel . py def is_palindrome ( val ): return val == val [:: - 1 ] Writing utils/srel.py c) crear los tests %% writefile tests / algo_test . py import utils.algo import pytest @pytest . mark . parametrize ( \"data\" , [ [ 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ], ( 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ) ] ) def test_sel_sort ( data ): sorted_vals = utils . algo . sel_sort ( data ) assert sorted_vals == sorted ( data ) @pytest . fixture def values (): return ( 2 , 3 , 1 , 4 , 6 ) def test_min ( values ): val = utils . algo . min ( values ) assert val == 1 def test_max ( values ): val = utils . algo . max ( values ) assert val == 6 Writing tests/algo_test.py %% writefile tests / srel_test . py import utils.srel import pytest @pytest . mark . parametrize ( \"word, expected\" , [ ( 'kayak' , True ), ( 'civic' , True ), ( 'forest' , False ) ] ) def test_palindrome ( word , expected ): val = utils . srel . is_palindrome ( word ) assert val == expected Writing tests/srel_test.py # dejar tests en la ruta correcta ! mv tests utils d) correr los test ! ! pytest -- pyargs utils \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m utils/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m utils/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m ===============================\u001b[0m Tests outside the package El siguiente ejemplo muestra un dise\u00f1o dela aplicaci\u00f3n donde los tests no est\u00e1n integrados dentro del paquete. setup.py src \u2514\u2500\u2500\u2500utils \u2502 algo.py \u2502 srel.py tests algo_test.py srel_test.py En este dise\u00f1o, tenemos tets fuera del \u00e1rbol de fuentes. a) crear dise\u00f1o del ejemplo # crear carpeta src ! mkdir src # mover carpeta utils ! mv utils src # mover carpeta tests ! mv src / utils / tests src / b) Correr los test ! ! pytest \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales #!rm -r cov_annotate cov_html htmlcov src *.py *.xml","title":"Pytest"},{"location":"testing/pytest/#unit-testing-pytest","text":"","title":"Unit testing: Pytest"},{"location":"testing/pytest/#introduccion","text":"El framework pytest facilita la escritura de peque\u00f1os tests, pero escala para admitir test funcionales complejas para aplicaciones y librerias. Si ha escrito pruebas unitarias para su c\u00f3digo Python antes, es posible que haya utilizado el m\u00f3dulo unittest integrado de Python. unittest proporciona una base s\u00f3lida sobre la cual construir su suite de pruebas, pero tiene algunas deficiencias. Varios marcos de prueba de terceros intentan abordar algunos de los problemas con unittest, y pytest ha demostrado ser uno de los m\u00e1s populares. pytest es un ecosistema basado en complementos y rico en funciones para probar su c\u00f3digo Python.","title":"Introducci\u00f3n"},{"location":"testing/pytest/#uso-de-pytest","text":"Si no se especifican argumentos, los archivos de tests se buscan en ubicaciones desde las rutas de tests (si est\u00e1n configuradas) o el directorio actual. Alternativamente, los argumentos de la l\u00ednea de comandos se pueden utilizar en cualquier combinaci\u00f3n de directorios, nombres de archivos o ID de nodo. En los directorios seleccionados, pytest busca archivos de test _ *.py o *_test.py . En los archivos seleccionados, pytest busca funciones de test con prefijo test. Veamos un ejemplo sencillo de esto: a) Escribir funciones a testear %% writefile algo . py def max ( values ): _max = values [ 0 ] for val in values : if val > _max : _max = val return _max def min ( values ): _min = values [ 0 ] for val in values : if val < _min : _min = val return _min Writing algo.py b) Escribir los tests %% writefile test_min_max . py import algo def test_min (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . min ( values ) assert val == 1 def test_max (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . max ( values ) assert val == 6 Writing test_min_max.py El archivo test_min_max.py tiene una palabra de test en su nombre. Nos sirve para diferenciar entre un script de python gen\u00e9rico respecto a uno de testeo. ! pytest test_min_max . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 2 items \u001b[0m test_min_max.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m2 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m ===============================\u001b[0m Esta es la salida. Hubo dos pruebas y ambas han pasado con \u00e9xito. Se muestra una salida m\u00e1s detallada con pytest -v test_min_max.py .","title":"Uso de Pytest"},{"location":"testing/pytest/#pytest-skip","text":"Con el decorador de skip , podemos omitir los test especificados. Hay varias razones para saltarse el test; por ejemplo, una base de datos/servicio en l\u00ednea no est\u00e1 disponible en este momento o nos saltamos los test espec\u00edficas de Linux en Windows. %% writefile skipping . py import algo import pytest @pytest . mark . skip def test_min (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . min ( values ) assert val == 1 def test_max (): values = ( 2 , 3 , 1 , 4 , 6 ) val = algo . max ( values ) assert val == 6 Writing skipping.py En el ejemplo, se omite test_min() . ! pytest skipping . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 2 items \u001b[0m skipping.py \u001b[33ms\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m========================= \u001b[32m\u001b[1m1 passed\u001b[0m, \u001b[33m1 skipped\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m =========================\u001b[0m","title":"Pytest skip"},{"location":"testing/pytest/#pytest-xfail","text":"Podemos usar el marcador xfail para indicar que espera que falle una prueba. Un caso de uso com\u00fan para esto es cuando encuentra un error en su software y escribe una prueba para documentar c\u00f3mo deber\u00eda comportarse el software. Esta prueba, por supuesto, fallar\u00e1 hasta que corrija el error. Para evitar tener una prueba fallida, marca la prueba como xfail . Una vez que se corrige el error, elimina el marcador xfail y tiene una prueba de regresi\u00f3n que asegura que el error no se repita. %% writefile xfail . py import pytest xfail = pytest . mark . xfail @xfail def test_hello (): assert 0 @xfail ( run = False ) def test_hello2 (): assert 0 @xfail ( \"hasattr(os, 'sep')\" ) def test_hello3 (): assert 0 @xfail ( reason = \"bug 110\" ) def test_hello4 (): assert 0 @xfail ( 'pytest.__version__[0] != \"17\"' ) def test_hello5 (): assert 0 def test_hello6 (): pytest . xfail ( \"reason\" ) @xfail ( raises = IndexError ) def test_hello7 (): x = [] x [ 1 ] = 1 Writing xfail.py En este caso, todos los test ser\u00e1n ignorados (con una x ), lo cu\u00e1l no afectar\u00e1 al resto de los tests (suponiendo que los tests pasen correctamente). ! pytest xfail . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m xfail.py \u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33mx\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m============================== \u001b[33m\u001b[1m7 xfailed\u001b[0m\u001b[33m in 0.13s\u001b[0m\u001b[33m ==============================\u001b[0m","title":"Pytest Xfail"},{"location":"testing/pytest/#pytest-marking","text":"Podemos usar marcadores para organizar los test unitarios. %% writefile marking . py import pytest @pytest . mark . a def test_a1 (): assert ( 1 ) == ( 1 ) @pytest . mark . a def test_a2 (): assert ( 1 , 2 ) == ( 1 , 2 ) @pytest . mark . a def test_a3 (): assert ( 1 , 2 , 3 ) == ( 1 , 2 , 3 ) @pytest . mark . b def test_b1 (): assert \"falcon\" == \"fal\" + \"con\" @pytest . mark . b def test_b2 (): assert \"falcon\" == f \"fal { 'con' } \" Writing marking.py Tenemos dos grupos de tests identificados por marcadores, \\(a\\) y \\(b\\) . Estas unidades son ejecutadas por pytest -m a marking.py y pytest -m b marking.py . ! pytest - m a marking . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 5 items / 2 deselected / 3 selected \u001b[0m marking.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m=============================== warnings summary ===============================\u001b[0m marking.py:3 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:3: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:8 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:13 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:18 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b marking.py:23 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:23: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b -- Docs: https://docs.pytest.org/en/latest/warnings.html \u001b[33m================= \u001b[32m3 passed\u001b[0m, \u001b[33m\u001b[1m2 deselected\u001b[0m, \u001b[33m\u001b[1m5 warnings\u001b[0m\u001b[33m in 0.02s\u001b[0m\u001b[33m ==================\u001b[0m ! pytest - m b marking . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 5 items / 3 deselected / 2 selected \u001b[0m marking.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[33m [100%]\u001b[0m \u001b[33m=============================== warnings summary ===============================\u001b[0m marking.py:3 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:3: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:8 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:8: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:13 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.a - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.a marking.py:18 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b marking.py:23 /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing/marking.py:23: PytestUnknownMarkWarning: Unknown pytest.mark.b - is this a typo? You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/latest/mark.html @pytest.mark.b -- Docs: https://docs.pytest.org/en/latest/warnings.html \u001b[33m================= \u001b[32m2 passed\u001b[0m, \u001b[33m\u001b[1m3 deselected\u001b[0m, \u001b[33m\u001b[1m5 warnings\u001b[0m\u001b[33m in 0.02s\u001b[0m\u001b[33m ==================\u001b[0m","title":"Pytest marking"},{"location":"testing/pytest/#pytest-parameterized-tests","text":"Con los tests parametrizados, podemos agregar m\u00faltiples valores a nuestras afirmaciones. Usamos el decorador @pytest.mark.parametrize . %% writefile parameterized . py import algo import pytest @pytest . mark . parametrize ( \"data, expected\" , [(( 2 , 3 , 1 , 4 , 6 ), 1 ), (( 5 , - 2 , 0 , 9 , 12 ), - 2 ), (( 200 , 100 , 0 , 300 , 400 ), 0 )]) def test_min ( data , expected ): val = algo . min ( data ) assert val == expected @pytest . mark . parametrize ( \"data, expected\" , [(( 2 , 3 , 1 , 4 , 6 ), 6 ), (( 5 , - 2 , 0 , 9 , 12 ), 12 ), (( 200 , 100 , 0 , 300 , 400 ), 400 )]) def test_max ( data , expected ): val = algo . max ( data ) assert val == expected Writing parameterized.py Pasamos dos valores a la funci\u00f3n de testeo: los datos y el valor esperado. En nuestro caso, probamos la funci\u00f3n min() con tres tuplas de datos. ! pytest parameterized . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 6 items \u001b[0m parameterized.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m6 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m ===============================\u001b[0m","title":"Pytest parameterized tests"},{"location":"testing/pytest/#pytest-fixtures","text":"Los tests deben ejecutarse en el contexto de un conjunto conocido de objetos. Este conjunto de objetos se denomina test fixture . %% writefile algo2 . py def sel_sort ( data ): if not isinstance ( data , list ): vals = list ( data ) else : vals = data size = len ( vals ) for i in range ( 0 , size ): for j in range ( i + 1 , size ): if vals [ j ] < vals [ i ]: _min = vals [ j ] vals [ j ] = vals [ i ] vals [ i ] = _min return vals Writing algo2.py %% writefile fixtures . py import algo2 import pytest # fijar valor data @pytest . fixture def data (): return [ 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ] # pasar data como argumento del test def test_sel_sort ( data ): sorted_vals = algo2 . sel_sort ( data ) assert sorted_vals == sorted ( data ) Writing fixtures.py ! pytest fixtures . py \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 1 item \u001b[0m fixtures.py \u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : para realizar los siguientes ejemplos, es necesario eliminar todos los archivos .py previos. # eliminar archivos .py ! rm *. py","title":"Pytest fixtures"},{"location":"testing/pytest/#pytest-layouts","text":"Los tests de Python se pueden organizar de varias formas. Los tests se pueden integrar en el paquete de Python o pueden descansar fuera de la librer\u00eda.","title":"Pytest layouts"},{"location":"testing/pytest/#integrated-tests","text":"A continuaci\u00f3n, mostramos c\u00f3mo ejecutar pruebas dentro de un paquete de Python. setup.py utils \u2502 algo.py \u2502 srel.py \u2502 __init__.py \u2502 \u2514\u2500\u2500\u2500tests algo_test.py srel_test.py __init__.py Tenemos este dise\u00f1o del paquete. Los test se encuentran en el subdirectorio de tests dentro del paquete.","title":"Integrated tests"},{"location":"testing/pytest/#a-crear-archivos-previos-del-ejemplos","text":"# crear carpetas ! mkdir utils tests # agregar archivo __init__.py ! touch utils / __init__ . py # agregar archivo __init__.py ! touch tests / __init__ . py","title":"a) crear archivos previos del ejemplos"},{"location":"testing/pytest/#b-crear-archivos-py-a-testear","text":"%% writefile setup . py from setuptools import setup , find_packages setup ( name = \"utils\" , packages = find_packages ()) Writing setup.py %% writefile utils / algo . py def sel_sort ( data ): if not isinstance ( data , list ): vals = list ( data ) else : vals = data size = len ( vals ) for i in range ( 0 , size ): for j in range ( i + 1 , size ): if vals [ j ] < vals [ i ]: _min = vals [ j ] vals [ j ] = vals [ i ] vals [ i ] = _min return vals def max ( values ): _max = values [ 0 ] for val in values : if val > _max : _max = val return _max def min ( values ): _min = values [ 0 ] for val in values : if val < _min : _min = val return _min Writing utils/algo.py %% writefile utils / srel . py def is_palindrome ( val ): return val == val [:: - 1 ] Writing utils/srel.py","title":"b) crear archivos .py a testear"},{"location":"testing/pytest/#c-crear-los-tests","text":"%% writefile tests / algo_test . py import utils.algo import pytest @pytest . mark . parametrize ( \"data\" , [ [ 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ], ( 3 , 2 , 1 , 5 , - 3 , 2 , 0 , - 2 , 11 , 9 ) ] ) def test_sel_sort ( data ): sorted_vals = utils . algo . sel_sort ( data ) assert sorted_vals == sorted ( data ) @pytest . fixture def values (): return ( 2 , 3 , 1 , 4 , 6 ) def test_min ( values ): val = utils . algo . min ( values ) assert val == 1 def test_max ( values ): val = utils . algo . max ( values ) assert val == 6 Writing tests/algo_test.py %% writefile tests / srel_test . py import utils.srel import pytest @pytest . mark . parametrize ( \"word, expected\" , [ ( 'kayak' , True ), ( 'civic' , True ), ( 'forest' , False ) ] ) def test_palindrome ( word , expected ): val = utils . srel . is_palindrome ( word ) assert val == expected Writing tests/srel_test.py # dejar tests en la ruta correcta ! mv tests utils","title":"c) crear los tests"},{"location":"testing/pytest/#d-correr-los-test","text":"! pytest -- pyargs utils \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m utils/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m utils/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m ===============================\u001b[0m","title":"d) correr los test !"},{"location":"testing/pytest/#tests-outside-the-package","text":"El siguiente ejemplo muestra un dise\u00f1o dela aplicaci\u00f3n donde los tests no est\u00e1n integrados dentro del paquete. setup.py src \u2514\u2500\u2500\u2500utils \u2502 algo.py \u2502 srel.py tests algo_test.py srel_test.py En este dise\u00f1o, tenemos tets fuera del \u00e1rbol de fuentes.","title":"Tests outside the package"},{"location":"testing/pytest/#a-crear-diseno-del-ejemplo","text":"# crear carpeta src ! mkdir src # mover carpeta utils ! mv utils src # mover carpeta tests ! mv src / utils / tests src /","title":"a) crear dise\u00f1o del ejemplo"},{"location":"testing/pytest/#b-correr-los-test","text":"! pytest \u001b[1m============================= test session starts ==============================\u001b[0m platform linux -- Python 3.8.5, pytest-5.4.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/fralfaro/PycharmProjects/python_development_tools/python_development_tools/testing plugins: hypothesis-5.49.0, cov-2.11.1 collected 7 items \u001b[0m src/tests/algo_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [ 57%]\u001b[0m src/tests/srel_test.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m [100%]\u001b[0m \u001b[32m============================== \u001b[32m\u001b[1m7 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m ===============================\u001b[0m Observaci\u00f3n : al final de cada presentaci\u00f3n, se eliminan los archivos que generamos de manera temporal. # eliminar archivos temporales #!rm -r cov_annotate cov_html htmlcov src *.py *.xml","title":"b) Correr los test !"}]}